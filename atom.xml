<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wangriyu’s Blog</title>
  <subtitle>子非鱼，安知鱼之乐也！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.wangriyu.wang/"/>
  <updated>2018-06-21T03:30:45.232Z</updated>
  <id>https://blog.wangriyu.wang/</id>
  
  <author>
    <name>鱼乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构 - 哈希</title>
    <link href="https://blog.wangriyu.wang/2018/06-Hash.html"/>
    <id>https://blog.wangriyu.wang/2018/06-Hash.html</id>
    <published>2018-06-14T16:00:00.000Z</published>
    <updated>2018-06-21T03:30:45.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在 MySQL 中，主要有四种类型的索引，分别为：B-Tree 索引，Hash 索引，Fulltext 索引和 R-Tree 索引。前一节已经讲了 B 类树的结构特点，这次讲哈希索引，至于后面的<a href="https://en.wikipedia.org/wiki/Full-text_search" target="_blank" rel="noopener">全文索引</a>和 <a href="https://zh.wikipedia.org/wiki/R%E6%A0%91" target="_blank" rel="noopener">R 树索引</a>感兴趣自己看吧。</p><p>之前讲 B 树时提到过哈希索引可以支持动态长度，而且由于 Hash 索引结构的特殊性，其检索效率非常高，最好的情况可以一次定位，查询效率远大于 B 树，但是实际运用中主要还是用 B 树做索引，因为哈希索引有以下局限性:</p><blockquote><p>（1）Hash 索引适合定值查询，不能做范围查询</p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样。</p><p>（2）Hash 索引无法用于排序操作</p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来进行任何排序运算；</p><p>（3）Hash 索引不能利用部分索引键查询</p><p>比如 (a,b,c) 形式的组合索引，查询中只用到了 a 和 b 也是可以查询的，如果使用 hash 表，组合索引会将几个字段合并 hash，没办法支持部分索引</p><p>（4）Hash 索引遇到大量 Hash 值相等的情况后性能并不一定就会比 B-Tree 索引高</p><p>数据库支持非唯一的 Hash 索引，如果遇到非唯一值，存储引擎会将他们链接到同一个 hash 键值下以一个链表的形式存在，然后在取得实际键值的时候再过滤不符合的键</p></blockquote><p>Hash 索引在 MySQL 中使用的并不是很多，目前主要是 Memory 和 NDB 引擎会使用；而常用的 Innodb 存储引擎和 MyISAM 引擎使用的索引还是 B+ 树为主</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">哈希表 (Hash Table)</a>，也叫散列表，是根据键（Key）转换而直接访问在存储地址的数据结构。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>比如我们有关键字 k，则其值存放在 f(k) 的存储位置上，因此不需要比较就可以找到记录。这个映射关系 f(x) 称为<strong>哈希函数(散列函数)</strong>，以此建立的表就是<strong>哈希表</strong>。</p><p>哈希表中存着的是包含存储单元的数组，这些存储单元我们称作<strong>槽 (slot)</strong> 或者<strong>桶 (bucket)</strong> ，每个存储单元可以容纳一个或多个关键字信息。理想情况下，完美的散列函数能为关键字找到唯一的独占的桶，但大多数情况下用到的散列函数都是不完美的，会存在冲突；</p><p>对不同的关键字可能得到同一散列地址，即 k1 != k2，而 f(k1) == f(k2)，这种现象称为<strong>冲突</strong> (Collision)。具有相同函数值的关键字对该散列函数来说称做<strong>同义词</strong>。</p><p>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为<strong>均匀散列函数</strong>（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://src.wangriyu.wang/images/blog/hash/hash-principle-0.svg" alt="image"></p><p>输入一个关键字 “lies”，经过散列得到值 9，对应哈希表得到我们要的地址 20</p><p>从关键字到索引值的转换过程使用的就是散列函数，散列函数有很多种，比如一种简单的散列方式如下:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/hash-principle-1.svg" alt="image"></p><p>取关键字每个字符的 ASCII 码，相加，即 lies -&gt; 108+105+101+115 -&gt; 429</p><p>但是我们的表只有 30 项，那么可以再把上面的值模 30: 429 mod 30 = 9</p><p>一个散列就完成了</p><p>但是继续输入发现:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/hash-principle-2.svg" alt="image"></p><p>关键字 “foes” 散列后也对应表下标 9，这就是冲突，”lies” 和 “foes” 是同义词</p><p>每种哈希表实现都要有处理冲突的方法，处理冲突也有很多方式，比如这里可以用简单的链表来处理:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/hash-principle-3.svg" alt="image"></p><p>之前哈希表中索引对应的就是具体的地址，而现在改成一个指向链表的指针，所有同义词都存在相应链表中</p><p>但是我们怎么直到链表哪个是 “lies” 哪个是 “foes” 呢，可以在链表每个节点中添加关键字信息:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/hash-principle-4.svg" alt="image"></p><p>这样冲突就算处理了，但是这种哈希表结构的最坏情况是 O(n)，不同于之前 O(1)。因为假如大部分关键字都是冲突的，那么这些关键字就变为链表查询了。</p><p>因此一个<strong>均匀的散列函数</strong>和一个高效的<strong>处理冲突的方法</strong>对哈希表来说至关重要</p><p>下面会介绍一些常见的哈希函数和处理冲突的方法</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><ol><li>直接定址法：取关键字或关键字的某个线性函数值为散列地址。即 hash(k) = k 或 hash(k) = a * k + b，其中 a, b 为常数（这种散列函数叫做自身函数）</li><li>数字分析法：假设关键字是以 r 为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址</li><li>平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。比如 {421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取中间的两位数{72，89，00}作为 Hash 地址</li><li>折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。比如图书的 ISBN 号为 8903-241-23，可以将 address(key)=89+03+24+12+3 作为 Hash 地址。</li><li>随机数法</li><li>除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址。即 hash(k) = k mod p, p &lt;= m。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对 p 的选择很重要，一般取素数或 m，若 p 选择不好，也容易产生冲突</li></ol><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><h4 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h4><p>影响产生冲突多少有以下三个因素：</p><ul><li>散列函数是否均匀</li><li>处理冲突的方法</li><li>散列表的负载因子</li></ul><p>散列表的负载因子定义为：α = 填入表中的元素个数 / 散列表的长度。α 是散列表装满程度的标志因子。<br>由于表长是定值，α 与“填入表中的元素个数”成正比，所以 α 越大，表明填入表中的元素越多，产生冲突的可能性就越大。</p><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>1、<a href="https://en.wikipedia.org/wiki/Open_addressing" target="_blank" rel="noopener">开放寻址 (open addressing/closed hashing)</a>: 一旦发生了冲突，通过<strong>探测</strong>寻找其他空的位置，然后插入。</p><p>$ hash_i = (hash(k) + d_i) $ mod m, i = 1, 2, 3…m-1, 其中 hash(k) 为散列函数，$ d_i $ 是增量序列，m 为哈希表长，i 为已发生冲突的次数。</p><p>hash(k) 是初始的探测位置，之后的探测位置 $ hash _1, hash_2, hash_3…hash _{m-1} $ 形成一个探测序列。</p><p>如果 $ d_i $ = i = 1, 2, 3…m-1，则为<strong>线性探测</strong>，相当于逐一往下找表空闲位置</p><p>如果 $ d_i = \pm1^2, \pm2^2, \pm3^2…\pm k^2 $，则为<strong>二次探测(或者叫平方探测)</strong>，相当于探测间隔为 $ \pm i^2 $</p><p>如果 $ d_i = i * rehash(k) $，rehash 是另一个哈希函数，则为<strong>双散列探测</strong></p><p>如果 $ d_i $ = 伪随机数序列，则为<strong>伪随机探测</strong></p><p>对开放寻址散列表性能的关键影响是载荷因子。随着载荷系数增加到 100％，可能需要查找或插入给定关键字的探针数量急剧增加。一旦表格变满，探测算法甚至可能无法终止。即使具有良好的散列函数，也应严格限制载荷因子在 0.7-0.8 以下，比如 Java 的系统库限制了荷载因子为 0.75，超过此值将动态调整散列表大小。</p><p>2、单独链表法。即上述原理用到的方法，也叫<strong>拉链法</strong>，链表的使用方式可以分很多种，可以见 <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining" target="_blank" rel="noopener">WikiPedia 的事例</a>，另外算法导论里提到一种完全散列的方式，相当于二维哈希表，每个槽对应的是另一个哈希列表，也值得借鉴</p><p>3、再散列: $ hash_i = rehash_i(k), i = 1, 2, 3…k $, 在发生冲突时，使用其他散列函数计算哈希值，直到冲突不再发生。这种方法不易产生“聚集”，但增加了计算时间。</p><p>4、建立一个公共溢出区</p><h3 id="动态哈希"><a href="#动态哈希" class="headerlink" title="动态哈希"></a>动态哈希</h3><p>前面的问题都是以哈希表定长为基础的，但是当关键字较多时，哈希表出现<strong>聚集</strong>时，性能会急剧下降。</p><p>即散列表的载荷因子较大时需要考虑扩充哈希表大小，如果是静态 hash，则需要新建一张更大的表，然后将所有关键字重新散列到新的表中，之后删除旧表</p><p>而动态散列可以在哈希表元素增长的同时，动态的调整 hash 桶的数目，动态 hash 不需要对原有元素进行重新插入(重组)，而是在原基础上，进行动态的桶扩展。</p><p>有以下三种方法可以实现动态 hash:</p><ul><li>多 hash 表</li><li>可扩展的动态散列</li><li>线性散列</li></ul><h4 id="多-hash-表"><a href="#多-hash-表" class="headerlink" title="多 hash 表"></a>多 hash 表</h4><p>多 hash 表就是采用多张哈希表来扩充原哈希表。</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Hash-0.svg" alt="hash table"></p><p>如图，哈希函数为 hash(k) = k % 5，每个桶最多含 4 个关键字</p><p>当我们要插入关键字 5 时，hash 值为 0，应该插入 Bucket 1 中，而且 Bucket 1 有空闲位置，直接插入即可；</p><p>当我们要插入关键字 3 时，hash 值为 3，应该插入 Bucket 3 中，但是 Bucket 3 已经满了，此时新建一张 hash 表来完成插入</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Hash-1.svg" alt="hash table"></p><p>对于此种方式，执行插入、查找、删除操作时，均需先求得 hash 值 x。</p><ul><li>插入时，得到当前的 hash 表的个数，并分别取得各个 hash 表的 x 位置上的索引项，若其中某个项指向的桶存在空闲位置，则插入之。同时，在插入时，可保持多个 hash 表在某个索引项上桶中元素的个数近似相等。若不存在空闲位置，则简单的进行表扩充，即新建一个 hash 表，如上所示</li><li>查找时，由于某个记录值可能存在当前 hash 结构的多个表中，因此需同时在多个 hash 表的同一位置上进行查找操作，等待所有的查找结束后，方可判定该元素是否存在。由于该种结构需进行多次查找，当表元素非常多时，为提高效率，在多处理器上可采用多线程，并发执行查找操作</li><li>删除操作，与上述过程基本类似。需要注意的是，若删除操作导致某个 hash 表元素为空，这时可将该表从结构中剔除</li></ul><p>这种方式的优点是设计和实现比较简单的。缺点是占用空间大，而且关键字较密集时空间利用率低。</p><h4 id="可扩展的动态散列"><a href="#可扩展的动态散列" class="headerlink" title="可扩展的动态散列"></a>可扩展的动态散列</h4><p>引入一个仅存储桶指针的索引数组，用翻倍的索引项数来取代翻倍的桶的数目，且每次只分裂有溢出的桶，从而减小翻倍的代价。</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Extendible-hashing-0.svg" alt="Extendible hashing"></p><p>如图所示哈希表有一个标识表示全局位深度 (Global Depth)，全局位深度表示取哈希值的低几位作为索引，比如 hash(k4) = 0100，全局位深度为 2，则取低两位 00 归属到 00 索引的桶中，而且哈希表索引项数始终等于 2 ^ Global Depth；桶中有一个本地位深度 (Local Depth)，本地位深度表示当前桶中元素的低几位是一样的；图中给出的桶中元素表示哈希后的值，比如桶 1 中 4 表示哈希值为 0100 的关键字 k4</p><ul><li>插入时，计算出哈希值再根据全局位深度匹配索引项，如果找到的桶未满，则直接插入即可；如果桶已满，则判断当前桶的本地位深度 L 与全局位深度 G 的大小关系: 如果 L = G，此时只有一个指针指向当前桶，则扩展索引，本地位深度和全局位深度均加一，索引项翻倍，重组当前桶的元素；如果 L &lt; G，此时不止一个指针指向当前桶，故不需要翻倍索引项，只需分裂出一个桶，将本地位深度加一然后重组当前桶元素即可</li><li>查找时，对于需要查找的关键字 x，hash(x) = y，根据当前 hash 表的全局位深度，决定对 y 取其后 G 位，位数不够用 0 填充，找到对应的索引项，从而找到对应的桶，在桶中逐一进行比较</li><li>删除时，和查找操作类似，先定位元素，删除之。若删除时发现桶为空，则可以考虑将该桶与其兄弟桶进行合并，并使局部位深度减一</li></ul><p>插入实例:</p><p>当我们插入某个关键字 k13，hash(k13) = 1101，对应索引 01 的桶 Bucket 2，桶未满直接插入即可；</p><p>再插入某个关键字 k20，hash(k20) = 10100，对应索引 00 的桶 Bucket 1，桶已满而且本地位深度等于全局位深度，需要扩展索引，全局位深度和本地位深度均加一，并重组当前桶的元素，变为下图:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Extendible-hashing-1.svg" alt="Extendible hashing"></p><p>继续插入某个关键字 k25，hash(k25) = 11001，对应索引 001 的桶 Bucket 2，桶已满而且本地位深度小于全局位深度，当前桶存在两个指针，只需要分裂出一个桶即可并将桶的本地位深度加一，如图:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Extendible-hashing-2.svg" alt="Extendible hashing"></p><p>这种方式的优点是可以可动态进行桶的增长，且增长的同时，用索引项的翻倍代替桶数翻倍的传统做法，可用性更好。缺点是当散列的数据分布不均或偏斜较大时，会使得索引项的数目很大，数据桶的利用率很低；还有索引的增长速度，是指数级增长，扩展较快</p><h4 id="线性散列"><a href="#线性散列" class="headerlink" title="线性散列"></a>线性散列</h4><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%95%A3%E5%88%97" target="_blank" rel="noopener">线性散列</a>能随数据的插入和删除，适当的对 hash 桶数进行调整，一次只分裂一个桶，线性散列不需要存放数据桶指针的专门索引项。</p><p>定义:</p><table><thead><tr><th>标识符</th><th>描述</th></tr></thead><tbody><tr><td>$h_0,h_1,h_2$…</td><td>一系列哈希函数，后者的范围总是前者的两倍，i 为下标，$h_i(key) = hash(key) mod (N*2^i)$</td></tr><tr><td>N</td><td>桶的初始个数，必须是 2 的幂次方</td></tr><tr><td>$d_i$</td><td>多少比特位用于表示 N，N = $2^{d_i}$</td></tr><tr><td>Level</td><td>当前轮数，每轮的初始桶数等于 $N*2^{Level}$</td></tr><tr><td>Next</td><td>一个指针指向需要分裂的桶，每次发生分裂的桶总是由 Next 决定，与当前值被插入的桶已满或溢出无关</td></tr><tr><td>Load Factor</td><td>负载因子，当桶中记录数达到该值时进行分裂；也可选择当桶满时才进行分裂</td></tr></tbody></table><p>当某个桶发生溢出时，可以将溢出元素以链表的形式链在桶后；<br>可以监控整张哈希表或者桶的负载因子，视情况选择是否分裂，比如全表的负载达到 0.75 可以对当前桶进行分裂，也可以选择只有桶满了才分裂；</p><p>实例:</p><p>初始状态 N = 4, Level = 0, Next 指向第一个桶</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-0.svg" alt="Linear-hashing"></p><p>插入某个关键字 k37，hash(k37) = 37 = 100101，$h_0(k37)$ = 01(取低两位)，对应编号 1 的桶，此时桶未满直接插入即可:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-1.svg" alt="Linear-hashing"></p><p>插入某个关键字 k43，hash(k43) = 43 = 101011，$h_0(k43)$ = 11(取低两位)，对应编号 3 的桶，此时桶已满需要分裂:<br>首先把 43 链在桶 3 后面，然后分裂 Next 指向的桶 0，产生一个新桶，新桶编号 = N + Next = 4 + 0 = 100，Next 指向下一个桶；最后把桶 0 的元素按 h1 散列重组</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-2.svg" alt="Linear-hashing"></p><p>继续插入某个关键字 k29，hash(k29) = 29 = 11101，$h_0(k29)$ = 01，对应编号 1 的桶，此时桶已满需要分裂:<br>也是按刚才的步骤处理，不过这次 Next 指向的桶就是当前桶</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-3.svg" alt="Linear-hashing"></p><p>向桶 1 中连续插入 17，33，41，引起分裂:</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-4.svg" alt="Linear-hashing"></p><p>继续向桶 1 插入 57，引起分裂，需要注意的是这时 Next 指针已经遍历过初始的四个桶，第一轮已结束，Level 加一，Next 指向第一个桶，第二轮初始为八个桶(即 N = 8):</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-5.svg" alt="Linear-hashing"></p><p>插入就是如上形式进行，接下来看怎么查找:</p><p>假如要查找某个关键字 key 对应的位置，如果 $Next \leq h _{Level}(key) \leq N-1$，则查询 $h _{Level}$ 列的与低 $d_i$ 位对应的桶，否则查询 $ h _{Level+1} $ 列的与低 $d_i$ +1 位对应的桶。</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-3.svg" alt="Linear-hashing"></p><p>在此图中 N = 4，Level = 0，Next = 2，$d_0$ = 2</p><p>比如查询 k44，$h_0(k44)$ = 00，00(= 0) 不在 2 和 3 之间，则查询 h1 列与 k44 低三位 (100) 对应的桶，找到编号为 4 的桶，再从桶找到对应位置；</p><p>假如查询的是 k7，$h_0(k7)$ = 11，11(= 3) 在 2 和 3 之间，则查询 h0 列与 k7 低两位 (11) 对应的桶，找到编号为 3 的桶，再从桶中找到对应位置</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Linear-hashing-5.svg" alt="Linear-hashing"></p><p>在此图中 N = 8，Level = 1，Next = 0，$d_1$ = 3</p><p>假如查询 k44，$h_1(k44)$ = 100，100(= 4) 在 0 和 7 之间，所以查询 h1 列与 100 对应的桶，即编号为 4 的桶；</p><p>其他关键字的 h1 值都是在范围 [Next, N] 内的，所以都是找 h1 列的</p><p>线性散列的删除操作是插入操作的逆操作，若溢出块为空，则可释放。若删除导致某个桶元素变空，则 Next 指向上一个桶。当 Next 减少到 0，且最后一个桶也是空时，则 Next 指向 N/2 - 1 的位置，同时 Level 值减 1。</p><p>线性散列比可扩展动态散列更灵活，且不需要存放数据桶指针的专门索引项，节省了空间；但如果数据散列后分布不均匀，导致的问题可能会比可扩展散列还严重</p><h2 id="分布式哈希"><a href="#分布式哈希" class="headerlink" title="分布式哈希"></a>分布式哈希</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%9B%9C%E6%B9%8A%E8%A1%A8" target="_blank" rel="noopener">分布式哈希表 - DHT</a>增加或移除节点只改变邻近节点所拥有的关键值集合，而其他节点的则不会被改变。传统的散列表，若增加或移除一个位置，则整个关键值空间必须重新散列。</p><p>其中<a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">一致性哈希</a>算法非常适用于分布式哈希表，一致性哈希允许任意顺序插入或删除存储桶，不同于线性散列那样需要顺序处理。</p><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>有 N 台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责 1/N 的服务。</p><p>常用的算法是对 hash 结果模 N 取余，比如 N = 5，hash = 103，余数为 3 则分发到编号为 3 的服务器上。但是这样的算法存在严重问题，如果有某台机器宕机或者新添加服务器，都会造成大量缓存请求失效或者需要转移重组数据。</p><p>而使用一致性哈希后，同样增加或者删除服务器节点只会对少量数据产生影响，不需要大规模迁移数据。比如分布式缓存系统节点数多，而且容易变动，非常适合使用一致性哈希</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>假设一致性哈希算法的结果是 32 位的 Key 值，将这 2^32 个数值映射在一个环形空间上，则对应有 2^32 个缓存区。比如下图中五个 Key 值分布在环形空间上</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-0.svg" alt="Consistent-hashing"></p><p>每一个缓存节点（Shard）也遵循同样的 Hash 算法，比如利用 IP 做 Hash，映射到环形空间当中</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-1.svg" alt="Consistent-hashing"></p><p>然后按顺时针将 Key 归属到最近的节点上，比如 K5、K1 归属为节点 N1 上</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-2.svg" alt="Consistent-hashing"></p><p>增加节点 N4 时，我们只需要改变 K5 的归属即可，不会对其他节点和数据造成影响</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-3.svg" alt="Consistent-hashing"></p><p>删除节点 N1 时，我们只需要将 K1 归属到 N2 上就行</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-4.svg" alt="Consistent-hashing"></p><p>但是仍会有分布不均的情况，特别是服务器节点较少时，比如下图大部分键值都流向某个单一节点</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-5.svg" alt="Consistent-hashing"></p><p>为了应对这种情况，引入了虚拟节点的概念，将原来的一个物理节点映射出多个子节点，让子节点代替物理节点放置在环形空间中</p><p><img src="https://src.wangriyu.wang/images/blog/hash/Consistent-hashing-6.svg" alt="Consistent-hashing"></p><p>比如原本的物理节点 N1 使用的关键字是自己的 IP 192.168.1.109，其位置是 hash(“192.168.1.109”)。现在为其创建两个虚拟节点 N1_1 和 N1_2，两个子节点可以使用 IP + 编号 的方式计算哈希，比如 hash(“192.168.1.109#1”) 和 hash(“192.168.1.109#2”)，同理为 N2 也创建了两个虚拟节点，</p><p>创建虚拟节点的好处是分布更均匀</p><h2 id="其他常见散列函数"><a href="#其他常见散列函数" class="headerlink" title="其他常见散列函数"></a>其他常见散列函数</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p><a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">Message-Digest Algorithm 5 - 消息摘要算法</a>，一种被广泛使用的密码散列函数，可以产生出一个 128 位的散列值</p><p>可以应用于文件校验，例如，服务器预先提供一个 MD5 校验和，用户下载完文件以后，用 MD5 算法计算下载文件的 MD5 校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错</p><p>MD5 是输入不定长度信息，输出固定长度 128 位的算法。经过程序流程，生成四个 32 位数据，最后联合起来成为一个 128 位散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。</p><p>但是 MD5 可以被破解，不适合高度安全性的场景，比如不能用于密钥认证和数字签名</p><h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p><a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="noopener">Secure Hash Algorithm - 安全散列算法</a>是一个密码散列函数家族，也能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。安全性高于 MD5，比如数字签名常用的就是 SHA-256。</p><p>SHA 分为 SHA-0、SHA-1、SHA-2、SHA-3 四个大版本，其中 SHA-0 和 SHA-1 输出的散列值为 160 位；SHA-2 细分为多种，比如 SHA-256 输出的是 256 位散列值，另外还有 SHA-224、SHA-384、SHA-512 等等；SHA-3 是 2015 年正式发布的，SHA-3 并不是要取代 SHA-2，因为 SHA-2 目前并没有出现明显的弱点，由于对 MD5 出现成功的破解，以及对 SHA-0 和 SHA-1 出现理论上破解的方法，<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E5%AE%B6%E6%A8%99%E6%BA%96%E6%8A%80%E8%A1%93%E7%A0%94%E7%A9%B6%E6%89%80" target="_blank" rel="noopener">NIST</a> 感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的 SHA-3</p><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97" target="_blank" rel="noopener">Cyclic redundancy check - 循环冗余校验</a>是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。一般来说，循环冗余校验的值都是 32 位的整数。</p><p>CRC 的计算过程网络课程便讲过，不算复杂，这里不深入。WikiPedia 上提供了一些 CRC 变体的描述，感兴趣可以了解一下。</p><p>尽管在错误检测中非常有用，CRC 并不能可靠地校验数据完整性，因为 CRC 多项式是线性结构，可以非常容易地故意改变量据而维持 CRC 不变。一般使用<a href="https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC" target="_blank" rel="noopener">Message authentication code</a>校验数据完整性</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Hash Table - WikiPedia</a></li><li><a href="https://www.interviewcake.com/article/python/data-structures-coding-interview?course=dsa#hash-tables" target="_blank" rel="noopener">Data Structures for Coding Interviews - Hash Table</a></li><li><a href="http://blog.sina.com.cn/s/blog_5e4516af01019frj.html" target="_blank" rel="noopener">动态 hash 思想方法</a></li><li><a href="https://en.wikipedia.org/wiki/Extendible_hashing" target="_blank" rel="noopener">Extendible hashing - WikiPedia</a></li><li><a href="https://www.youtube.com/watch?v=h37Jhr21ByQ&amp;t=61s" target="_blank" rel="noopener">Linear Hashing - Youtube</a></li><li><a href="https://mp.weixin.qq.com/s/yimfkNYF_tIJJqUIzV7TFA" target="_blank" rel="noopener">漫画：什么是一致性哈希？</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94" target="_blank" rel="noopener">雪崩效应 - WikiPedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      包含静态哈希表、三种动态哈希、一致性哈希的原理以及其他哈希函数的应用
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://blog.wangriyu.wang/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://blog.wangriyu.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希" scheme="https://blog.wangriyu.wang/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="数据库" scheme="https://blog.wangriyu.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 - 树</title>
    <link href="https://blog.wangriyu.wang/2018/06-Tree.html"/>
    <id>https://blog.wangriyu.wang/2018/06-Tree.html</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-06-17T12:44:06.186Z</updated>
    
    <content type="html"><![CDATA[<p>与数据库相关的树结构主要为 B 类树，B 类树通常用于数据库和操作系统的文件系统</p><p>在学习 B 类树之前先复习一下二叉查找树的概念和红黑树</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树 - Binary Tree</a> 是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>完美二叉树 (Perfect Binary Tree): 除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充</li><li>完全二叉树 (Complete Binary Tree): 除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐</li><li>满二叉树 (Full/Strictly Binary Tree): 除了叶子结点之外的每一个结点都有两个孩子结点</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>前序遍历: 首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树</li><li>中序遍历: 首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，再访问根结点，最后遍历右子树</li><li>后序遍历: 首先遍历左子树，然后遍历右子树，最后访问根结点。在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点</li></ul><ul><li>深度优先搜索: 顾名思义，查找时深度优先，从根结点访问最远的结点直到找到所有节点。前序，中序和后序遍历都是深度优先遍历的特例</li><li>广度优先搜索: 广度优先遍历会先访问离根节点最近的节点，二叉树的广度优先遍历又称按层次遍历。算法借助队列实现</li></ul><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">二叉查找树 - Binary Search Tree</a>: 也称二叉搜索树、有序二叉树。对于根树和所有子树都满足，每个节点都大于左子树元素，而小于右子树元素，<strong>且没有键值相等的结点</strong></p><p>搜索、插入、删除的复杂度等于<strong>树高</strong>，期望 $O(\log_2^n)$，最坏 O(n)（数列有序，树退化成线性表）</p><blockquote><p>二叉查找树动态展示: <a href="https://visualgo.net/zh/bst" target="_blank" rel="noopener">https://visualgo.net/zh/bst</a></p></blockquote><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>当数据基本有序时，二叉查找树会退化成线性表，查找效率严重下降</p><p>所以后面出现了很多改进的<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91" target="_blank" rel="noopener">平衡树</a>结构以满足树高最坏也为 $O(\log_2^n)$，<br>如<a href="https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91" target="_blank" rel="noopener">伸展树 (Splay Tree)</a>、平衡二叉树 (SBT)、<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">AVL 树</a>、红黑树等</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树 - Red–black tree</a> 是一种自平衡二叉查找树，除了符合二叉查找树的性质外，它还满足以下五条性质:</p><ol><li>每个结点要么是红的，要么是黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的（叶子结点指树尾端 NIL 指针或 NULL 结点，不包含数据，只充当树在此结束的指示）</li><li>如果一个结点是红的，那么它的两个子节点都是黑的 (从根到每个叶子的所有路径上不能有两个连续的红色节点)</li><li>对于任一结点而言，其到叶结点树尾端 NIL 指针的每一条路径都包含相同数目的黑结点</li></ol><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-0.svg" alt="一棵红黑树"></p><h3 id="平衡优势"><a href="#平衡优势" class="headerlink" title="平衡优势"></a>平衡优势</h3><p>上述约束确保了红黑树的关键特性: <strong>从根到叶子的最长路径不会超过最短路径的两倍</strong></p><p>证明: 主要看性质 4 和 性质 5，假设从根到叶子的最短路径 a 上有黑色节点 n 个，最长路径 b 肯定是交替的红色和黑色节点，而根据性质 5 可知从根到叶子的所有路径都有相同数目的黑色节点，<br>这就表明 b 的黑色节点也为 n 个，但 b 出现的红色节点不可能超过黑色节点个数，否则会破坏性质 4 (抽屉原理)，所以从根到叶子的最长路径不会超过最短路径的两倍</p><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。<br>恢复红黑树的性质需要少量 $O(\log_2^n)$ 的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 $O(\log_2^n)$ 次。</p><p>红黑树发生变更时需要 [变色] 和 [旋转] 来调整，其中旋转又分 [左旋] 和 [右旋]。</p><ul><li>变色就是更改颜色</li><li>左旋: 以 X 为支点<code>逆时针</code>旋转红黑树的两个节点 X-Y，使得父节点被自己的右孩子取代，而自己下降为左孩子</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/left.svg" alt="左旋"></p><ul><li>右旋: 以 X 为支点<code>顺时针</code>旋转红黑树的两个节点 X-Y，使得父节点被自己的左孩子取代，而自己下降为右孩子</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/right.svg" alt="右旋"></p><p>旋转过程中只需要做三次指针变更就行</p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>插入节点的位置跟二叉查找树的寻找方法基本一致，如果插入结点 z 小于当前遍历到的结点，则到当前结点的左子树中继续查找，如果 z 大于当前结点，则到当前结点的右子树中继续查找，<br>如果 z 依然比此刻遍历到的新的当前结点小，则 z 作为当前结点的左孩子，否则作为当前结点的右孩子。而红黑树插入节点后，为了保持约束还需要进行调整修复(变色加旋转)。</p><p>所以插入步骤如下: 红黑树按二叉查找树的规则找到位置后插入新节点 z，z 的左孩子、右孩子都是叶子结点 nil， z 结点初始都为红色，再根据下述情形进行变色旋转等操作，最后达到平衡。</p><ul><li>情形 1: 如果<strong>当前节点是根结点</strong>，为满足性质 2，所以直接把此结点 z 涂为黑色</li><li>情形 2: 如果<strong>当前结点的父结点是黑色</strong>，由于不违反性质 2 和性质 4，红黑树没有被破坏，所以此时也是什么也不做</li></ul><p>比如上图插入 12 时满足情形 2:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-1.svg" alt="插入 12"></p><p>以下情形需要作出额外调整:</p><ul><li>情形 3: 如果<strong>当前结点的父结点是红色</strong>且<strong>祖父结点的另一个子结点(叔叔结点)是红色</strong></li><li>情形 4: <strong>当前结点的父结点是红色</strong>，<strong>叔叔结点是黑色</strong>或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置<strong>不在同侧</strong></li><li>情形 5: <strong>当前结点的父结点是红色</strong>，<strong>叔叔结点是黑色</strong>或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置<strong>在同侧</strong></li></ul><p>下面着重讲讲后三种情况如何调整</p><h5 id="情形-3"><a href="#情形-3" class="headerlink" title="情形 3"></a>情形 3</h5><p><code>当前结点的父结点是红色且祖父结点的另一个子结点(叔叔结点)是红色</code></p><blockquote><p>因为当前节点的父节点是红色，所以父节点不可能是根节点，当前节点肯定有祖父节点，也就有叔叔节点</p></blockquote><p><strong>解决步骤</strong>: 将当前结点的父结点和叔叔结点涂黑，祖父结点涂红，再把祖父结点当做新节点(即当前节点的指针指向祖父节点)重新检查各种情形进行调整</p><p>由于对称性，不管父结点是祖父结点的左子还是右子，当前结点是其父结点的左子还是右子，处理都是一样的</p><p>我们插入 21 这个元素，当前节点指向 21：</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-2.svg" alt="插入 21"></p><p>此时会发现 21、22 两个红色相连与性质 4 冲突，但 21 节点满足情形 3，修复后:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-3.svg" alt="调整情形 3"></p><p>此时当前节点指向 21 的祖父节点，即 25。而 25 节点同样遇到情形 3 的问题，继续修复:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-4.svg" alt="继续调整情形 3"></p><p>此时当前节点指向根节点，满足情形 1，将 14 节点涂黑即可恢复红黑树平衡</p><h5 id="情形-4"><a href="#情形-4" class="headerlink" title="情形 4"></a>情形 4</h5><p><code>当前结点的父结点是红色，叔叔结点是黑色或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置不在同侧</code></p><p><strong>解决步骤</strong>:</p><ul><li>如果当前节点是父节点的右子，父节点是祖父节点的左子，以当前结点的父结点做为新结点(即当前节点的指针指向父节点)，并作为支点左旋</li><li>如果当前节点是父节点的左子，父节点是祖父节点的右子，以当前结点的父结点做为新结点(即当前节点的指针指向父节点)，并作为支点右旋</li></ul><p>在上图的基础上我们继续插入 5 这个元素:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-5.svg" alt="插入 5"></p><p>可以看出 5 是父节点的左子，而父节点是祖父节点的右子，不同侧则为情形 4，将当前节点指向 5 的父节点 6，并以 6 为支点进行右旋:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-6.svg" alt="插入情形 4"></p><p>此时当前节点是 6，而 6 是父节点 5 的右子，父节点 5 也是祖父节点 1 的右子，同侧则转为情形 5，继续往下看</p><h5 id="情形-5"><a href="#情形-5" class="headerlink" title="情形 5"></a>情形 5</h5><p><code>当前结点的父结点是红色，叔叔结点是黑色或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置在同侧</code></p><p><strong>解决步骤</strong>:</p><ul><li>首先把父结点变为黑色，祖父结点变为红色</li><li>如果当前节点是父节点的左子，父节点是祖父节点的左子，以祖父结点为支点右旋</li><li>如果当前节点是父节点的右子，父节点是祖父节点的右子，以祖父结点为支点左旋</li></ul><p>在上一张图的基础上修改节点 5 为黑色，节点 1 为红色，再以 1 为支点左旋:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-7.svg" alt="插入情形 5"></p><p>此时便恢复平衡</p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除节点 X 时第一步先判断两个孩子是否都是非空的，如果都非空，就先按二叉查找树的规则处理:</p><p>在删除带有两个非空子树的节点 X 的时候，我们可以找到左子树中的最大元素(或者右子树中的最小元素)，并把这个最值<strong>复制</strong>给 X 节点，只代替原来要删除的值，不改变节点颜色。</p><p>然后我们只要删除那个被复制出值的那个节点就行，因为是最值节点所以它的孩子不可能都非空。</p><p>因为只是复制了一个值，不违反任何性质，这就把原问题转化为<strong>如何删除最多有一个非空子树的节点的问题</strong>。它不关心这个节点是最初要删除的节点还是被复制出值的那个节点。</p><p>我们以图为例，图中三角形代表可能为空的子树:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-0.svg" alt="取值复制"></p><p>节点 X 是要删除的节点，发现它的两个子树非空，我们可以找左子树中最大的元素 Max (也可以找右子树中最小的元素 Min)，把 Max 值(或者 Min 值)复制到 X 上覆盖原来的值，不修改其他属性，然后删除 Max 节点(或 Min 节点)即可，可以很清楚的看到最值节点最多只会有一个非空子树</p><hr><p>接下来就是如何处理删除最多有一个非空子树的节点 X 的问题</p><p>简单情形:</p><ol><li>如果 X 的两个儿子都为空，即均为叶子，我们将其中任意一个看作它的儿子</li><li>如果 <strong>X 是一个红色节点</strong>，它的父亲和儿子一定是黑色的，所以简单的<strong>用它的黑色儿子替换它</strong>就行，这并不会破坏性质 3 和性质 4，通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质 5</li><li>如果 <strong>X 是黑色而它的儿子是红色</strong>，如果只是删除这个黑色节点，<strong>用它的红色儿子代替</strong>的话，会破坏性质 5，我们可以<strong>重绘它的儿子为黑色</strong>，则曾经通过 X 的所有路径将通过它的黑色儿子，这样可以继续保持性质 5</li></ol><p>如果 X 和它的儿子都是黑色，这是一种复杂的情况，我们单拎出来讲</p><p>我们首先把要删除的节点 X 替换为它的儿子。出于方便，称呼这个新上位的儿子为 N，称呼它的兄弟为 S，使用 P 称呼 N 的新父亲，SL 称呼 S 的左儿子，SR 称呼 S 的右儿子</p><p>有以下六种情形需要考虑:</p><h5 id="情形-1"><a href="#情形-1" class="headerlink" title="情形 1"></a>情形 1</h5><p>N 是新的根</p><p>我们不需要做什么，因为所有路径都去除了一个黑色节点，而新根也是黑色的，所以性质都保持着</p><blockquote><p>情形 2、5、6 涉及到左右不同的情况，只取一种处理</p></blockquote><h5 id="情形-2"><a href="#情形-2" class="headerlink" title="情形 2"></a>情形 2</h5><p>S 是红色</p><ul><li>交换兄弟 S 和父亲 P 的颜色</li><li>如果 N 是其父亲的左节点，我们在 N 的父亲上做左旋，把红色兄弟转换成 N 的祖父</li><li>如果 N 是其父亲的右节点，我们在 N 的父亲上做右旋，把红色兄弟转换成 N 的祖父</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-2.svg" alt="删除情形 2"></p><p>完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在 N 有了一个黑色的兄弟和一个红色的父亲，所以我们可以接下去按情形 4、情形 5 或情形 6 来处理</p><h5 id="情形-3-1"><a href="#情形-3-1" class="headerlink" title="情形 3"></a>情形 3</h5><p>N 的父亲、S 和 S 的儿子都是黑色的</p><ul><li>重绘 S 为红色</li><li>将 P 作为新的 N，从情形 1 开始，在 P 上做平衡处理</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-3.svg" alt="删除情形 3"></p><p>在这种情形下，我们简单的重绘 S 为红色。结果是通过 S 的所有路径都少了一个黑色节点。这与删除 N 的初始父亲 X 造成通过 N 的所有路径少了一个黑色节点达成平衡。但是，通过 P 的所有路径现在比不通过 P 的路径少了一个黑色节点，所以仍然违反性质 5。要修正这个问题，我们要从情形 1 开始，在 P 上做重新平衡处理</p><h5 id="情形-4-1"><a href="#情形-4-1" class="headerlink" title="情形 4"></a>情形 4</h5><p>S 和 S 的儿子都是黑色，但是 N 的父亲是红色</p><ul><li>交换 N 的兄弟 S 和父亲 P 的颜色</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-4.svg" alt="删除情形 4"></p><p>在这种情形下，我们简单的交换 N 的兄弟和父亲的颜色。这不影响不通过 N 的路径的黑色节点的数目，但是它在通过 N 的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点</p><h5 id="情形-5-1"><a href="#情形-5-1" class="headerlink" title="情形 5"></a>情形 5</h5><p>S 是黑色，S 的其中一个儿子是红色，且红色儿子的位置与 N 相对于父亲的位置处于<strong>同侧</strong></p><ul><li>如果 N 是其父亲的左节点，S 的左儿子是红色，右儿子是黑色，则在 S 上做右旋转</li><li>如果 N 是其父亲的右节点，S 的左儿子是黑色，右儿子是红色，则在 S 上做左旋转</li><li>将 S 和它之前的红色儿子交换颜色</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-5.svg" alt="删除情形 5"></p><p>所有路径仍有同样数目的黑色节点，但是现在 N 有了一个黑色兄弟，且兄弟的一个儿子仍为红色的，其位置与 N 相对于父亲的位置处于不同侧，进入情形 6</p><blockquote><p>情形 5、6 中父节点 P 的颜色可以为黑色也可以是红色</p></blockquote><h5 id="情形-6"><a href="#情形-6" class="headerlink" title="情形 6"></a>情形 6</h5><p>S 是黑色，S 的其中一个儿子是红色，且其位置与 N 相对于父亲的位置处于<strong>不同侧</strong></p><ul><li>交换 N 的父亲 P 和 S 的颜色</li><li>如果 N 是其父亲的右节点，S 的左儿子是红色，右儿子是黑色，则在 N 的父亲上做右旋转，并使 S 的左儿子涂黑</li><li>如果 N 是其父亲的左节点，S 的左儿子是黑色，右儿子是红色，则在 N 的父亲上做左旋转，并使 S 的右儿子涂黑</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-6.svg" alt="删除情形 6"></p><p>交换前 N 的父亲可以是红色也可以是黑色，交换后，N 增加了一个黑色祖先，所以通过 N 的路径都增加了一个黑色节点，S 的右子树黑色节点个数也没有变化，达到平衡</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>还是以之前的图为例</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-7.svg" alt="删除"></p><p>我们自下而上开始尝试删除每一个节点:</p><ul><li><p>假如要删除元素 1，根据简单情形中的第二条，我们直接删除 1，并用一个 nil 节点代替即可，元素 6、12、21 的处理与此相同</p></li><li><p>假如要删除元素 5，因为左右子树均不为空，所以找左子树的最大值 1 (或者右子树的最小值 6)，用找到的值代替 5 (这里只是值替换，其他均不变)，然后去删除 1 节点，这就转到问题 1 上了</p></li><li><p>假如要删除元素 11，根据简单情形的第三条，我们直接删除 11，并用子节点 12 代替，同时把 12 涂黑即可，元素 22 的处理与此相同</p></li><li><p>假如要删除元素 25，因为左右子树均不为空，所以找左子树的最大值 22 (或者右子树的最小值 27)，我们这里用值 22 代替 25，颜色不变。然后去删除 22 节点，这变成上一个问题了</p></li><li><p>假如要删除元素 27，黑色的 nil 叶子节点代替 27 节点，因为兄弟节点 22 有一个红色孩子，且在左边，和 nil 节点相对父亲 25 的位置不同侧，属于情形 6，所以第一步交换 22 和 25 的颜色，再以 25 为支点做右旋转，然后将 21 节点涂黑即可</p></li><li><p>假如要删除元素 8，选择右子树最小值 11 替换 8。然后去删除节点 11，对应问题 3</p></li><li><p>假如要删除元素 17，选择左子树最大值 15 替换 17。然后去删除节点 15，过程看下一个问题</p></li><li><p>假如要删除元素 15，删除的元素和替代的元素都是黑色，这属于复杂情形。检查其类型可以匹配到情形 2，元素 15 是被移除的 X，代替它的是 nil 节点，即为 N，17 为 P，25 为 S，根据上文可知第一步先交换 P 和 S 的颜色，然后以 P 为支点进行左旋，此时 N 多了一个黑色的兄弟 22 和红色的父亲 17:</p></li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-example-0.svg" alt="删除 15"></p><p>此时 N 的兄弟 S 变为 22，P 变为 17，S 的左孩子是红色的 21，属于情形 5。S 做右旋转，并交换 22 和 21 的颜色:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-example-1.svg" alt="删除 15"></p><p>此时 N 的兄弟 S 变为黑色的 21，但 21 的红色孩子节点 22 变为右侧，进入情形 6</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-example-2.svg" alt="删除 15"></p><p>P 节点 17 做左旋转，并将 S 的右节点涂黑，此时树恢复平衡</p><ul><li>假如要删除根节点 14，取左子树最大值 12 代替 14。然后去删除节点 12，对应问题 1</li></ul><p>至此，我们已经把节点都删了个遍，相信你对红黑树的删除操作应该了解了</p><blockquote><p>红黑树动态展示: <a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p></blockquote><h2 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h2><p>红黑树还是典型的二叉搜索树结构，主要应用在一些 map 和 set 类型的实现上，比如 Java 中的 TreeMap 和 C++ 的 set/map/multimap 等。其查找的时间复杂度 $O(\log_2^n)$ 与树的深度相关，降低树的深度可以提高查找效率。</p><blockquote><p>Java 的 hashmap 和 golang 的 map 是用哈希实现的</p></blockquote><p>但是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），<br>这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O 读写过于频繁，进而导致查询效率低下，因此我们该想办法降低树的深度，从而减少磁盘查找存取的次数。</p><p>一个基本的思想就是：采用<code>多叉树结构</code>，所以出现了下述的平衡多路查找树</p><h2 id="B-树-B-Tree"><a href="#B-树-B-Tree" class="headerlink" title="B 树 (B - Tree)"></a>B 树 (B - Tree)</h2><blockquote><p>B-树，即为 B 树，不要读作 B 减树</p></blockquote><p>B 树与红黑树最大的不同在于，B 树的结点可以有许多子女，从几个到几千个。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>B 树的定义有两种，一种以阶数为限制的 B 树(下文所述的)，一种以度数为限制的 B 树(算法导论所描述的)，两者原理类似，这里以阶数来定义</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">B 树</a>属于平衡多路查找树。一棵 m 阶(m 阶即代表树中任一结点最多含有 m 个孩子)的 B 树的特性如下:</p><ol><li>除根节点外所有节点关键字个数范围: [$\lceil\frac m2\rceil$-1, m-1]</li><li>若非叶子节点含 n 个关键字，则子树有 n+1 个，由关键字范围可知子树的个数范围: [$\lceil\frac m2\rceil$, m]</li><li>根节点至少包含一个关键字，至少有两个孩子(除非 B 树只存在一个节点: 根结点)，即根节点关键字个数范围: [1, m-1]，孩子数范围: [2, m]</li><li>所有叶子节点都处在同一层，即高度都一样</li><li>每个节点中的关键字从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域划分</li></ol><p><img src="https://src.wangriyu.wang/images/blog/tree/BTree-0.svg" alt="2-3-4 树"></p><p>如图是一个典型的 <a href="https://zh.wikipedia.org/wiki/2-3-4%E6%A0%91" target="_blank" rel="noopener">2-3-4 树</a>结构，也是阶为 4 的 B 树。从图中查询元素最多只需要 3 次磁盘 I/O 就可以访问到我们需要的数据节点，将节点数据块读入内存后再查找指定元素会很快。如果同样的数据用红黑树表示，树高会增长很多，造成遍历节点的次数增多，访问磁盘的次数增多，查找性能会下降。</p><p>对于一棵包含 n 个元素、高度为 h 、阶数为 m 的 B 树:<br>影响 B 树高度的是每个结点所包含的子树数，如果尽可能使结点孩子数都等于 $\lceil\frac m2\rceil$，则层数最多，为最坏情况；如果尽可能使结点孩子数都等于 m，则层数最少，为最好情况。所以有</p><p>$$ \log _m{(n + 1)} \leq h \leq \log _{\lceil\frac m2\rceil}{(\frac{n + 1}{2})} + 1 $$</p><p>底数 $\lceil\frac m2\rceil$ 可以取很大，比如 m 可以达到几千，从而在关键字数一定的情况下，使得最终的 h 值尽量比较小，树的高度比较低。</p><p>实际运用中 B 树中的每个结点根据实际情况可以包含大量的关键字信息和分支(但不能超过磁盘块的大小，根据磁盘驱动的不同，一般块的大小在 1k~4k 左右)；这样树的深度降低了，意味着查找一个元素只要很少的结点从外存磁盘中读入内存，就可以很快地访问到要查找的数据</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>一个节点的结构可以定义为:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> BTNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  KeyNum   <span class="token builtin">int</span>       <span class="token comment" spellcheck="true">// 关键字个数，math.Ceil(m/2)-1 &lt;= KeyNum &lt; 阶数 m</span>
  Parent   <span class="token operator">*</span>BTNode   <span class="token comment" spellcheck="true">// 指向父节点的指针</span>
  IsLeaf   <span class="token builtin">bool</span>      <span class="token comment" spellcheck="true">// 是否为叶子，叶子节点 children 为 nil</span>
  Key      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>     <span class="token comment" spellcheck="true">// 关键字切片，长度为 KeyNum</span>
  Children <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>BTNode <span class="token comment" spellcheck="true">// 子节点指针切片，长度为 KeyNum+1</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上面 2-3-4 树的根节点为例：</p><p><img src="https://src.wangriyu.wang/images/blog/tree/BTNode.svg" alt="B 树节点"></p><p> 所有数据以块的方式存储在外磁盘中，我们通过 B 树来查找数据时，每遍历到一个节点，便将其读入内存，比较其中的关键字，若能匹配到我们要找的元素，便返回；若未能找到，通过比较确定在哪两个关键字的值域区间， 即可确定子树的节点指针，继续往下找，把下一个节点的数据读入内存，重复以上步骤</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于一棵 m 阶的 B 树来说，插入一个元素(或者叫关键字)时，首先判断在 B 树中是否已存在，如果存在则不插入；如果不存在，则在对应叶子结点中插入新的元素，需要判断是否会超出关键字个数限制(m-1)</p><p>插入步骤:</p><ol><li>根据元素大小查找插入位置，肯定是最底层的叶子节点，将元素插入到该节点中</li><li>如果叶子节点的关键字个数小于等于 m-1，说明未超出限制，插入结束；否则进入下一步</li><li>如果叶子节点的关键字个数大于 m-1 个，以结点中间的关键字为中心分裂成左右两部分，然后将这个中间的关键字插入到父结点中，这个关键字的左子树指向分裂后的左半部分，这个关键字的右子树指向分裂后的右半部分。</li><li>然后将当前结点指向父结点，如果插入刚才的中间关键字后父节点的关键字个数也超出限制，继续进行第 3 步；否则结束插入</li></ol><p>还是以上面的 2-3-4 树(阶数 m = 4)为例，我们依次插入元素</p><ul><li>首先插入 1、2、3，因为关键字个数均未超过 m-1，所以直接插入即可:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-0.svg" alt="插入 1 2 3"></p><ul><li>当插入 4 时，该节点关键字个数达到 m，需要分裂，这里可以选 3 (也可以选 2) 作为中间字，分裂后:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-1.svg" alt="插入 4"></p><ul><li>继续插入 5、7，对应 4 所在的叶子节点:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-2.svg" alt="插入 5 7"></p><ul><li>当插入 8 时，也需要分裂，将中间字 5 上移至父节点，4 成为 5 的左区间子树，7 8 成为 5 的右区间子树:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-3.svg" alt="插入 8"></p><p>之后的步骤类似，不再一一叙述</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作是指删除 B 树中的某个节点中的指定关键字</p><p>删除步骤:</p><ol><li>如果当前要删除的关键字位于非叶子结点 N 上，则用后继最小关键字(找前继最大关键字也可以)覆盖要删除的关键字，然后在后继关键字所在的子树中删除该后继关键字。此后继关键字一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个后继关键字后进入第 2 步，如果原本要删除的关键字本身就位于叶子上同样删除关键字后进入第二步</li><li>该结点(假设为 M)关键字个数大于等于 math.Ceil(m/2)-1，结束删除操作，否则进入第 3 步</li><li>此时结点 M 关键字个数小于 math.Ceil(m/2)-1<ul><li>如果相邻兄弟结点(左右都可以)关键字个数大于 math.Ceil(m/2)-1，则父结点中取一个临近的关键字下移到 M，兄弟结点中取一个临近关键字上移至父节点，删除操作结束；</li><li>如果相邻的兄弟节点关键字个数都不大于 math.Ceil(m/2)-1，将父结点中临近的关键字 key 下移至 M，合并 M 和它的兄弟节点形成一个新的结点。原父结点中的 key 的两个孩子指针就变成一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复第 2 步</li></ul></li></ol><p>以上面的 2-3-4 树为例</p><p><img src="https://src.wangriyu.wang/images/blog/tree/BTree-0.svg" alt="2-3-4 树"></p><p>阶数为 4，节点关键字个数范围应该是 [1, 3]，即 math.Ceil(m/2)-1 = 1</p><ul><li>删除关键字 2 或者 8，不影响节点</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-0.svg" alt="删除 2 和 8"></p><ul><li>删除关键字 4，该叶子节点 X 关键字个数变为 0 小于范围下界，同时左右两个相邻兄弟的关键字个数都不大于 1，需要合并节点。<ul><li>第一步，将父节点的 5 下移到 X 上</li><li>第二步，合并 X 和右兄弟节点 7 形成一个包含 5、7 的新节点</li><li>第三步，父节点中原本 5 的左右两个孩子指针变为一个并指向这个新节点</li></ul></li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-1.svg" alt="删除 4"></p><p>这里第一步也可以选择下移 3，然后第二步跟左兄弟合并成 1、3 节点</p><ul><li>继续删除 1，此时与上一个问题不同，该叶子节点的兄弟有富余的关键字，我们只需要把父节点的临近的一个关键字下移到该叶子节点代替删除的元素，然后把兄弟节点的一个临近关键字上移至父节点即可，这个操作有点类似红黑树的左旋操作</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-2.svg" alt="删除 1"></p><ul><li>现在尝试删除非叶子节点 5，用后继最小关键字 7 代替 5，然后删除 7 所在的叶子节点。<ul><li>此时会引起连锁反应，7 所在的叶子节点现在为空，而兄弟节点关键字又不大于 1，需要合并</li><li>将关键字 7 又从父节点移至原来的叶子上，合并成含 3、7 的新节点，假设新节点为 N，父节点的孩子指针变为一个并指向 N</li><li>而父节点现在关键字是空的，而且其兄弟(N 的叔叔)关键字也不大于 1，也需要合并</li><li>根节点取出关键字 9 下移到 N 的父节点上，合并 N 的父节点和叔叔节点，产生一个包含 9、15 的新节点，根节点的孩子指针减少一个且左子树指向这个新节点</li></ul></li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-3.svg" alt="删除 5"></p><p>删除操作就演示到这，B 树的内容讲完</p><blockquote><p>B 树动态展示: <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h2 id="B-树-B-Tree-1"><a href="#B-树-B-Tree-1" class="headerlink" title="B+ 树 (B+ - Tree)"></a>B+ 树 (B+ - Tree)</h2><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+ 树</a> 是基于 B 树的变体，查找性能更好</p><p>同为 m 阶的 B+ 树与 B 树的不同点:</p><ol><li>所有非叶子节点，每个节点最多有 m 个关键字，最少有 $\lceil\frac m2\rceil$ 个关键字(比 B 树的限制多一个)，其中每个关键字对应一棵子树</li><li>所有的非叶子结点可以看成是索引部分，结点中仅含有其子树根结点中最大(或最小)关键字，不包含关键字数据的指针(B 树是包含这个指针的)</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小到大顺序链接.(而 B 树的全部关键字信息分散在各个节点中)</li></ol><p><img src="https://src.wangriyu.wang/images/blog/tree/B+Tree-0.svg" alt="B+ 树"></p><p>如图所示的是将之前的 2-3-4 树的数据存到 B+ 树结构中的示意图，叶子节点保存了所有关键字信息并且叶子节点之间也用指针连接起来(一个顺序链表)，而所有非叶子节点只包含子树根节点中对应的最大关键字，其作用只是用于索引</p><blockquote><p>B+ 树还可以用另一种形式定义:</p><p>中间节点最多有 m-1 个关键字，最少有 $\lceil\frac m2\rceil-1$ 个关键字，与 B 树相同；<br>但是非叶子节点的关键字是左子树的最大关键字(或者右子树的最小关键字)，与刚才的情形不同</p></blockquote><p>比如同样的数据此定义的 B+ 树表现形式如下:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+Tree-1.svg" alt="B+ 树"></p><p>这种形式中间节点占用更少，可能更常见一点，不过下面的讲解是按第一种定义来</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>B+ 树比 B 树更适合实际应用中操作系统的文件索引和数据库索引</p><ol><li>B+ 树索引节点可以存储更多的关键字，磁盘 I/O 可以更少</li></ol><blockquote><p>数据库中关键字可能只是某个数据列的索引信息(比如以 ID 列创建的索引)，而索引指向的数据记录(某个 ID 对应的数据行)我们称作<strong>卫星数据</strong>，推荐看下博文 <a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html" target="_blank" rel="noopener">数据库的最简单实现</a> 和 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>B- 树中间节点和叶子节点都会带有关键字和卫星数据的指针，B+ 树中间节点只带有关键字，而卫星数据的指针均放在叶子节点中</p></blockquote><p>因为没有卫星数据的指针，所以 B+ 树内部结点相对 B 树占用空间更小。如果把所有同一结点的关键字存放在同一盘块中，那么对于 B+ 树来说盘块所能容纳的关键字数量也就更多，一次性读入内存中时能查找的关键字也就更多。相对来说 IO 读写次数也就降低了，性能就提升了。</p><p>举个例子，假设磁盘中的一个盘块能容纳 16 bytes，而一个关键字占 2 bytes，一个卫星数据指针占 2bytes。对于一棵 9 阶 B 树来说，一个结点最多含 8 个关键字(8*4 bytes)，即一个内部结点需要 2 个盘块来存储。而对于 B+ 树来说，内部结点不含卫星数据的指针，所以一个内部节点只需要 1 个盘块。当需要把内部结点读入内存中的时候，B 树就比 B+ 树多一次盘块查找时间</p><ol start="2"><li>B+ 树的查询效率更加稳定</li></ol><p>由于非叶子节点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路径。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。而 B 树查找一个文件时查找到的路径长度是不一的。</p><ol start="3"><li>B+ 树对范围查询操作更友好</li></ol><p>如果是查找单一元素，B+ 树的查找过程与 B 树类似，只是每次查找都是从根查到叶</p><p>而进行范围查询的操作时，B+ 树只要遍历叶子节点就可以实现整棵树的遍历，而 B 树的范围查询要通过中序遍历，效率比较低下</p><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>B+ 树的插入与 B 树类似，先寻找关键字对应的位置插入，需要注意的是插入比当前子树的最大关键字还大的数时要修改祖先节点对应的关键字，因为 B+ 树内部结点存的是子树的最大关键字</p><p>比如在上面给出的 B+ 树中插入 105 这个元素，因为 105 大于当前子树最大关键字 101，所以需要修改父节点和祖父节点的边界关键字:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-insert-0.svg" alt="插入 105"></p><ul><li>如果插入元素的节点未超出上界限制，则结束；否则将节点分裂，中间节点上移到父节点中，再判断父节点是否需要调整</li></ul><p>比如刚才插入 105 的叶子节点关键字个数达到 4 个，需要分裂，这里分裂与 B 树略有不同。B 树是把节点按中间节点分成三份，再把中间节点上移；而 B+ 树是分成两份，再把左半节点的最大关键字添加进父节点</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-insert-1.svg" alt="分裂叶子"></p><p>此时父节点也需要分裂</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-insert-2.svg" alt="分裂父节点"></p><p>根节点未超出 4，结束；假如此时根节点也超出上界了，需要把根节点也分裂，生成一个新的根节点，且新的根节点的关键字为左右子树的最大关键字</p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>B+ 树的删除与 B 树也类似，找到要删除的关键字，如果是当前子树的最大关键字，删除该关键字后还要修改祖先节点对应的关键字；如果不是当前子树的最大关键字，直接删除；</p><p>在上一张图的基础上删除 8，这是叶子的最大关键字，所以需要修改父节点和祖父节点的边界关键字:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-removal-0.svg" alt="删除 8"></p><ul><li>如果删除元素的节点未低于下界限制，则结束；否则分两种情况处理:<ul><li>如果兄弟节点有富余关键字，则从兄弟节点中移动一个关键字到当前节点，修改父节点对应边界关键字即可</li><li>如果兄弟节点关键字个数都处于下界值，不能外借元素，则合并当前节点和兄弟节点，修改父节点的孩子指针以及边界关键字，此时父节点关键字个数也少了一个，将当前节点的指针指向父节点继续判断处理</li></ul></li></ul><p>我们继续删除 7，此时该叶子节点关键字个数少于 1 需要调整，而兄弟节点有富余关键字，可以移动 5 到当前节点，修改父节点和祖父节点的边界关键字</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-removal-1.svg" alt="删除 7"></p><p>继续删除 5，兄弟节点的关键字个数为下界值 1，不能外借，则合并当前节点和兄弟节点，并修改父节点指针及关键字，相应的祖父节点也需要修改边界关键字</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-removal-2.svg" alt="删除 5"></p><blockquote><p>B+ 树动态展示: <a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><h2 id="B-树-B-Tree-2"><a href="#B-树-B-Tree-2" class="headerlink" title="B* 树 (B* - Tree)"></a>B* 树 (B* - Tree)</h2><p>B* 树是 B+ 树的变体，在 B+ 树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B* 树多了两条性质:</p><ul><li>中间结点也增加了指向兄弟的指针，即每一层节点都可以横向遍历</li><li>B* 树定义了非叶子结点关键字个数至少为 $\lceil\frac {2m}3\rceil$，即块的最低使用率为 2/3，代替 B+ 树的 1/2</li></ul><p>下图的数据与之前 B+ 树的数据一样，但分支结构有所不同(因为中间节点关键字范围变为[3, 4]，不同于之前 B+ 树的 [2, 4])，而且第二层节点之间也用指针连接起来<br><img src="https://src.wangriyu.wang/images/blog/tree/B*-Tree.svg" alt="B* 树"></p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>B+ 树节点满时就会分裂，而 B* 树节点满时会先检查兄弟节点是否满(因为每个节点都有指向兄弟的指针):</p><ul><li>如果兄弟节点未满则向兄弟节点转移关键字，然后修改原节点和兄弟结点的关键字以及会受最大关键字变动影响的祖先的边界关键字</li><li>如果兄弟节点已满，则从当前节点和兄弟节点各拿出 1/3 的数据创建一个新的节点出来，然后在父结点增加新结点的指针</li></ul><p>B* 树存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得 B* 树分解次数变得更少，节点空间使用率更高</p><p>因为没有找到相关的内容，关于 B* 树的插入删除这里不再讲解</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文依次介绍了二叉树 -&gt; 二叉搜索树 -&gt; 平衡二叉搜索树(红黑树) -&gt; 平衡多路查找树(B 类树)，各有特点，其中 B 类树是介绍的重点，因为实际运用中索引结构使用的是 B 类树</p><p>因为树的上面几层会反复查询，所以我们可以把树的前几层存在内存中，而底层的数据存在外部磁盘里，这样效率更高</p><p>当然 B 树也存在弊端:</p><p>因为一旦确定最大阶数，后面的使用过程中就不可以修改关键字个数的范围</p><p>那么除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到 70 字符之内</p><p>后面一篇我们会讲解另一种 Mysql 的索引结构: 哈希索引，可以动态适应任意长度的键值</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">wikipedia - 红黑树</a></li><li><a href="https://mp.weixin.qq.com/s/rDCEFzoKHIjyHfI_bsz5Rw" target="_blank" rel="noopener">什么是 B-树</a></li><li>《编程之法: 面试和算法心得》</li></ul>]]></content>
    
    <summary type="html">
    
      介绍二叉搜索树、红黑树、B 树、B+ 树和 B* 树，如果看完本文你心里还没点 B 树，那我也没办法了
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://blog.wangriyu.wang/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://blog.wangriyu.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据库" scheme="https://blog.wangriyu.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="树" scheme="https://blog.wangriyu.wang/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 Aplayer 导致博客目录跳转失效</title>
    <link href="https://blog.wangriyu.wang/2018/06-Aplayer.html"/>
    <id>https://blog.wangriyu.wang/2018/06-Aplayer.html</id>
    <published>2018-06-04T16:00:00.000Z</published>
    <updated>2018-06-17T12:48:09.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可以在此链接中测试 <a href="https://codepen.io/wangriyu/full/aGraGO" target="_blank" rel="noopener">https://codepen.io/wangriyu/full/aGraGO</a></p><p>加载 1.10.1 版本的 Aplayer 后，页面内带中文字符的锚标签均无法跳转，而纯英文的正常</p><h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p><img src="https://src.wangriyu.wang/images/blog/aplayer/toc.png" alt="toc"></p><p>前不久的某一天，我照常打开博客浏览新发布的文章时，点击侧边栏的锚标签进行目录跳转，突然发现没反应！？</p><p><img src="https://src.wangriyu.wang/images/blog/aplayer/emoji.jpeg" alt="emoji"></p><p>难道是我打开的姿势不对？我又打开另几篇博客，试了几个目录发现都一样没反应，难道是我之前给左上角背景图片添加 <code>pointer-events: none</code> 时影响到侧边栏的点击事件了?</p><p>但是也不对啊，我试了发现<strong>只有中文标题的目录点击跳转不了，英文标题却是正常的</strong>，肯定是其他地方的锅</p><p>我的第一直觉是这个左下角的播放器，因为这是前不久添加的，而且离这些锚标签近</p><p>打开控制台，我先看了播放器是否覆盖了目录，没有！然后我看了下锚标签的点击事件</p><p><img src="https://src.wangriyu.wang/images/blog/aplayer/console-1.png" alt="console"></p><p>这个 smoothscroll 有点眼生啊，我好像没用过啊</p><p>我再试着把播放器去掉，发现目录跳转一切正常，果然是你的锅</p><h2 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h2><p>发现是播放器的问题之后，我继续找问题出在哪，我发现去掉播放器之后，锚标签的点击事件少了刚才的 smoothscroll，应该是这个插件的问题</p><p><img src="https://src.wangriyu.wang/images/blog/aplayer/console-0.png" alt="console"></p><p>先去 Aplayer 的仓库看了下依赖，果然使用这插件</p><p><img src="https://src.wangriyu.wang/images/blog/aplayer/smoothscroll.png" alt="smoothscroll"></p><p>再去看了下 smoothscroll 的仓库，克隆了一份做了下测试</p><p>然后我发现它处理 hash 时只测试了英文，而使用中文时，中文字符转成了 Unicode 码，下面函数的判断条件无法成立，后面的点击处理也就失效了</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> linkHandler <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ev<span class="token punctuation">.</span>defaultPrevented<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ev<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span> window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// using the history api to solve issue #1 - back doesn't work</span>
        <span class="token comment" spellcheck="true">// most browser don't update :target when the history api is used:</span>
        <span class="token comment" spellcheck="true">// THIS IS A BUG FROM THE BROWSERS.</span>
        <span class="token comment" spellcheck="true">// change the scrolling duration in this call</span>
        <span class="token keyword">var</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Do not scroll to non-existing node</span>

        <span class="token function">smoothScroll</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'#'</span> <span class="token operator">+</span> el<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// this will cause the :target to be activated.</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要修改的地方是对 hash 的进行 decodeURIComponent 处理，这样就能正常处理中文的标签和 location 的对应问题了</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> linkHandler <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ev<span class="token punctuation">.</span>defaultPrevented<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ev<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span> window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// using the history api to solve issue #1 - back doesn't work</span>
        <span class="token comment" spellcheck="true">// most browser don't update :target when the history api is used:</span>
        <span class="token comment" spellcheck="true">// THIS IS A BUG FROM THE BROWSERS.</span>
        <span class="token comment" spellcheck="true">// change the scrolling duration in this call</span>
        <span class="token keyword">var</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Do not scroll to non-existing node</span>

        <span class="token function">smoothScroll</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'#'</span> <span class="token operator">+</span> el<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// this will cause the :target to be activated.</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我已经提出了 pull request，静等官方修复</p><p>如果是使用 Aplayer 的用户，可以先自行修改依赖，重新编译一份带正常功能的 smoothscroll 的 Aplayer</p><p>我这有已经打包修复的: <a href="https://src.wangriyu.wang/lib/js/APlayer.min.js" target="_blank" rel="noopener">https://src.wangriyu.wang/lib/js/APlayer.min.js</a></p><p>现在我博客侧边栏的目录点击也是正常的了</p>]]></content>
    
    <summary type="html">
    
      使用 Aplayer 导致中文标题的目录跳转失效的解决办法
    
    </summary>
    
      <category term="Web" scheme="https://blog.wangriyu.wang/categories/Web/"/>
    
    
      <category term="Aplayer" scheme="https://blog.wangriyu.wang/tags/Aplayer/"/>
    
  </entry>
  
  <entry>
    <title>搭建 docker 环境并用 docker 部署 nextcloud 网盘</title>
    <link href="https://blog.wangriyu.wang/2018/05-server-nextcloud.html"/>
    <id>https://blog.wangriyu.wang/2018/05-server-nextcloud.html</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-17T12:53:55.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统环境为 CentOS 7.4，默认用户为 root</p></blockquote><h2 id="安装-docker-和-docker-compose"><a href="#安装-docker-和-docker-compose" class="headerlink" title="安装 docker 和 docker-compose"></a>安装 docker 和 docker-compose</h2><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><pre class="line-numbers language-bash"><code class="language-bash">$ yum <span class="token function">install</span> docker-io -y
$ docker -v // 查看版本
$ systemctl start docker // 启动 docker
$ systemctl <span class="token function">enable</span> docker // 设置开机自启动
$ docker info // 如果已经启动 docker，会输出全局信息
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置镜像源，因为我是腾讯云服务器，所以选了腾讯云提供的源</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"OPTIONS='--registry-mirror=https://mirror.ccs.tencentyun.com'"</span> <span class="token operator">>></span> /etc/sysconfig/docker
$ systemctl daemon-reload
$ <span class="token function">service</span> docker restart
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在就可使用 docker 了</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker search mysql
$ docker pull 镜像
$ docker images // 已安装镜像
$ docker <span class="token function">ps</span> -a // 已启动容器
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h3><pre class="line-numbers language-bash"><code class="language-bash">$ yum -y <span class="token function">install</span> epel-release
$ yum -y <span class="token function">install</span> python-pip
$ pip <span class="token function">install</span> --upgrade --force-reinstall pip<span class="token operator">==</span>9.0.3 // 这里如果升级最新的，比如 10.0 以上的，下面安装 docker-compose 会报错
$ pip <span class="token function">install</span> docker-compose
$ docker-compose --version
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部署-nextcloud"><a href="#部署-nextcloud" class="headerlink" title="部署 nextcloud"></a>部署 nextcloud</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>需要镜像: <code>wonderfall/nextcloud</code> 和 <code>mariadb:10</code></li><li>主机需要安装 nginx</li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~
$ docker pull wonderfall/nextcloud
$ docker pull mariadb:10
$ <span class="token function">vi</span> docker-compose.yml
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>粘贴以下内容</p><pre class="line-numbers language-stylus"><code class="language-stylus">nextcloud<span class="token punctuation">:</span>
  <span class="token property-declaration"><span class="token property">image</span><span class="token punctuation">:</span> wonderfall<span class="token operator">/</span>nextcloud</span>
  <span class="token property-declaration"><span class="token property">container_name</span><span class="token punctuation">:</span> nextcloud_web</span>
  <span class="token property-declaration"><span class="token property">links</span><span class="token punctuation">:</span>
    <span class="token operator">-</span> nextcloud-db<span class="token punctuation">:</span>nextcloud-db</span>
  environment<span class="token punctuation">:</span>
    <span class="token property-declaration"><span class="token property">-</span> UID<span class="token operator">=</span><span class="token number">1000</span></span>
    <span class="token property-declaration"><span class="token property">-</span> GID<span class="token operator">=</span><span class="token number">1000</span></span>
    <span class="token property-declaration"><span class="token property">-</span> UPLOAD_MAX_SIZE<span class="token operator">=</span><span class="token number">5</span>G</span>
    <span class="token property-declaration"><span class="token property">-</span> APC_SHM_SIZE<span class="token operator">=</span><span class="token number">128</span>M</span>
    <span class="token property-declaration"><span class="token property">-</span> OPCACHE_MEM_SIZE<span class="token operator">=</span><span class="token number">128</span></span>
    <span class="token property-declaration"><span class="token property">-</span> CRON_PERIOD<span class="token operator">=</span><span class="token number">15</span>m</span>
    <span class="token property-declaration"><span class="token property">-</span> TZ<span class="token operator">=</span>Aisa<span class="token operator">/</span>Shanghai</span>
    <span class="token property-declaration"><span class="token property">-</span> ADMIN_USER<span class="token operator">=</span>登录账号</span>
    <span class="token property-declaration"><span class="token property">-</span> ADMIN_PASSWORD<span class="token operator">=</span>登录密码</span>
    <span class="token property-declaration"><span class="token property">-</span> DOMAIN<span class="token operator">=</span>localhost</span>
    <span class="token property-declaration"><span class="token property">-</span> DB_TYPE<span class="token operator">=</span>mysql</span>
    <span class="token property-declaration"><span class="token property">-</span> DB_NAME<span class="token operator">=</span>nextcloud</span>
    <span class="token property-declaration"><span class="token property">-</span> DB_USER<span class="token operator">=</span>nextcloud</span>
    <span class="token property-declaration"><span class="token property">-</span> DB_PASSWORD<span class="token operator">=</span>数据库 nextcloud 账号密码</span>
    <span class="token property-declaration"><span class="token property">-</span> DB_HOST<span class="token operator">=</span>nextcloud-db</span>
  volumes<span class="token punctuation">:</span>
    # 文件会放在宿主机的 `/docker/nextcloud` 目录，如果不存在会自动创建
    <span class="token property-declaration"><span class="token property">-</span> <span class="token operator">/</span>docker<span class="token operator">/</span>nextcloud<span class="token operator">/</span>data<span class="token punctuation">:</span><span class="token operator">/</span>data</span>
    <span class="token property-declaration"><span class="token property">-</span> <span class="token operator">/</span>docker<span class="token operator">/</span>nextcloud<span class="token operator">/</span>config<span class="token punctuation">:</span><span class="token operator">/</span>config</span>
    <span class="token property-declaration"><span class="token property">-</span> <span class="token operator">/</span>docker<span class="token operator">/</span>nextcloud<span class="token operator">/</span>apps<span class="token punctuation">:</span><span class="token operator">/</span>apps2</span>
    <span class="token property-declaration"><span class="token property">-</span> <span class="token operator">/</span>docker<span class="token operator">/</span>nextcloud<span class="token operator">/</span>themes<span class="token punctuation">:</span><span class="token operator">/</span>nextcloud<span class="token operator">/</span>themes</span>
  <span class="token property-declaration"><span class="token property">expose</span><span class="token punctuation">:</span>
    <span class="token operator">-</span> <span class="token number">8888</span></span>
  ports<span class="token punctuation">:</span>
    # 宿主机端口<span class="token punctuation">:</span>镜像端口
    <span class="token property-declaration"><span class="token property">-</span> <span class="token number">8888</span><span class="token punctuation">:</span><span class="token number">8888</span><span class="token operator">/</span>tcp</span>
  <span class="token property-declaration"><span class="token property">restart</span><span class="token punctuation">:</span> always</span>

nextcloud-db<span class="token punctuation">:</span>
  <span class="token property-declaration"><span class="token property">image</span><span class="token punctuation">:</span> mariadb<span class="token punctuation">:</span><span class="token number">10</span></span>
  <span class="token property-declaration"><span class="token property">container_name</span><span class="token punctuation">:</span> nextcloud_db</span>
  volumes<span class="token punctuation">:</span>
    # 数据库文件会放在宿主机的 `/docker/nextcloud/db` 目录，如果不存在会自动创建
    <span class="token property-declaration"><span class="token property">-</span> <span class="token operator">/</span>docker<span class="token operator">/</span>nextcloud<span class="token operator">/</span>db<span class="token punctuation">:</span><span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql</span>
  environment<span class="token punctuation">:</span>
    <span class="token property-declaration"><span class="token property">-</span> MYSQL_ROOT_PASSWORD<span class="token operator">=</span>数据库 root 密码</span>
    <span class="token property-declaration"><span class="token property">-</span> MYSQL_DATABASE<span class="token operator">=</span>nextcloud</span>
    <span class="token property-declaration"><span class="token property">-</span> MYSQL_USER<span class="token operator">=</span>nextcloud</span>
    <span class="token property-declaration"><span class="token property">-</span> MYSQL_PASSWORD<span class="token operator">=</span>数据库 nextcloud 账号密码</span>
  <span class="token property-declaration"><span class="token property">restart</span><span class="token punctuation">:</span> always</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑完后保存退出，在 docker-compose.yml 同级目录执行:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose up -d
Creating nextcloud_db <span class="token punctuation">..</span>. <span class="token keyword">done</span>
Creating nextcloud_web <span class="token punctuation">..</span>. <span class="token keyword">done</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里要注意一下，相应容器启动后还有一段配置时间，大概几分钟到十几分钟不等。我刚开始弄的时候，起完容器就去看网页能否打开，结果打不开，以为是打开的方式不对，直到后面看了一下日志才发现需要等…</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">ps</span> -a // 可以看到容器已经起来
$ docker logs nextcloud_db // 查看数据库配置是否完成
$ docker logs nextcloud_web // 查看 nextcloud 是否配置完成
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里推荐安装 httpie 工具，方便测试 http，如果 nextcloud 服务正常的话，应该会输出一个 login 页</p><pre class="line-numbers language-bash"><code class="language-bash">$ yum <span class="token function">install</span> httpie
$ http localhost:8888
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在 nextcloud 网盘就搭建好了，通过 ip:8888 就可以访问网盘页面了，下一步添加域名解析</p><h3 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h3><p>到 DNS 解析那添加一条二级域名，比如我用 pan，解析值填服务器 IP</p><p>回到服务器上</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> /etc/nginx/conf.d
$ <span class="token function">vi</span> pan.wangriyu.wang.conf
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加主机设置</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>
    <span class="token keyword">server_name</span>  pan<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true"># https 设置，可以不写</span>
    <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
    <span class="token keyword">ssl_certificate</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>wangriyu<span class="token punctuation">.</span>wang<span class="token operator">/</span>fullchain<span class="token punctuation">.</span>pem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
    <span class="token keyword">ssl_certificate_key</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>wangriyu<span class="token punctuation">.</span>wang<span class="token operator">/</span>privkey<span class="token punctuation">.</span>pem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
    <span class="token keyword">include</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>options<span class="token operator">-</span><span class="token keyword">ssl</span><span class="token operator">-</span>nginx<span class="token punctuation">.</span>conf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
    <span class="token keyword">ssl_dhparam</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span><span class="token keyword">ssl</span><span class="token operator">-</span>dhparams<span class="token punctuation">.</span>pem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>

    <span class="token keyword">add_header</span> Strict<span class="token operator">-</span>Transport<span class="token operator">-</span>Security <span class="token string">"max-age=63072000; includeSubdomains"</span> always<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true"># 限制客户端最大上传大小</span>
    <span class="token keyword">client_max_body_size</span> 5G<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true"># 反向代理</span>
    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>
      <span class="token keyword">proxy_redirect</span> off<span class="token punctuation">;</span>
      <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8888</span><span class="token punctuation">;</span>
      <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span><span class="token punctuation">.</span>htaccess <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">404</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">server</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true"># 非加密连接重定向到 https 上</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$host</span> <span class="token operator">=</span> pan<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">301</span> <span class="token keyword">https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$host</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>

    <span class="token keyword">listen</span>   <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">server_name</span>  pan<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">404</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑完保存退出，重载 nginx</p><pre class="line-numbers language-bash"><code class="language-bash">$ nginx -s reload
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时我们就可以访问 <a href="https://pan.wangriyu.wang" target="_blank" rel="noopener">https://pan.wangriyu.wang</a> 了，nextcloud 还有客户端，好好享受你的个人网盘吧</p>]]></content>
    
    <summary type="html">
    
      如何使用 docker 快速部署 nextcloud
    
    </summary>
    
      <category term="Server" scheme="https://blog.wangriyu.wang/categories/Server/"/>
    
    
      <category term="docker" scheme="https://blog.wangriyu.wang/tags/docker/"/>
    
      <category term="nextcloud" scheme="https://blog.wangriyu.wang/tags/nextcloud/"/>
    
      <category term="个人网盘" scheme="https://blog.wangriyu.wang/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 搭建 FTP 服务</title>
    <link href="https://blog.wangriyu.wang/2018/05-server-ftp.html"/>
    <id>https://blog.wangriyu.wang/2018/05-server-ftp.html</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2018-06-17T12:55:30.115Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统环境为 CentOS 7.4，默认用户为 root</p></blockquote><h2 id="安装并启动-FTP-服务"><a href="#安装并启动-FTP-服务" class="headerlink" title="安装并启动 FTP 服务"></a>安装并启动 FTP 服务</h2><h3 id="安装-VSFTPD"><a href="#安装-VSFTPD" class="headerlink" title="安装 VSFTPD"></a>安装 VSFTPD</h3><p>官网介绍: <a href="https://security.appspot.com/vsftpd.html#about" target="_blank" rel="noopener">https://security.appspot.com/vsftpd.html#about</a></p><pre class="line-numbers language-bash"><code class="language-bash">$ yum <span class="token function">install</span> vsftpd -y
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动-VSFTPD"><a href="#启动-VSFTPD" class="headerlink" title="启动 VSFTPD"></a>启动 VSFTPD</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">service</span> vsftpd start
$ systemctl <span class="token function">enable</span> vsftpd
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ftp 协议默认使用的是 21 端口，如果服务正常启动了，此命令应该会输出占用对象为 vsftpd</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">netstat</span> -nltp <span class="token operator">|</span> <span class="token function">grep</span> 21
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时访问 <code>ftp://服务器 IP 地址</code> 就可以浏览服务器上的 /var/ftp 目录了</p><h3 id="配置-FTP-权限"><a href="#配置-FTP-权限" class="headerlink" title="配置 FTP 权限"></a>配置 FTP 权限</h3><p>当前 FTP 服务允许匿名登陆，即直接访问，我们需要配置 FTP 访问权限</p><p>vsftpd 的配置目录为 /etc/vsftpd，其中</p><ul><li>vsftpd.conf 为主要配置文件</li><li>ftpusers 配置禁止访问 FTP 服务器的用户列表，即黑名单</li><li>user_list 配置用户访问控制</li></ul><h3 id="阻止匿名访问和切换根目录"><a href="#阻止匿名访问和切换根目录" class="headerlink" title="阻止匿名访问和切换根目录"></a>阻止匿名访问和切换根目录</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">vi</span> /etc/vsftpd/vsftpd.conf
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到 <code>anonymous_enable</code> 并设为 NO，找到 <code>chroot_local_user</code> 并去掉注释，并在最后添加 <code>allow_writeable_chroot=YES</code></p><pre class="line-numbers language-stylus"><code class="language-stylus"># 禁用匿名用户
<span class="token variable-declaration"><span class="token variable">anonymous_enable=NO</span></span>

# 禁止切换根目录
<span class="token variable-declaration"><span class="token variable">chroot_local_user=YES</span></span>

# 避免 vsftpd：500 OOPS<span class="token punctuation">:</span> vsftpd<span class="token punctuation">:</span> refusing to run with writable root inside chroot <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token variable-declaration"><span class="token variable">allow_writeable_chroot=YES</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他配置见 <code>Very Secure FTP Daemon 手册</code>: <a href="https://wiki.archlinux.org/index.php/Very_Secure_FTP_Daemon_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Very_Secure_FTP_Daemon_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><p>保存后重启 FTP 服务</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">service</span> vsftpd restart
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建-FTP-用户"><a href="#创建-FTP-用户" class="headerlink" title="创建 FTP 用户"></a>创建 FTP 用户</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">useradd</span> ftpuser
$ <span class="token function">passwd</span> ftpuser
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限制该用户仅能通过 FTP 访问</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">usermod</span> -s /sbin/nologin ftpuser
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="为用户分配主目录"><a href="#为用户分配主目录" class="headerlink" title="为用户分配主目录"></a>为用户分配主目录</h3><p>假设 /data/ftp 是 ftp 要访问的目录</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> /data
$ <span class="token function">chmod</span> -R 755 ./ftp
$ <span class="token function">chown</span> -R ftpuser ./ftp
$ <span class="token function">usermod</span> -d /data/ftp ftpuser
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="访问-FTP-服务"><a href="#访问-FTP-服务" class="headerlink" title="访问 FTP 服务"></a>访问 FTP 服务</h3><p>Mac 系统推荐安装 <a href="https://panic.com/transmit/" target="_blank" rel="noopener">Transmit</a> 客户端</p><p>左边为本地文件，右边为 FTP 服务器，支持拖动，可以很方便的进行移动复制删除创建等操作</p><p><img src="https://src.wangriyu.wang/images/blog/ftp/transmit.png" alt="image"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>至此 FTP 服务就搭建完了，我用这个 FTP 服务主要是上传修改博客和一些其他地方用到的静态文件，比如图片音乐等</p><p>我用 nginx 起一个 http 主机，这样我就可以通过 src.wangiyu.wang 这个域名访问 FTP 目录的文件，然后再去腾讯云那里添加 src.wangriyu.wang 到 CDN 上，这样我就可以用 FTP 方便管理博客要用到的图片等比较大的静态文件，然后用 CDN 来访问文件</p>]]></content>
    
    <summary type="html">
    
      如何在服务器上搭建 FTP 服务
    
    </summary>
    
      <category term="Server" scheme="https://blog.wangriyu.wang/categories/Server/"/>
    
    
      <category term="ftp" scheme="https://blog.wangriyu.wang/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2 详解</title>
    <link href="https://blog.wangriyu.wang/2018/05-HTTP2.html"/>
    <id>https://blog.wangriyu.wang/2018/05-HTTP2.html</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2018-06-17T13:00:37.183Z</updated>
    
    <content type="html"><![CDATA[<p>维基百科关于 HTTP/2 的介绍，可以看下定义和发展历史:</p><p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">Wiki</a></p><p>RFC 7540 定义了 HTTP/2 的协议规范和细节，本文的细节主要来自此文档，建议先看一遍本文，再回过头来照着协议大致过一遍 RFC，如果想深入某些细节再仔细翻看 RFC</p><p><a href="https://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">RFC7540</a></p><h2 id="Why-use-it"><a href="#Why-use-it" class="headerlink" title="Why use it ?"></a>Why use it ?</h2><h3 id="HTTP-1-1-存在的问题"><a href="#HTTP-1-1-存在的问题" class="headerlink" title="HTTP/1.1 存在的问题:"></a>HTTP/1.1 存在的问题:</h3><p>1、<strong>TCP 连接数限制</strong></p><p>对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接 (不同浏览器不一样)。为了解决数量限制，出现了 <code>域名分片</code> 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)，这样就可以针对不同域名创建连接并请求，以一种讨巧的方式突破限制，但是滥用此技术也会造成很多问题，比如每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存，对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等，对于移动端来说问题更明显，可以参考这篇文章: <a href="http://dev.mobify.com/blog/domain-sharding-bad-news-mobile-performance/" target="_blank" rel="noopener">Why Domain Sharding is Bad News for Mobile Performance and Users</a></p><p><img src="https://src.wangriyu.wang/images/blog/http/HOLB-1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/HOLB-2.png" alt="image"></p><p>在图中可以看到新建了六个 TCP 连接，每次新建连接 DNS 解析需要时间(几 ms 到几百 ms 不等)、TCP 慢启动也需要时间、TLS 握手又要时间，而且后续请求都要等待队列调度</p><p>2、<strong><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">线头阻塞 (Head Of Line Blocking)</a> 问题</strong></p><p>每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。为了解决此问题，出现了 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">管线化 - pipelining</a> 技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化</p><p>3、Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</p><p>4、为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</p><p>5、明文传输不安全</p><h3 id="HTTP2-的优势"><a href="#HTTP2-的优势" class="headerlink" title="HTTP2 的优势:"></a>HTTP2 的优势:</h3><h4 id="1、二进制分帧层-Binary-Framing-Layer"><a href="#1、二进制分帧层-Binary-Framing-Layer" class="headerlink" title="1、二进制分帧层 (Binary Framing Layer)"></a>1、二进制分帧层 (Binary Framing Layer)</h4><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧:</p><p><img src="https://src.wangriyu.wang/images/blog/http/http2-frame.png" alt="image"></p><p>h1 和 h2 的报文对比:</p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-message.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/h2-message.png" alt="image"></p><p>图中 h2 的报文是重组解析过后的，可以发现一些头字段发生了变化，而且所有头字段均小写</p><blockquote><p><code>strict-transport-security: max-age=63072000; includeSubdomains</code> 字段是服务器开启 <a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">HSTS 策略</a>，让浏览器强制使用 HTTPS 进行通信，可以减少重定向造成的额外请求和会话劫持的风险</p></blockquote><blockquote><p>服务器开启 HSTS 的方法是: 以 nginx 为例，在相应站点的 server 模块中添加 <code>add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot; always;</code> 即可</p></blockquote><blockquote><p>在 Chrome 中可以打开 <code>chrome://net-internals/#hsts</code> 进入浏览器的 HSTS 管理界面，可以增加 / 删除 / 查询 HSTS 记录，比如下图:</p></blockquote><blockquote><p><img src="https://src.wangriyu.wang/images/blog/http/HSTS.png" alt="image"></p></blockquote><blockquote><p>在 HSTS 有效期内且 TLS 证书仍有效，浏览器访问 blog.wangriyu.wang 会自动加上 https:// ，而不需要做一次查询重定向到 https</p></blockquote><p>关于帧详见: <a href="#帧-Frame">How does it work ？- 帧</a></p><h4 id="2、多路复用-MultiPlexing"><a href="#2、多路复用-MultiPlexing" class="headerlink" title="2、多路复用 (MultiPlexing)"></a>2、多路复用 (MultiPlexing)</h4><p>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。<br>把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。</p><p>流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题</p><p>所以 http2 对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接:</p><p><img src="https://src.wangriyu.wang/images/blog/http/ConnectionView-h1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/ConnectionView-h2.png" alt="image"></p><p>关于流详见: <a href="#流-Stream">How does it work ？- 流</a></p><h4 id="3、服务端推送-Server-Push"><a href="#3、服务端推送-Server-Push" class="headerlink" title="3、服务端推送 (Server Push)"></a>3、服务端推送 (Server Push)</h4><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p><p>Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>关于服务端推送详见: <a href="#Server-Push">How does it work ？- Server-Push</a></p><h4 id="4、Header-压缩-HPACK"><a href="#4、Header-压缩-HPACK" class="headerlink" title="4、Header 压缩 (HPACK)"></a>4、Header 压缩 (HPACK)</h4><p>使用 <a href="https://httpwg.org/specs/rfc7541.html" target="_blank" rel="noopener">HPACK</a> 算法来压缩首部内容</p><p>关于 HPACK 详见: <a href="#HPACK-算法">How does it work ？- HPACK</a></p><h4 id="5、应用层的重置连接"><a href="#5、应用层的重置连接" class="headerlink" title="5、应用层的重置连接"></a>5、应用层的重置连接</h4><p>对于 HTTP/1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p><h4 id="6、请求优先级设置"><a href="#6、请求优先级设置" class="headerlink" title="6、请求优先级设置"></a>6、请求优先级设置</h4><p>HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p><h4 id="7、流量控制"><a href="#7、流量控制" class="headerlink" title="7、流量控制"></a>7、流量控制</h4><p>每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p><p>关于流量控制详见: <a href="#流量控制">How does it work ？- 流量控制</a></p><h4 id="8、HTTP-1-的几种优化可以弃用"><a href="#8、HTTP-1-的几种优化可以弃用" class="headerlink" title="8、HTTP/1 的几种优化可以弃用"></a>8、HTTP/1 的几种优化可以弃用</h4><p>合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多</p><h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work ?"></a>How does it work ?</h2><h3 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧 - Frame"></a>帧 - Frame</h3><h4 id="帧的结构"><a href="#帧的结构" class="headerlink" title="帧的结构"></a>帧的结构</h4><p>所有帧都是一个固定的 9 字节头部 (payload 之前) 跟一个指定长度的负载 (payload):</p><pre class="line-numbers language-http"><code class="language-http">+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Length</code> 代表整个 frame 的长度，用一个 24 位无符号整数表示。除非接收者在 SETTINGS_MAX_FRAME_SIZE 设置了更大的值 (大小可以是 2^14(16384) 字节到 2^24-1(16777215) 字节之间的任意值)，否则数据长度不应超过 2^14(16384) 字节。头部的 9 字节不算在这个长度里</li><li><code>Type</code> 定义 frame 的类型，用 8 bits 表示。帧类型决定了帧主体的格式和语义，如果 type 为 unknown 应该忽略或抛弃。</li><li><code>Flags</code> 是为帧类型相关而预留的布尔标识。标识对于不同的帧类型赋予了不同的语义。如果该标识对于某种帧类型没有定义语义，则它必须被忽略且发送的时候应该赋值为 (0x0)</li><li><code>R</code> 是一个保留的比特位。这个比特的语义没有定义，发送时它必须被设置为 (0x0), 接收时需要忽略。</li><li><a href="https://httpwg.org/specs/rfc7540.html#StreamIdentifiers" target="_blank" rel="noopener">Stream Identifier</a> 用作流控制，用 31 位无符号整数表示。客户端建立的 sid 必须为奇数，服务端建立的 sid 必须为偶数，值 (0x0) 保留给与整个连接相关联的帧 (连接控制消息)，而不是单个流</li><li><code>Frame Payload</code> 是主体内容，由帧类型决定</li></ul><p>共分为十种类型的帧:</p><ul><li><code>HEADERS</code>: 报头帧 (type=0x1)，用来打开一个流或者携带一个首部块片段</li><li><code>DATA</code>: 数据帧 (type=0x0)，装填主体信息，可以用一个或多个 DATA 帧来返回一个请求的响应主体</li><li><code>PRIORITY</code>: 优先级帧 (type=0x2)，指定发送者建议的流优先级，可以在任何流状态下发送 PRIORITY 帧，包括空闲 (idle) 和关闭 (closed) 的流</li><li><code>RST_STREAM</code>: 流终止帧 (type=0x3)，用来请求取消一个流，或者表示发生了一个错误，payload 带有一个 32 位无符号整数的错误码 (<a href="https://httpwg.org/specs/rfc7540.html#ErrorCodes" target="_blank" rel="noopener">Error Codes</a>)，不能在处于空闲 (idle) 状态的流上发送 RST_STREAM 帧</li><li><code>SETTINGS</code>: 设置帧 (type=0x4)，设置此 <code>连接</code> 的参数，作用于整个连接</li><li><code>PUSH_PROMISE</code>: 推送帧 (type=0x5)，服务端推送，客户端可以返回一个 RST_STREAM 帧来选择拒绝推送的流</li><li><code>PING</code>: PING 帧 (type=0x6)，判断一个空闲的连接是否仍然可用，也可以测量最小往返时间 (RTT)</li><li><code>GOAWAY</code>: GOWAY 帧 (type=0x7)，用于发起关闭连接的请求，或者警示严重错误。GOAWAY 会停止接收新流，并且关闭连接前会处理完先前建立的流</li><li><code>WINDOW_UPDATE</code>: 窗口更新帧 (type=0x8)，用于执行流量控制功能，可以作用在单独某个流上 (指定具体 Stream Identifier) 也可以作用整个连接 (Stream Identifier 为 0x0)，只有 DATA 帧受流量控制影响。初始化流量窗口后，发送多少负载，流量窗口就减少多少，如果流量窗口不足就无法发送，WINDOW_UPDATE 帧可以增加流量窗口大小</li><li><code>CONTINUATION</code>: 延续帧 (type=0x9)，用于继续传送首部块片段序列，见 <a href="#首部的压缩与解压缩">首部的压缩与解压缩</a></li></ul><h4 id="DATA-帧格式"><a href="#DATA-帧格式" class="headerlink" title="DATA 帧格式"></a>DATA 帧格式</h4><pre class="line-numbers language-http"><code class="language-http"> +---------------+
 |Pad Length? (8)|
 +---------------+-----------------------------------------------+
 |                            Data (*)                         ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Pad Length</code>: ? 表示此字段的出现时有条件的，需要设置相应标识 (set flag)，指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>Data</code>: 传递的数据，其长度上限等于帧的 payload 长度减去其他出现的字段长度</li><li><code>Padding</code>: 填充字节，没有具体语义，发送时必须设为 0，作用是混淆报文长度，与 TLS 中 CBC 块加密类似，详见 <a href="https://httpwg.org/specs/rfc7540.html#padding" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html#padding</a></li></ul><p>DATA 帧有如下标识 (flags):</p><ul><li>END_STREAM: bit 0 设为 1 代表当前流的最后一帧</li><li>PADDED: bit 3 设为 1 代表存在 Padding</li></ul><p>例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/DATA-Frame1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/DATA-Frame2.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/DATA-Frame3.png" alt="image"></p><h4 id="HEADERS-帧格式"><a href="#HEADERS-帧格式" class="headerlink" title="HEADERS 帧格式"></a>HEADERS 帧格式</h4><pre class="line-numbers language-http"><code class="language-http"> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |E|                 Stream Dependency? (31)                     |
 +-+-------------+-----------------------------------------------+
 |  Weight? (8)  |
 +-+-------------+-----------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>E</code>: 一个比特位声明流的依赖性是否是排他的，存在则代表 PRIORITY flag 被设置</li><li><code>Stream Dependency</code>: 指定一个 stream identifier，代表当前流所依赖的流的 id，存在则代表 PRIORITY flag 被设置</li><li><code>Weight</code>: 一个无符号 8 为整数，代表当前流的优先级权重值 (1~256)，存在则代表 PRIORITY flag 被设置</li><li><code>Header Block Fragment</code>: header 块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul><p>HEADERS 帧有以下标识 (flags):</p><ul><li>END_STREAM: bit 0 设为 1 代表当前 header 块是发送的最后一块，但是带有 END_STREAM 标识的 HEADERS 帧后面还可以跟 CONTINUATION 帧 (这里可以把 CONTINUATION 看作 HEADERS 的一部分)</li><li>END_HEADERS: bit 2 设为 1 代表 header 块结束</li><li>PADDED: bit 3 设为 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li><li>PRIORITY: bit 5 设为 1 表示存在 Exclusive Flag (E), Stream Dependency, 和 Weight</li></ul><p>例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/HEADERS-Frame.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/HEADERS-Response.png" alt="image"></p><h4 id="首部的压缩与解压缩"><a href="#首部的压缩与解压缩" class="headerlink" title="首部的压缩与解压缩"></a>首部的压缩与解压缩</h4><p>HTTP/2 里的首部字段也是一个键具有一个或多个值。这些首部字段用于 HTTP 请求和响应消息，也用于服务端推送操作。</p><p>首部列表 (Header List) 是零个或多个首部字段 (Header Field) 的集合。当通过连接传送时，首部列表通过压缩算法(即下文 HPACK) 序列化成首部块 (Header Block)。然后，序列化的首部块又被划分成一个或多个叫做首部块片段 (Header Block Fragment) 的字节序列，并通过 HEADERS、PUSH_PROMISE，或者 CONTINUATION 帧进行有效负载传送。</p><blockquote><p>Cookie 首部字段需要 HTTP 映射特殊对待，见 <a href="https://httpwg.org/specs/rfc7540.html#CompressCookie" target="_blank" rel="noopener">8.1.2.5. Compressing the Cookie Header Field</a></p></blockquote><p>一个完整的首部块有两种可能</p><ul><li>一个 HEADERS 帧或 PUSH_PROMISE 帧加上设置 END_HEADERS flag</li><li>一个未设置 END_HEADERS flag 的 HEADERS 帧或 PUSH_PROMISE 帧，加上多个 CONTINUATION 帧，其中最后一个 CONTINUATION 帧设置 END_HEADERS flag</li></ul><p>必须将首部块作为连续的帧序列传送，不能插入任何其他类型或其他流的帧。尾帧设置 END_HEADERS 标识代表首部块结束，这让首部块在逻辑上等价于一个单独的帧。接收端连接片段重组首部块，然后解压首部块重建首部列表。</p><p><img src="https://src.wangriyu.wang/images/blog/http/End-Stream.png" alt="image"></p><h4 id="SETTINGS-帧格式"><a href="#SETTINGS-帧格式" class="headerlink" title="SETTINGS 帧格式"></a>SETTINGS 帧格式</h4><p><a href="https://httpwg.org/specs/rfc7540.html#SETTINGS" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html#SETTINGS</a></p><p>一个 SETTINGS 帧的 payload 由零个或多个参数组成，每个参数的形式如下:</p><pre class="line-numbers language-http"><code class="language-http"> +-------------------------------+
 |       Identifier (16)         |
 +-------------------------------+-------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Identifier</code>: 代表参数类型，比如 SETTINGS_HEADER_TABLE_SIZE 是 0x1</li><li><code>Value</code>: 相应参数的值</li></ul><p>在建立连接开始时双方都要发送 SETTINGS 帧以表明自己期许对方应做的配置，对方接收后同意配置参数便返回带有 ACK 标识的空 SETTINGS 帧表示确认，而且连接后任意时刻任意一方也都可能再发送 SETTINGS 帧调整，SETTINGS 帧中的参数会被最新接收到的参数覆盖</p><p>SETTINGS 帧作用于整个连接，而不是某个流，而且 SETTINGS 帧的 stream identifier 必须是 0x0，否则接收方会认为错误 (PROTOCOL_ERROR)。</p><p>SETTINGS 帧包含以下参数:</p><ul><li>SETTINGS_HEADER_TABLE_SIZE (0x1): 用于解析 Header block 的 Header 压缩表的大小，初始值是 4096 字节</li><li>SETTINGS_ENABLE_PUSH (0x2): 可以关闭 Server Push，该值初始为 1，表示允许服务端推送功能</li><li>SETTINGS_MAX_CONCURRENT_STREAMS (0x3): 代表发送端允许接收端创建的最大流数目</li><li>SETTINGS_INITIAL_WINDOW_SIZE (0x4): 指明发送端所有流的流量控制窗口的初始大小，会影响所有流，该初始值是 2^16 - 1(65535) 字节，最大值是 2^31 - 1，如果超出最大值则会返回 FLOW_CONTROL_ERROR</li><li>SETTINGS_MAX_FRAME_SIZE (0x5): 指明发送端允许接收的最大帧负载的字节数，初始值是 2^14(16384) 字节，如果该值不在初始值 (2^14) 和最大值 (2^24 - 1) 之间，返回 PROTOCOL_ERROR</li><li>SETTINGS_MAX_HEADER_LIST_SIZE (0x6): 通知对端，发送端准备接收的首部列表大小的最大字节数。该值是基于未压缩的首部域大小，包括名称和值的字节长度，外加每个首部域的 32 字节的开销</li></ul><p>SETTINGS 帧有以下标识 (flags):</p><ul><li>ACK: bit 0 设为 1 代表已接收到对方的 SETTINGS 请求并同意设置，设置此标志的 SETTINGS 帧 payload 必须为空</li></ul><p>例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/SETTINGS-Frame.png" alt="image"></p><p>实际抓包会发现 HTTP2 请求创建连接发送 SETTINGS 帧初始化前还有一个 Magic 帧 (建立 HTTP/2 请求的前言)。</p><p>在 HTTP/2 中，要求两端都要发送一个连接前言，作为对所使用协议的最终确认，并确定 HTTP/2 连接的初始设置，客户端和服务端各自发送不同的连接前言。</p><p>客户端的前言内容 (对应上图中编号 23 的帧) 包含一个内容为 <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code> 的序列加上一个可以为空的 SETTINGS 帧，在收到 101(Switching Protocols) 响应 (代表 upgrade 成功) 后发送，或者作为 TLS 连接的第一个传输的应用数据。如果在预先知道服务端支持 HTTP/2 的情况下启用 HTTP/2 连接，客户端连接前言在连接建立时发送。</p><p>服务端的前言 (对应上图中编号 26 的帧) 包含一个可以为空的 SETTINGS 帧，在建立 HTTP/2 连接后作为第一帧发送。详见 <a href="https://httpwg.org/specs/rfc7540.html#ConnectionHeader" target="_blank" rel="noopener">HTTP/2 Connection Preface</a></p><p>发送完前言后双方都得向对方发送带有 ACK 标识的 SETTINGS 帧表示确认，对应上图中编号 29 和 31 的帧。</p><p>请求站点的全部帧序列，帧后面的数字代表所属流的 id，最后以 GOAWAY 帧关闭连接:</p><p><img src="https://src.wangriyu.wang/images/blog/http/All-Frame.png" alt="image"></p><p>GOAWAY 帧带有最大的那个流标识符 (比如图中第 29 帧是最大流)，对于发送方来说会继续处理完不大于此数字的流，然后再真正关闭连接</p><h3 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 - Stream"></a>流 - Stream</h3><p>流只是一个逻辑上的概念，代表 HTTP/2 连接中在客户端和服务器之间交换的独立双向帧序列，每个帧的 Stream Identifier 字段指明了它属于哪个流。</p><p>流有以下特性:</p><ul><li>单个 h2 连接可以包含多个并发的流，两端之间可以交叉发送不同流的帧</li><li>流可以由客户端或服务器来单方面地建立和使用，或者共享</li><li>流可以由任一方关闭</li><li>帧在流上发送的顺序非常重要，最后接收方会把相同 Stream Identifier (同一个流) 的帧重新组装成完整消息报文</li></ul><h4 id="流的状态"><a href="#流的状态" class="headerlink" title="流的状态"></a>流的状态</h4><p><img src="https://src.wangriyu.wang/images/blog/http/stream-state.png" alt="image"></p><blockquote><p>注意图中的 send 和 recv 对象是指端点，不是指当前的流</p></blockquote><h5 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h5><p>所有流以“空闲”状态开始。在这种状态下，没有任何帧的交换</p><p>其状态转换:</p><ul><li>发送或者接收一个 HEADERS 帧会使空闲 <code>idle</code> 流变成打开 <code>open</code> 状态，其中 HEADERS 帧的 Stream Identifier 字段指明了流 id。同样的 HEADERS 帧(带有 END_STREAM )也可以使一个流立即进入 half-closed 状态。</li><li>服务端必须在一个打开 <code>open</code> 或者半关闭 (远端) <code>half-closed(remote)</code> 状态的流 (由客户端发起的) 上发送 PUSH_PROMISE 帧，其中 PUSH_PROMISE 帧的 Promised Stream ID 字段指定了一个预示的新流 (由服务端发起)，<ul><li>在服务端该新流会由空闲 <code>idle</code> 状态进入被保留的 (本地) <code>reserved(local)</code> 状态</li><li>在客户端该新流会由空闲 <code>idle</code> 状态进入被保留的 (远端) <code>reserved(remote)</code> 状态</li></ul></li></ul><blockquote><p>在 <a href="https://httpwg.org/specs/rfc7540.html#discover-http" target="_blank" rel="noopener">3.2 - Starting HTTP/2 for “http” URIs</a> 中介绍了一种特殊情况:</p><blockquote><p>客户端发起一个 HTTP/1.1 请求，请求带有 Upgrade 机制，想创建 h2c 连接，服务端同意升级返回 101 响应。<br>升级之前发送的 HTTP/1.1 请求被分配一个流标识符 0x1，并被赋予默认优先级值。从客户端到服务端这个流 1 隐式地转为 “half-closed” 状态，因为作为 HTTP/1.1 请求它已经完成了。HTTP/2 连接开始后，流 1 用于响应。详细过程可以看下文的 <a href="#HTTP-2-的协议协商机制">HTTP/2 的协议协商机制</a></p></blockquote></blockquote><p>此状态下接收到 HEADERS 和 PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><p>状态图中 <code>send PP</code> 和 <code>recv PP</code> 是指连接的双方端点发送或接收了 PUSH_PROMISE，不是指某个空闲流发送或接收了 PUSH_PROMISE，是 PUSH_PROMISE 的出现促使一个预示的流从 <code>idle</code> 状态转为 <code>reserved</code></p><blockquote><p>在下文 <a href="#Server-Push">Server-Push</a> 中会详细介绍服务端推送的内容和 PUSH_PROMISE 的使用情形</p></blockquote><h5 id="reserved-local-reserved-remote"><a href="#reserved-local-reserved-remote" class="headerlink" title="reserved (local) / reserved (remote)"></a>reserved (local) / reserved (remote)</h5><p>PUSH_PROMISE 预示的流由 <code>idle</code> 状态进入此状态，代表准备进行 Server push</p><p>其状态转换:</p><ul><li>PUSH_PROMISE 帧预示的流的响应以 HEADERS 帧开始，这会立即将该流在服务端置于半关闭 (远端) <code>half-closed(remote)</code> 状态，在客户端置于半关闭 (本地) <code>half-closed(local)</code> 状态，最后以携带 END_STREAM 的帧结束，这会将流置于关闭 <code>closed</code> 状态</li><li>任一端点都可以发送 RST_STREAM 帧来终止这个流，其状态由 <code>reserved</code> 转为 <code>closed</code></li></ul><p><code>reserved(local)</code> 状态下的流不能发送 HEADERS、RST_STREAM、PRIORITY 以外的帧，接收到 RST_STREAM、PRIORITY、WINDOW_UPDATE 以外的帧被视为 PROTOCOL_ERROR</p><p><code>reserved(remote)</code> 状态下的流不能发送 RST_STREAM、WINDOW_UPDATE、PRIORITY 以外的帧，接收到 HEADERS、RST_STREAM、PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>处于 <code>open</code> 状态的流可以被两个对端用来发送任何类型的帧</p><p>其状态转换:</p><ul><li>任一端都可以发送带有 END_STREAM 标识的帧，发送方会转入 <code>half-closed(local)</code> 状态；接收方会转入 <code>half-closed(remote)</code> 状态</li><li>任一端都可以发送 RST_STREAM 帧，这会使流立即进入 <code>closed</code> 状态</li></ul><h5 id="half-closed-local"><a href="#half-closed-local" class="headerlink" title="half-closed (local)"></a>half-closed (local)</h5><p>流是双向的，半关闭表示这个流单向关闭了，local 代表本端到对端的方向关闭了，remote 代表对端到本端的方向关闭了</p><p>此状态下的流不能发送 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧</p><p>当此状态下的流收到带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><p>此状态下的流收到的 PRIORITY 帧用以调整流的依赖关系顺序，可以看下文的流优先级</p><h5 id="half-closed-remote"><a href="#half-closed-remote" class="headerlink" title="half-closed (remote)"></a>half-closed (remote)</h5><p>此状态下的流不会被对端用于发送帧，执行流量控制的端点不再有义务维护接收方的流控制窗口。</p><p>一个端点在此状态的流上接收到 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧，应该响应一个 STREAM_CLOSED 流错误</p><p>此状态下的流可以被端点用于发送任意类型的帧，且此状态下该端点仍会观察流级别的流控制的限制</p><p>当此状态下的流发送带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><h5 id="closed"><a href="#closed" class="headerlink" title="closed"></a>closed</h5><p>代表流已关闭</p><p>此状态下的流不能发送 PRIORITY 以外的帧，发送 PRIORITY 帧是调整那些依赖这个已关闭的流的流优先级，端点都应该处理 PRIORITY 帧，尽管如果该流从依赖关系树中移除了也可以忽略优先级帧</p><p>此状态下在收到带有 END_STREAM 标识的 DATA 或 HEADERS 帧后的一小段时间内 (period) 仍可能接收到 WINDOW_UPDATE 或 RST_STREAM 帧，因为在远程对端接收并处理 RST_STREAM 或带有 END_STREAM 标志的帧之前，它可能会发送这些类型的帧。但是端点必须忽略接收到的 WINDOW_UPDATE 或 RST_STREAM</p><p>如果一个流发送了 RST_STREAM 帧后转入此状态，而对端接收到 RST_STREAM 帧时可能已经发送了或者处在发送队列中，这些帧是不可撤销的，发送 RST_STREAM 帧的端点必须忽略这些帧。</p><p>一个端点可以限制 period 的长短，在 period 内接受的帧会忽略，超出 period 的帧被视为错误。</p><p>一个端点发送了 RST_STREAM 帧后接收到流控制帧(比如 DATA)，仍会计入流量窗口，即使这些帧会被忽略，因为对端肯定是在接收到 RST_STREAM 帧前发送的流控制帧，对端会认为流控制已生效</p><p>一个端点可能会在发送了 RST_STREAM 帧后收到 PUSH_PROMISE 帧，即便预示的流已经被重置 (reset)，PUSH_PROMISE 帧也能使预示流变成 <code>reserved</code> 状态。因此，需要 RST_STREAM 来关闭一个不想要的预示流。</p><blockquote><p>PRIORITY 帧可以被任意状态的流发送和接收，未知类型的帧会被忽略</p></blockquote><h5 id="流状态的转换"><a href="#流状态的转换" class="headerlink" title="流状态的转换"></a>流状态的转换</h5><p>下面看两个例子来理解流状态:</p><p><img src="https://src.wangriyu.wang/images/blog/http/ServerPushStreamState.png" alt="image"></p><p>(1)、Server 在 Client 发起的一个流上发送 PUSH_PROMISE 帧，其 Promised Stream ID 指定一个预示流用于后续推送，send PP 后这个预示流在服务端从 idle 状态转为 reserve(local) 状态，客户端 recv PP 后这个流从 idle 状态转为 reserve(remote) 状态</p><p>(2)(3)、此时预示流处于保留状态，客户端如果选择拒绝接受推送，可以发送 RST 帧关闭这个流；服务端如果此时出问题了也可以发送 RST 帧取消推送。不管哪一方发送或接收到 RST，此状态都转为 closed</p><p>(4)、没有出现重置说明推送仍有效，则服务端开始推送，首先发送的肯定是响应的 HEADERS 首部块，此时流状态转为半关闭 half-closed(remote)；客户端接收到 HEADERS 后流状态转为半关闭 half-closed(local)</p><p>(5)(6)、半关闭状态下的流应该还会继续推送诸如 DATA 帧、CONTINUATION 帧这样的数据帧，如果这个过程碰到任一方发起重置，则流会关闭进入 closed 状态</p><p>(7)、如果一切顺利，资源随着数据帧响应完毕，最后一帧会带上 END_STREAM 标识代表这个流结束了，此时流转为 closed 状态</p><p><img src="https://src.wangriyu.wang/images/blog/http/RequestStreamState.png" alt="image"></p><p>(1)、客户端发起请求，首先发送一个 HEADERS 帧，其 Stream Identifier 创建一个新流，此流从 idle 状态转为 open 状态</p><p>(2)(3)、如果客户端取消请求可以发送 RST 帧，服务端出错也可以发送 RST 帧，不管哪一方接收或发送 RST，流关闭进入 closed 状态；</p><p>(4)、如果请求结束(END_STREAM)，流转为半关闭状态。假如是 GET 请求，一般 HEADERS 帧就是最后一帧，send H 后流会立即进入半关闭状态。假如是 POST 请求，待数据传完，最后一帧带上 END_STREAM 标识，流转为半关闭</p><p>(5)(6)、客户端半关闭后服务端开始返回响应，此时任一方接收或发送 RST，流关闭；</p><p>(7)、如果一切顺利，等待响应结束(END_STREAM)，流关闭</p><h4 id="流的标识符"><a href="#流的标识符" class="headerlink" title="流的标识符"></a>流的标识符</h4><p>流 ID 是 31 位无符号整数，客户端发起的流必须是奇数，服务端发起的流必须是偶数，0x0 保留为连接控制消息不能用于建立新流。</p><p>HTTP/1.1 Upgrade to HTTP/2 时响应的流 ID 是 0x1，在升级完成之后，流 0x1 在客户端会转为 <code>half-closed (local)</code> 状态，因此这种情况下客户端不能用 0x1 初始化一个流</p><p>新建立的流的 ID 必须大于所有已使用过的数字，接收到一个错误大小的 ID 应该返回 PROTOCOL_ERROR 响应</p><p>使用一个新流时隐式地关闭了对端发起的 ID 小于当前流的且处于 <code>idle</code> 状态的流，比如一个流发送一个 HEADERS 帧打开了 ID 为 7 的流，但还从未向 ID 为 5 的流发送过帧，则流 0x5 会在 0x7 发送完或接收完第一帧后转为 <code>closed</code> 状态</p><p>一个连接内的流 ID 不能重用</p><h4 id="流的优先级"><a href="#流的优先级" class="headerlink" title="流的优先级"></a>流的优先级</h4><p>客户端可以通过 HEADERS 帧的 PRIORITY 信息指定一个新建立流的优先级，其他期间也可以发送 PRIORITY 帧调整流优先级</p><p>设置优先级的目的是为了让端点表达它所期望对端在并发的多个流之间如何分配资源的行为。更重要的是，当发送容量有限时，可以使用优先级来选择用于发送帧的流。</p><p>流可以被标记为依赖其他流，所依赖的流完成后再处理当前流。每个依赖 (dependency) 后都跟着一个权重 (weight)，这一数字是用来确定依赖于相同的流的可分配可用资源的相对比例</p><h5 id="流依赖-Stream-Dependencies"><a href="#流依赖-Stream-Dependencies" class="headerlink" title="流依赖(Stream Dependencies)"></a>流依赖(Stream Dependencies)</h5><p>每个流都可以显示地依赖另一个流，包含依赖关系表示优先将资源分配给指定的流(上层节点)而不是依赖流</p><p>一个不依赖于其他流的流会指定 stream dependency 为 0x0 值，因为不存在的 0x0 流代表依赖树的根</p><p>一个依赖于其他流的流叫做<strong>依赖流</strong>，被依赖的流是当前流的父级。如果被依赖的流不在当前依赖树中(比如状态为 <code>idle</code> 的流)，被依赖的流会使用一个默认优先级</p><p>当依赖一个流时，该流会添加进父级的依赖关系中，共享相同父级的依赖流不会相对于彼此进行排序，比如 B 和 C 依赖 A，新添加一个依赖流 D，BCD 的顺序是不固定的:</p><pre class="line-numbers language-http"><code class="language-http">    A                 A
   / \      ==>      /|\
  B   C             B D C
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>独占标识 (exclusive) 允许插入一个新层级(新的依赖关系)，独占标识导致该流成为父级的唯一依赖流，而其他依赖流变为其子级，比如同样插入一个新依赖流 E (带有 exclusive):</p><pre class="line-numbers language-http"><code class="language-http">                      A
    A                 |
   /|\      ==>       E
  B D C              /|\
                    B D C
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在依赖关系树中，只有当一个依赖流所依赖的所有流(父级最高为 0x0 的链)被关闭或者无法继续在上面执行，这个依赖流才应该被分配资源</p><h5 id="依赖权重"><a href="#依赖权重" class="headerlink" title="依赖权重"></a>依赖权重</h5><p>所有依赖流都会分配一个 1~256 权重值</p><p>相同父级的依赖流按权重比例分配资源，比如流 B 依赖于 A 且权重值为 4，流 C 依赖于 A 且权重值为 12，当 A 不再执行时，B 理论上能分配的资源只有 C 的三分之一</p><h5 id="优先级调整-Reprioritization"><a href="#优先级调整-Reprioritization" class="headerlink" title="优先级调整 (Reprioritization)"></a>优先级调整 (Reprioritization)</h5><p>使用 PRIORITY 帧可以调整流优先级</p><p>PRIORITY 帧内容与 HEADERS 帧的优先级模块相同:</p><pre class="line-numbers language-http"><code class="language-http"> +-+-------------------------------------------------------------+
 |E|                  Stream Dependency (31)                     |
 +-+-------------+-----------------------------------------------+
 |   Weight (8)  |
 +-+-------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果父级重新设置了优先级，则依赖流会随其父级流一起移动。若调整优先级的流带有独占标识，会导致新的父流的所有子级依赖于这个流</p></li><li><p>如果一个流调整为依赖自己的一个子级，则这个将被依赖的子级首先移至调整流的父级之下(即同一层)，再移动那个调整流的整棵子树，移动的依赖关系保持其权重</p></li></ul><p>看下面这个例子: 第一个图是初始关系树，现在 A 要调整为依赖 D，根据第二点，现将 D 移至 x 之下，再把 A 调整为 D 的子树(图 3)，如果 A 调整时带有独占标识根据第一点 F 也归为 A 子级(图 4)</p><pre class="line-numbers language-http"><code class="language-http">    x                x                x                 x
    |               / \               |                 |
    A              D   A              D                 D
   / \            /   / \            / \                |
  B   C     ==>  F   B   C   ==>    F   A       OR      A
     / \                 |             / \             /|\
    D   E                E            B   C           B C F
    |                                     |             |
    F                                     E             E
               (intermediate)   (non-exclusive)    (exclusive)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="流优先级的状态管理"><a href="#流优先级的状态管理" class="headerlink" title="流优先级的状态管理"></a>流优先级的状态管理</h5><p>当一个流从依赖树中移除，它的子级可以调整为依赖被关闭流的父级(应该就是连接上一层节点)，新的依赖权重将根据关闭流的权重以及流自身的权重重新计算。</p><p>从依赖树中移除流会导致某些优先级信息丢失。资源在具有相同父级的流之间共享，这意味着如果这个集合中的某个流关闭或者阻塞，任何空闲容量将分配给最近的相邻流。然而，如果此集合的共有依赖(即父级节点)从树中移除，这些子流将与更上一层的流共享资源</p><p>一个例子: 流 A 和流 B 依赖相同父级节点，而流 C 和流 D 都依赖 A，在移除流 A 之前的一段时间内，A 和 D 都无法执行(可能任务阻塞了)，则 C 会分配到 A 的所有资源；<br>如果 A 被移除出树了，A 的权重按比重新计算分配给 C 和 D，此时 D 仍旧阻塞，C 分配的资源相较之前变少了。对于同等的初始权重，C 获取到的可用资源是三分之一而不是二分之一(为什么是三分之一?文档中没有说明细节，权重如何重新分配也不太清楚，下面是按我的理解解释的)</p><p>X 的资源为 1，ABCD 初始权重均为 16，*号代表节点当前不可用，图一中 C 和 B 各占一半资源，而 A 移除后 CD 的权重重新分配变为 8，所以图二中 C 和 B 占比变为 1:2，R(C) 变为 1/3</p><pre class="line-numbers language-http"><code class="language-http">          X(v:1.0)               X(v:1.0)
         / \                    /|\
        /   \                  / | \
      *A     B       ==>      /  |  \
    (w:16) (w:16)            /   |   \
      / \                   C   *D    B
     /   \                (w:8)(w:8)(w:16)
    C    *D
 (w:16) (w:16)


 R(C)=16/(16+16)=1/2 ==>  R(C)=8/(8+16)=1/3
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能向一个流创建依赖关系的优先级信息还在传输中，那个流就已经关闭了。如果一个依赖流的依赖指向没有相关优先级信息(即父节点无效)，则这个依赖流会分配默认优先级，这可能会造成不理想的优先级，因为给流分配了不在预期的优先级。</p><p>为了避免上述问题，一个端点应该在流关闭后的一段时间内保留流的优先级调整状态信息，此状态保留时间越长，流被分配错误的或者默认的优先级可能性越低。</p><p>类似地，处于“空闲”状态的流可以被分配优先级或成为其他流的父节点。这允许在依赖关系树中创建分组节点，从而实现更灵活的优先级表达式。空闲流以默认优先级开始</p><p>流优先级状态信息的保留可能增加终端的负担，因此这种状态可以被限制。终端可能根据负荷来决定保留的额外的状态的数目；在高负荷下，可以丢弃额外的优先级状态来限制资源的任务。在极端情况下，终端甚至可以丢弃激活或者保留状态流的优先级信息。如果使用了固定的限制，终端应当至少保留跟 SETTINGS_MAX_CONCURRENT_STREAMS 设置一样大小的流状态</p><h5 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h5><p>所有流都是初始为非独占地依赖于流 0x0。</p><p>Pushed 流初始依赖于相关的流(见 Server-Push)。</p><p>以上两种情况，流的权重都指定为 16。</p><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server-Push"></a>Server-Push</h3><h4 id="PUSH-PROMISE-帧格式"><a href="#PUSH-PROMISE-帧格式" class="headerlink" title="PUSH_PROMISE 帧格式"></a>PUSH_PROMISE 帧格式</h4><pre class="line-numbers language-http"><code class="language-http"> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |R|                  Promised Stream ID (31)                    |
 +-+-----------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>R</code>: 保留的1bit位</li><li><code>Promised Stream ID</code>: 31 位的无符号整数，代表 PUSH_PROMISE 帧保留的流，对于发送者来说该流标识符必须是可用于下一个流的有效值</li><li><code>Header Block Fragment</code>: 包含请求首部域的首部块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul><p>PUSH_PROMISE 帧有以下标识 (flags):</p><ul><li>END_HEADERS: bit 2 置 1 代表 header 块结束</li><li>PADDED: bit 3 置 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li></ul><h4 id="Push-的过程"><a href="#Push-的过程" class="headerlink" title="Push 的过程"></a>Push 的过程</h4><p>结合上文关于 Server-Push 的流状态转换</p><p>PUSH_PROMISE 帧只能在对端(客户端)发起的且流状态为 open 或者 half-closed (remote) 的流上发送</p><p>PUSH_PROMISE 帧准备推送的响应总是和来自于客户端的请求相关联。服务端在该请求所在的流上发送 PUSH_PROMISE 帧。PUSH_PROMISE 帧包含一个 Promised Stream ID，该流标识符是从服务端可用的流标识符里选出来的。</p><p>如果服务端收到了一个对文档的请求，该文档包含内嵌的指向多个图片文件的链接，且服务端选择向客户端推送那些额外的图片，那么在发送包含图片链接的 DATA 帧之前发送 PUSH_PROMISE 帧可以确保客户端在发现内嵌的链接之前，能够知道有一个资源将要被推送过来。同样地，如果服务端准备推送被首部块引用的响应 (比如，在 <a href="https://www.w3.org/wiki/LinkHeader" target="_blank" rel="noopener">Link 首部字段</a> 里的)，在发送首部块之前发送一个 PUSH_PROMISE 帧，可以确保客户端不再请求那些资源</p><p>一旦客户端收到了 PUSH_PROMISE 帧，并选择接收被推送的响应，客户端就不应该为准备推送的响应发起任何请求，直到预示的流被关闭以后。</p><p><img src="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_2.png" alt="image"></p><blockquote><p>注意图中推送的四个资源各预示了一个流 (Promised Stream ID)，而发送 PUSH_PROMISE 帧的还是在客户端发起的请求流 (Stream Identifier = 1) 上，客户端收到 PUSH_PROMISE 帧并选择接收便不会对这四个资源发起请求，之后服务端会发起预示的流然后推送资源相关的响应</p></blockquote><p>不管出于什么原因，如果客户端决定不再从服务端接收准备推送的响应，或者如果服务端花费了太长时间准备发送被预示的响应，客户端可以发送一个 RST_STREAM 帧，该帧可以使用 CANCEL 或者 REFUSED_STEAM 码，并引用被推送的流标识符。</p><h4 id="nginx-配置-Server-Push"><a href="#nginx-配置-Server-Push" class="headerlink" title="nginx 配置 Server-Push"></a>nginx 配置 Server-Push</h4><blockquote><p>server-push 需要服务端设置，并不是说浏览器发起请求，与此请求相关的资源服务端就会自动推送</p></blockquote><p>以 nginx 为例，从版本 1.13.9 开始正式支持 hppt2 serverpush 功能，</p><p>在相应 server 或 location 模块中加入 <code>http2_push</code> 字段加上相对路径的文件即可在请求该资源时推送相关资源，比如我的博客设置如下，访问首页时有四个文件会由服务器主动推送过去而不需要客户端请求:</p><pre class="line-numbers language-nginx"><code class="language-nginx">  <span class="token keyword">server_name</span>  blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>
  <span class="token keyword">root</span> <span class="token operator">/</span>blog<span class="token punctuation">;</span>
  <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>

  <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span><span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token punctuation">{</span>
    http2_push <span class="token operator">/</span>css<span class="token operator">/</span>style<span class="token punctuation">.</span>css<span class="token punctuation">;</span>
    http2_push <span class="token operator">/</span>js<span class="token operator">/</span>main<span class="token punctuation">.</span>js<span class="token punctuation">;</span>
    http2_push <span class="token operator">/</span>img<span class="token operator">/</span>yule<span class="token punctuation">.</span>jpg<span class="token punctuation">;</span>
    http2_push <span class="token operator">/</span>img<span class="token operator">/</span>avatar<span class="token punctuation">.</span>jpg<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过浏览器控制台可以查看 <code>Push</code> 响应:</p><p><img src="https://src.wangriyu.wang/images/blog/http/server-push.png" alt="image"></p><p>也可以用 <code>nghttp</code> 测试 push 响应 (* 号代表是服务端推送的):</p><p><img src="https://src.wangriyu.wang/images/blog/http/nghttp-serverpush.png" alt="image"></p><p>上面 <code>http2_push</code> 的设置适合静态资源，服务端事先知道哪些文件是客户端需要的，然后选择性推送</p><p>假如是后台应用动态生成的文件(比如 json 文件)，服务器事先不知道要推送什么，可以用 <code>Link</code> 响应头来做自动推送</p><p>在 server 模块中添加 <code>http2_push_preload on;</code></p><pre class="line-numbers language-nginx"><code class="language-nginx">  <span class="token keyword">server_name</span>  blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>
  <span class="token keyword">root</span> <span class="token operator">/</span>blog<span class="token punctuation">;</span>
  <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>

  http2_push_preload on<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后设置响应头 (add_header) 或者后台程序生成数据文件返回时带上响应头 Link 标签，比如</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token property-declaration"><span class="token property">Link</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">.</span>css<span class="token operator">></span><span class="token punctuation">;</span> as<span class="token operator">=</span>style<span class="token punctuation">;</span> rel<span class="token operator">=</span>preload<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">/</span>main<span class="token operator">.</span>js<span class="token operator">></span><span class="token punctuation">;</span> as<span class="token operator">=</span>script<span class="token punctuation">;</span> rel<span class="token operator">=</span>preload<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">/</span>image<span class="token operator">.</span>jpg<span class="token operator">></span><span class="token punctuation">;</span> as<span class="token operator">=</span>image<span class="token punctuation">;</span> rel<span class="token operator">=</span>preload</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nginx 会根据 Link 响应头主动推送这些资源</p><p>更多nginx 官方介绍见 <a href="https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/" target="_blank" rel="noopener">Introducing HTTP/2 Server Push with NGINX 1.13.9</a></p><h4 id="Server-Push-潜在的问题"><a href="#Server-Push-潜在的问题" class="headerlink" title="Server-Push 潜在的问题"></a>Server-Push 潜在的问题</h4><p>看了这篇文章 <a href="https://imququ.com/post/server-push-in-http2.html" target="_blank" rel="noopener">HTTP/2 中的 Server Push 讨论</a>，发现 Server-Push 有个潜在的问题</p><p>Server-Push 满足条件时便会发起推送，可是客户端已经有缓存了想发送 RST 拒收，而服务器在收到 RST 之前已经推送资源了，虽然这部分推送无效但是肯定会占用带宽</p><p>比如我上面博客关于 http2_push 的配置，我每次打开首页服务器都会推送那四个文件，而实际上浏览器知道自己有缓存使用的也是本地缓存，也就是说本地缓存未失效的期间内，服务器的 Server-Push 只是起到了占用带宽的作用</p><p>当然实际上对我的小站点来说影响并不大，但是如果网站需要大量推送的话，需要考虑并测试 Server-Push 是否会影响用户的后续访问</p><p>另外服务端可以设置 Cookie 或者 Session 记录访问时间，然后之后的访问判断是否需要 Push；还有就是客户端可以限制 PUSH 流的数目，也可以设置一个很低的流量窗口来限制 PUSH 发送的数据大小</p><p>至于哪些资源需要推送，在《web 性能权威指南》中就提到几种策略，比如 Apache 的 mod_spdy 能够识别 X-Associated-Content 首部，当中列出了希望服务器推送的资源；另外网上有人已经做了基于 Referer 首部的中间件来处理 Server-Push；或者服务端能更智能的识别文档，根据当前流量决定是否推送或者推送那些资源。相信以后会有更多关于 Server-Push 的实现和应用</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>多路复用的流会竞争 TCP 资源，进而导致流被阻塞。流控制机制确保同一连接上的流不会相互干扰。流量控制作用于单个流或整个连接。HTTP/2 通过使用 WINDOW_UPDATE 帧来提供流量控制。</p><p>流控制具有以下特征:</p><ul><li>流量控制是特定于连接的。两种级别的流量控制都位于单跳的端点之间，而不是整个端到端的路径。比如 server 前面有一个 front-end proxy 如 Nginx，这时就会有两个 connection，browser-Nginx, Nginx—server，flow control 分别作用于两个 connection。详情见: <a href="https://stackoverflow.com/questions/40747040/how-is-http-2-hop-by-hop-flow-control-accomplished" target="_blank" rel="noopener">How is HTTP/2 hop-by-hop flow control accomplished? - stackoverflow</a></li><li>流量控制是基于 WINDOW_UPDATE 帧的。接收方公布自己打算在每个流以及整个连接上分别接收多少字节。这是一个以信用为基础的方案。</li><li>流量控制是有方向的，由接收者全面控制。接收方可以为每个流和整个连接设置任意的窗口大小。发送方必须尊重接收方设置的流量控制限制。客户方、服务端和中间代理作为接收方时都独立地公布各自的流量控制窗口，作为发送方时都遵守对端的流量控制设置。</li><li>无论是新流还是整个连接，流量控制窗口的初始值是 65535 字节。</li><li>帧的类型决定了流量控制是否适用于帧。目前，只有 DATA 帧会受流量控制影响，所有其它类型的帧并不消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞。</li><li>流量控制不能被禁用。</li><li>HTTP/2 只定义了 WINDOW_UPDATE 帧的格式和语义，并没有规定接收方如何决定何时发送帧、发送什么样的值，也没有规定发送方如何选择发送包。具体实现可以选择任何满足需求的算法。</li></ul><h4 id="WINDOW-UPDATE-帧格式"><a href="#WINDOW-UPDATE-帧格式" class="headerlink" title="WINDOW_UPDATE 帧格式"></a>WINDOW_UPDATE 帧格式</h4><pre class="line-numbers language-http"><code class="language-http">+-+-------------------------------------------------------------+
|R|                Window Size Increment (31)                   |
+-+-------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Window Size Increment 表示除了现有的流量控制窗口之外，发送端还可以传送的字节数。取值范围是 1 到 2^31 - 1 字节。</p><p>WINDOW_UPDATE 帧可以是针对一个流或者是针对整个连接的。如果是前者，WINDOW_UPDATE 帧的流标识符指明了受影响的流；如果是后者，流标识符为 0 表示作用于整个连接。</p><p>流量控制功能只适用于被标识的、受流量控制影响的帧。文档定义的帧类型中，只有 DATA 帧受流量控制影响。除非接收端不能再分配资源去处理这些帧，否则不受流量控制影响的帧必须被接收并处理。如果接收端不能再接收帧了，可以响应一个 FLOW_CONTROL_ERROR 类型的流错误或者连接错误。</p><p>WINDOW_UPDATE 可以由发送过带有 END_STREAM 标志的帧的对端发送。这意味着接收端可能会在 half-closed (remote) 或者 closed 状态的流上收到 WINDOW_UPDATE 帧，接收端不能将其当做错误。</p><h4 id="流量控制窗口"><a href="#流量控制窗口" class="headerlink" title="流量控制窗口"></a>流量控制窗口</h4><p>流量控制窗口是一个简单的整数值，指出了准许发送端传送的数据的字节数。窗口值衡量了接收端的缓存能力。</p><p>除非将其当做连接错误，否则当接收端收到 DATA 帧时，必须总是从流量控制窗口中减掉其长度(不包括帧头的长度，而且两个级别的控制窗口都要减)。即使帧有错误，这也是有必要的，因为发送端已经将该帧计入流量控制窗口，如果接收端没有这样做，发送端和接收端的流量控制窗口就会不一致。</p><p>发送端不能发送受流量控制影响的、其长度超出接收端告知的两种级别的流量控制窗口可用空间的帧。即使这两种级别的流量控制窗口都没有可用空间了，也可以发送长度为 0、设置了 END_STREAM 标志的帧(即空的 DATA 帧)。</p><p>当帧的接收端消耗了数据并释放了流量控制窗口的空间时，可以发送一个 WINDOW_UPDATE 帧。对于流级别和连接级别的流量控制窗口，需要分别发送 WINDOW_UPDATE 帧。</p><p>新建连接时，流和连接的初始窗口大小都是 2^16 - 1(65535) 字节。可以通过设置连接前言中 SETTINGS 帧的 SETTINGS_INITIAL_WINDOW_SIZE 参数改变流的初始窗口大小，这会作用于所有流。而<code>连接的初始窗口大小不能改，但可以用 WINDOW_UPDATE 帧来改变流量控制窗口</code>，这是为什么连接前言往往带有一个 WINDOW_UPDATE 帧的原因。</p><p>除了改变还未激活的流的流量控制窗口外，SETTIGNS 帧还可以改变已活跃的流 (处于 open 或 half-closed (remote) 状态的流)的初始流量控制窗口的大小。也就是说，当 SETTINGS_INITIAL_WINDOW_SIZE 的值变化时，接收端必须调整它所维护的所有流的流量控制窗口的值，不管是之前就打开的流还是尚未打开的流。</p><p>改变 SETTINGS_INITIAL_WINDOW_SIZE 可能引发流量控制窗口的可用空间变成负值。发送端必须追踪负的流量控制窗口，并且直到它收到了使流量控制窗口变成正值的 WINDOW_UPDATE 帧，才能发送新的 DATA 帧。</p><p>例如，如果连接一建立客户端就立即发送 60KB 的数据，而服务端却将初始窗口大小设置为 16KB，那么客户端一收到 SETTINGS 帧，就会将可用的流量控制窗口重新计算为 -44KB。客户端保持负的流量控制窗口，直到 WINDOW_UPDATE 帧将窗口值恢复为正值，客户端才可以继续发送数据。</p><p>如果改变 SETTINGS_INITIAL_WINDOW_SIZE 导致流量控制窗口超出了最大值，一端必须 将其当做类型为 FLOW_CONTROL_ERROR 的连接错误</p><p>如果接收端希望使用比当前值小的流量控制窗口，可以发送一个新的 SETTINGS 帧。但是，接收端必须准备好接收超出该窗口值的数据，因为可能在收到 SETTIGNS 帧之前，发送端已经发送了超出该较小窗口值的数据。</p><h4 id="合理使用流控制"><a href="#合理使用流控制" class="headerlink" title="合理使用流控制"></a>合理使用流控制</h4><p>流量控制的定义是用来保护端点在资源约束条件下的操作。例如，一个代理需要在很多连接之间共享内存，也有可能有缓慢的上游连接和快速的下游连接。流量控制解决了接收方无法在一个流上处理数据，但仍希望继续处理同一连接中的其他流的情况。</p><p>不需要此功能的部署可以通告最大大小 (2^31 - 1) 的流量控制窗口，并且可以通过在收到任何数据时发送 WINDOW_UPDATE 帧来维护此窗口大小保持不变。这可以有效禁用接受方的流控制。相反地，发送方总是受控于接收方通告的流控制窗口的限制。</p><p>资源约束下(例如内存)的调度可以使用流量来限制一个对端可以消耗的内存量。需要注意的是如果在不知道带宽延迟积的时候启用流量控制可能导致无法最优的利用可用的网络资源 (RFC1323)。</p><p>即便是对当前的网络延迟乘积有充分的认识，流量控制的实现也可能很复杂。当使用流量控制时，接收端必须及时地从 TCP 接收缓冲区读取数据。这样做可能导致在一些例如 WINDOW_UPDATE 的关键帧在 HTTP/2 不可用时导致死锁。但是流量控制可以保证约束资源能在不需要减少连接利用的情况下得到保护。</p><h3 id="HTTP-2-的协议协商机制"><a href="#HTTP-2-的协议协商机制" class="headerlink" title="HTTP/2 的协议协商机制"></a>HTTP/2 的协议协商机制</h3><h4 id="非加密下的协商-h2c"><a href="#非加密下的协商-h2c" class="headerlink" title="非加密下的协商 - h2c"></a>非加密下的协商 - h2c</h4><p>客户端使用 HTTP Upgrade 机制请求升级，HTTP2-Settings 首部字段是一个专用于连接的首部字段，它包含管理 HTTP/2 连接的参数(使用 Base64 编码)，其前提是假设服务端会接受升级请求</p><pre class="line-numbers language-http"><code class="language-http"> GET / HTTP/1.1
 Host: server.example.com
 Connection: Upgrade, HTTP2-Settings
 Upgrade: h2c
 HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器如果支持 http/2 并同意升级，则转换协议，否则忽略</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">101 Switching Protocols</span></span>
<span class="token header-name keyword">Connection:</span> Upgrade
<span class="token header-name keyword">Upgrade:</span> h2c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时潜在的存在一个流 0x1，客户端上这个流在完成 h1 请求后便转为 <code>half-closed</code> 状态，服务端会用这个流返回响应</p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-2.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-3.png" alt="image"></p><p>注意图中第一个响应所在的流是 0x1，与上文所说的一致</p><p>目前浏览器只支持 TLS 加密下的 HTTP/2 通信，所以上述情况在浏览器中目前是不可能碰到的，图中显示的是 nghttp 客户端发起的请求</p><h4 id="加密的协商机制-h2"><a href="#加密的协商机制-h2" class="headerlink" title="加密的协商机制 - h2"></a>加密的协商机制 - h2</h4><p>TLS 加密中在 Client-Hello 和 Server-Hello 的过程中通过 <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">ALPN</a> 进行协议协商</p><p><img src="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_1.png" alt="image"></p><p>应用层协议协商在 TLS 握手第一步的扩展中，Client Hello 中客户端指定 ALPN Next Protocol 为 h2 或者 http/1.1 说明客户端支持的协议</p><p><img src="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_2.png" alt="image"></p><p>服务端如果在 Server Hello 中选择 h2 扩展，说明协商协议为 h2，后续请求响应跟着变化；如果服务端未设置 http/2 或者不支持 h2，则继续用 http/1.1 通信</p><h3 id="分析实例"><a href="#分析实例" class="headerlink" title="分析实例"></a>分析实例</h3><p><img src="https://src.wangriyu.wang/images/blog/http/all-frames.png" alt="image"></p><p>196: TLS 握手第一步 Client Hello，开始协议协商，且此处带上了 Session Ticket</p><p>200: Server Hello 同意使用 h2，而且客户端的会话票证有效，恢复会话，握手成功</p><p>202: 客户端也恢复会话，开始加密后续消息</p><p>205: 服务端发起一个连接前言 (SETTINGS)，SETTINGS 帧中设置了最大并行流数量、初始窗口大小、最大帧长度，然后 (WINDOW_UPDATE) 扩大窗口大小</p><p>310: 客户端也发送一个连接前言 Magic，并初始化设置 (SETTINGS)，SETTINGS 帧中设置了 HEADER TABLE 大小、初始窗口大小、最大并行流数量，然后 (WINDOW_UPDATE) 扩大窗口大小</p><p>311: 客户端发送完连接前言后可以立即跟上一个请求，GET / (HEADERS[1])，而且这个 HEADERS 帧还带有 END_STREAM，这会使流 1 从 idle 状态立即转为 half-closed(local) 状态 (open 是中间态)</p><p><img src="https://src.wangriyu.wang/images/blog/http/all-frames-1.png" alt="image"></p><p>311: 此消息中还包含一个客户端发送给服务端的带 ACK 的 SETTINGS 帧</p><p>312: 服务端也响应带 ACK 的 SETTINGS 帧</p><p>321: 服务端在流 1 (此时状态为 half-closed(remote)) 上发送了四个 PUSH_PROMISE 帧，它们分别保留了流 2、4、6、8 用于后续推送，</p><p><img src="https://src.wangriyu.wang/images/blog/http/all-frames-2.png" alt="image"></p><p>321: 此消息中还返回了上面请求的响应 (HEADERS - DATA)，最后 DATA 带上 END_STREAM，流 1 从 half-closed 转为 closed</p><p>329: 调整流优先级，依赖关系: 8 -&gt; 6 -&gt; 4 -&gt; 2 -&gt; 1 (都带有独占标志，而且权重均为 110)</p><p><img src="https://src.wangriyu.wang/images/blog/http/priority-1.png" alt="image"></p><p>342: 流 1 关闭后，流 2 得到分配资源，服务器开始推送，数据由两个 DATA 帧返回</p><p>344: 流 2 结束，开始推送流 4</p><p>356: 调整依赖关系</p><p><img src="https://src.wangriyu.wang/images/blog/http/priority-2.png" alt="image"></p><pre class="line-numbers language-http"><code class="language-http">  1         1         1         1(w: 110)
  |         |         |         |
  2         2         2         2(w: 110)
  |         |         |         |
  4   ==>   4   ==>   6   ==>   6(w: 147)
  |         |         |         |
  6         8         4         8(w: 147)
  |         |         |         |
  8         6         8         4(w: 110)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>367、369、372: 推送 6 和 8 的流数据</p><p>377: 发起一个请求，打开流 3，其中客户端发起的请求都是依赖流 0x0</p><p>之后都是同样的套路完成请求 - 响应，最后以 GOAWAY 帧关闭连接结束</p><h3 id="HPACK-算法"><a href="#HPACK-算法" class="headerlink" title="HPACK 算法"></a>HPACK 算法</h3><p><img src="https://src.wangriyu.wang/images/blog/http/hpack.png" alt="image"></p><p>上图来自 Ilya Grigorik 的 PPT - <a href="#references">HTTP/2 is here, let’s optimize!</a></p><p>可以清楚地看到 HTTP2 头部使用的也是键值对形式的值，而且 HTTP1 当中的请求行以及状态行也被分割成键值对，还有所有键都是小写，不同于 HTTP1。除此之外，还有一个包含静态索引表和动态索引表的索引空间，实际传输时会把头部键值表压缩，使用的算法即 HPACK，其原理就是匹配当前连接存在的索引空间，若某个键值已存在，则用相应的索引代替首部条目，比如 “:method: GET” 可以匹配到静态索引中的 index 2，传输时只需要传输一个包含 2 的字节即可；若索引空间中不存在，则用字符编码传输，字符编码可以选择哈夫曼编码，然后分情况判断是否需要存入动态索引表中</p><h4 id="索引表"><a href="#索引表" class="headerlink" title="索引表"></a>索引表</h4><h5 id="静态索引"><a href="#静态索引" class="headerlink" title="静态索引"></a>静态索引</h5><p>静态索引表是固定的，对于客户端服务端都一样，目前协议商定的静态索引包含 61 个键值，详见 <a href="https://httpwg.org/specs/rfc7541.html#static.table.definition" target="_blank" rel="noopener">Static Table Definition - RFC 7541</a></p><p>比如前几个如下</p><table><thead><tr><th style="text-align:left">索引</th><th style="text-align:left">字段值</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">index</td><td style="text-align:left">Header Name</td><td style="text-align:left">Header Value</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">:authority</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">:method</td><td style="text-align:left">GET</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">:method</td><td style="text-align:left">POST</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">:path</td><td style="text-align:left">/</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">:path</td><td style="text-align:left">/index.html</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">:scheme</td><td style="text-align:left">http</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">:scheme</td><td style="text-align:left">https</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">:status</td><td style="text-align:left">200</td></tr></tbody></table><h5 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h5><p>动态索引表是一个 FIFO 队列维护的有空间限制的表，里面含有非静态表的索引。<br>动态索引表是需要连接双方维护的，其内容基于连接上下文，一个 HTTP2 连接有且仅有一份动态表。<br>当一个首部匹配不到索引时，可以选择把它插入动态索引表中，下次同名的值就可能会在表中查到索引并替换。<br>但是并非所有首部键值都会存入动态索引，因为动态索引表是有空间限制的，最大值由 SETTING 帧中的 SETTINGS_HEADER_TABLE_SIZE (默认 4096 字节) 设置</p><ul><li>如何计算动态索引表的大小 (Table Size):</li></ul><p>大小均以字节为单位，动态索引表的大小等于所有条目大小之和，每个条目的大小 = 字段长度 + 键值长度 + 32</p><blockquote><p>这个额外的 32 字节是预估的条目开销，比如一个条目使用了两个 64-bit 指针分别指向字段和键值，并使用两个 64-bit 整数来记录字段和键值的引用次数</p><p>golang 实现也是加上了 32: <a href="https://github.com/golang/net/blob/db08ff08e8622530d9ed3a0e8ac279f6d4c02196/http2/hpack/hpack.go#L61" target="_blank" rel="noopener">golang.org/x/net/http2/hpack/hpack.go#L61</a></p></blockquote><p>SETTING 帧规定了动态表的最大大小，但编码器可以另外选择一个比 SETTINGS_HEADER_TABLE_SIZE 小的值作为动态表的有效负载量</p><ul><li>如何更新动态索引表的最大容量</li></ul><p>修改最大动态表容量可以发送一个 <code>dynamic table size update</code> 信号来更改:</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前缀 001 代表此字节为 <code>dynamic table size update</code> 信号，后面使用 <strong>N=5 的整数编码方法</strong>表示新的最大动态表容量(不能超过 SETTINGS_HEADER_TABLE_SIZE)，其计算方法下文会介绍。</p><p>需要注意的是这个信号必须在首部块发送之前或者两个首部块传输的间隔发送，可以通过发送一个 Max size 为 0 的更新信号来清空现有动态表</p><ul><li>动态索引表什么时候需要驱逐条目</li></ul><ol><li>每当出现表大小更新的信号时，需要判断并驱逐队尾的条目，即旧的索引，直到当前大小小于等于新的容量</li><li>每当插入新条目时，需要判断并驱逐队尾的条目，直到当前大小小于等于容量。这个情形下插入一个比 Max size 还大的新条目不会视作错误，但其结果是会清空动态索引表</li></ol><blockquote><p>关于动态索引表如何管理的，推荐看下 golang 的实现: <a href="https://github.com/golang/net/blob/db08ff08e8622530d9ed3a0e8ac279f6d4c02196/http2/hpack/hpack.go#L157" target="_blank" rel="noopener">golang.org/x/net/http2/hpack/hpack.go#L157</a>，通过代码能更明白这个过程</p></blockquote><h5 id="索引地址空间"><a href="#索引地址空间" class="headerlink" title="索引地址空间"></a>索引地址空间</h5><p>由静态索引表和动态索引表可以组成一个索引地址空间:</p><pre class="line-numbers language-http"><code class="language-http">  &lt;----------  Index Address Space ---------->
  &lt;-- Static  Table -->  &lt;-- Dynamic Table -->
  +---+-----------+---+  +---+-----------+---+
  | 1 |    ...    | s |  |s+1|    ...    |s+k|
  +---+-----------+---+  +---+-----------+---+
                         ⍋                   |
                         |                   ⍒
                  Insertion Point      Dropping Point
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前 s 就是 61，而有新键值要插入动态索引表时，从 index 62 开始插入队列，所以动态索引表中索引从小到大依次存着从新到旧的键值</p><h4 id="编码类型表示"><a href="#编码类型表示" class="headerlink" title="编码类型表示"></a>编码类型表示</h4><p>HPACK 编码使用两种原始类型: 无符号可变长度整数和八位字节表示的字符串，相应地规定了以下两种编码方式</p><h5 id="整数编码"><a href="#整数编码" class="headerlink" title="整数编码"></a>整数编码</h5><p>一个整数编码可以用于表示字段索引值、首部条目索引值或者字符串长度。<br>一个整数编码含两部分: 一个前缀字节和可选的后跟字节序列，只有前缀字节不足以表达整数值时才需要后跟字节，<strong>前缀字节中可用比特位 N 是整数编码的一个参数</strong></p><p>比如下面所示的是一个 N=5 的整数编码(前三比特用于其他标识)，如果我们要编码的整数值小于 2^N - 1，直接用一个前缀字节表示即可，比如 10 就用 <code>???01010</code> 表示</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| ? | ? | ? |       Value       |
+---+---+---+-------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果要编码的整数值 X 大于等于 2^N - 1，前缀字节的可用比特位都设成 1，然后把 X 减去 2^N - 1 得到值 R，并用一个或多个字节序列表示 R，字节序列中每个字节的最高有效位 (msb) 用于表示是否结束，<strong>msb 设为 0 时代表是最后一个字节</strong>。具体编码看下面的伪代码和例子</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| ? | ? | ? | 1   1   1   1   1 |
+---+---+---+-------------------+
| 1 |    Value-(2^N-1) LSB      |
+---+---------------------------+
               ...
+---+---------------------------+
| 0 |    Value-(2^N-1) MSB      |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编码:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">if</span> I <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> encode I on N bits
<span class="token keyword">else</span>
    <span class="token function">encode</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> on N bits
    I <span class="token operator">=</span> I <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    while I <span class="token operator">>=</span> <span class="token number">128</span>
         <span class="token function">encode</span> <span class="token punctuation">(</span>I <span class="token operator">%</span> <span class="token number">128</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span> on <span class="token number">8</span> bits
         I <span class="token operator">=</span> I <span class="token operator">/</span> <span class="token number">128</span>
    encode I on <span class="token number">8</span> bits
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解码:</p><pre class="line-numbers language-go"><code class="language-go">decode I from the next N bits
<span class="token keyword">if</span> I <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">return</span> I
<span class="token keyword">else</span>
    M <span class="token operator">=</span> <span class="token number">0</span>
    repeat
        B <span class="token operator">=</span> next octet
        I <span class="token operator">=</span> I <span class="token operator">+</span> <span class="token punctuation">(</span>B <span class="token operator">&amp;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span>M
        M <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">7</span>
    while B <span class="token operator">&amp;</span> <span class="token number">128</span> <span class="token operator">==</span> <span class="token number">128</span>
    <span class="token keyword">return</span> I
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如使用 N=5 的整数编码表示 1337:</p><p>1337 大于 31 (2^5 - 1), 将前缀字节后五位填满 1</p><p>I = 1337 - (2^5 - 1) = 1306</p><p>I 仍然大于 128, I % 128 = 26, 26 + 128 = 154</p><p>154 二进制编码: 10011010, 这即是第一个后跟字节</p><p>I = 1306 / 128 = 10, I 小于 128, 循环结束</p><p>将 I 编码成二进制: 00001010, 这即是最后一个字节</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306 >= 128, encode(154), I=1306/128=10
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10 &lt; 128, encode(10), done
+---+---+---+---+---+---+---+---+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解码时读取第一个字节，发现后五位 (11111) 对应的值 I 等于 31(&gt;= 2^N - 1)，说明还有后跟字节；令 M=0，继续读下一个字节 B，I = I + (B &amp; 127) * 2^M = 31 + 26 * 1 = 57，M = M + 7 = 7，最高有效位为 1，表示字节序列未结束，B 指向下一个字节；I = I + (B &amp; 127) * 2^M = 57 + 10 * 128 = 1337，最高有效位为 0，表示字节码结束，返回 I</p><blockquote><p>这里也可以这样处理 1306: 1306 = 0x51a = (0101 0001 1010)B，将 bit 序列从低到高按 7 个一组分组，则有第一组 001 1010，第二组 000 1010，加上最高有效位 0/1 便与上面的后跟字节对应</p></blockquote><h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><p>一个字符串可能代表 Header 条目的字段或者键值。字符编码使用字节序列表示，要么直接使用字符的八位字节码要么使用哈夫曼编码。</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| H |    String Length (7+)     |
+---+---------------------------+
|  String Data (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>H: 一个比特位表示是否使用哈夫曼编码</li><li>String Length: 代表字节序列长度，即 String Data 的长度，使用 N=7 的整数编码方式表示</li><li>String Data: 字符串的八位字节码序列表示，如果 H 为 0，则此处就是原字符的八位字节码表示；如果 H 为 1，则此处为原字符的哈夫曼编码</li></ul><p>RFC 7541 给出了一份字符的哈夫曼编码表: <a href="https://httpwg.org/specs/rfc7541.html#huffman.code" target="_blank" rel="noopener">Huffman Code</a>，这是基于大量 HTTP 首部数据生成的哈夫曼编码。</p><ul><li>当中第一列 (sym) 表示要编码的字符，最后的特殊字符 “EOS” 代表字符串结束</li><li>第二列 (code as bits) 是二进制哈夫曼编码，向最高有效位对齐</li><li>第三列 (code as hex) 是十六进制哈夫曼编码，向最低有效位对齐</li><li>最后一列 (len) 代表编码长度，单位 bit</li></ul><p>使用哈夫曼编码可能存在编码不是整字节的，会在后面填充 1 使其变成整字节</p><p>比如下面的例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-IndexedName.png" alt="Literal Header Field with Incremental Indexing - Indexed Name"></p><p><code>:authority: blog.wangriyu.wang</code> 首部对应的编码为:</p><pre class="line-numbers language-http"><code class="language-http">41 8e 8e 83 cc bf 81 d5    35 86 f5 6a fe 07 54 df
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Literal Header Field with Incremental Indexing — Indexed Name</code> 的编码格式见下文</p><p>41 (0100 0001) 表示字段存在索引值 1，即对应静态表中第一项 :authority</p><p>8e (1000 1110) 最高有效位为 1 表示键值使用哈夫曼编码，000 1110 表示字节序列长度为 14</p><p>后面 <code>8e 83 cc bf 81 d5 35 86 f5 6a fe 07 54 df</code> 是一段哈夫曼编码序列</p><p>由哈夫曼编码表可知 100011 -&gt; ‘b’, 101000 -&gt; ‘l’, 00111 -&gt; ‘o’, 100110 -&gt; ‘g’, 010111 -&gt; ‘.’, 1111000 -&gt; ‘w’, 00011 -&gt; ‘a’, 101010 -&gt; ‘n’, 100110 -&gt; ‘g’, 101100 -&gt; ‘r’, 00110 -&gt; ‘i’, 1111010 -&gt; ‘y’, 101101 -&gt; ‘u’</p><pre class="line-numbers language-http"><code class="language-http">8e 83 cc bf 81 d5 35 86 f5 6a fe 07 54 df
                         |
                         ⍒
1000 1110 1000 0011 1100 1100 1011 1111 1000 0001 1101 0101 0011 0101 1000 0110 1111 0101 0110 1010 1111 1110 0000 0111 0101 0100 1101 1111
                         |
                         ⍒
100011 101000 00111 100110 010111 1111000 00011 101010 100110 101100 00110 1111010 101101 010111 1111000 00011 101010 100110 11111
                         |
                         ⍒
blog.wangriyu.wang  最后 11111 用于填充
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h4><p>现在开始是 HPACK 真正的编解码规范</p><h5 id="已索引首部条目表示-Indexed-Header-Field-Representation"><a href="#已索引首部条目表示-Indexed-Header-Field-Representation" class="headerlink" title="已索引首部条目表示 (Indexed Header Field Representation)"></a>已索引首部条目表示 (Indexed Header Field Representation)</h5><ul><li><code>Indexed Header Field</code></li></ul><p>以 1 开始为标识，能在索引空间匹配到索引的首部会替换成这种形式，后面的 index 使用上述的整数编码方式且 N = 7。<br>比如 <code>:method: GET</code> 可以用 0x82，即 10000010 表示</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/Indexed-Header-Field.png" alt="Indexed Header Field"></p><h5 id="未索引文字首部条目表示-Literal-Header-Field-Representation"><a href="#未索引文字首部条目表示-Literal-Header-Field-Representation" class="headerlink" title="未索引文字首部条目表示 (Literal Header Field Representation)"></a>未索引文字首部条目表示 (Literal Header Field Representation)</h5><p>尚未被索引的首部有三种表示形式，第一种会添加进索引，第二种对于当前跳来说不会添加进索引，第三种绝对不被允许添加进索引</p><ol><li>会添加索引的文字首部 (Literal Header Field with Incremental Indexing)</li></ol><p>以 01 开始为标识，此首部会加入到解码后的首部列表 (Header List) 中并且会把它<strong>作为新条目插入到动态索引表中</strong></p><ul><li><code>Literal Header Field with Incremental Indexing — Indexed Name</code></li></ul><p>如果字段已经存在索引，但键值未被索引，比如首部 <code>:authority: blog.wangriyu.wang</code> 的字段 <code>:authority</code> 已存在索引但键值 <code>blog.wangriyu.wang</code> 不存在索引，则会替换成如下形式 (index 使用 N=6 的整数编码表示)</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-IndexedName.png" alt="Literal Header Field with Incremental Indexing - Indexed Name"></p><ul><li><code>Literal Header Field with Incremental Indexing — New Name</code></li></ul><p>如果字段和键值均未被索引，比如 <code>upgrade-insecure-requests: 1</code>，则会替换成如下形式</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-NewName.png" alt="Literal Header Field with Incremental Indexing — New Name"></p><ol start="2"><li>不添加索引的首部 (Literal Header Field without Indexing)</li></ol><p>以 0000 开始为标识，此首部会加入到解码后的首部列表中，但<strong>不会插入到动态索引表中</strong></p><ul><li><code>Literal Header Field without Indexing — Indexed Name</code></li></ul><p>如果字段已经存在索引，但键值未被索引，则会替换成如下形式 (index 使用 N=4 的整数编码表示)</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-without-Indexing-IndexedName.png" alt="Literal Header Field without Indexing - Indexed Name"></p><ul><li><code>Literal Header Field without Indexing — New Name</code></li></ul><p>如果字段和键值均未被索引，则会替换成如下形式。比如 <code>strict-transport-security: max-age=63072000; includeSubdomains</code></p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-without-Indexing-NewName.png" alt="Literal Header Field without Indexing - New Name"></p><ol start="3"><li>绝对不添加索引的首部 (Literal Header Field Never Indexed)</li></ol><p>这与上一种首部类似，只是标识为 0001，首部也是会添加进解码后的首部列表中但不会插入动态更新表。</p><p>区别在于这类首部发出是什么格式表示，接收也是一样的格式，作用于每一跳 (hop)，如果中间通过代理，代理必须原样转发不能另行编码。</p><p>而上一种首部只是作用当前跳，通过代理后可能会被重新编码</p><p>golang 实现中使用一个 <code>Sensitive</code> 标明哪些字段是绝对不添加索引的: <a href="https://github.com/golang/net/blob/db08ff08e8622530d9ed3a0e8ac279f6d4c02196/http2/hpack/hpack.go#L41" target="_blank" rel="noopener">golang.org/x/net/http2/hpack/hpack.go#L41</a></p><p>RFC 文档中详细说明了这么做的原因: <a href="https://httpwg.org/specs/rfc7541.html#never.indexed.literals" target="_blank" rel="noopener">Never-Indexed Literals</a></p><p>表示形式除了标识其他都跟上一种首部一样:</p><ul><li><code>Literal Header Field Never Indexed — Indexed Name</code></li></ul><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Literal Header Field Never Indexed — New Name</code></li></ul><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="动态表最大容量更新-Dynamic-Table-Size-Update"><a href="#动态表最大容量更新-Dynamic-Table-Size-Update" class="headerlink" title="动态表最大容量更新 (Dynamic Table Size Update)"></a>动态表最大容量更新 (Dynamic Table Size Update)</h5><p>以 001 开始为标识，作用前面已经提过</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/Dynamic-Table-Size-Update-0.png" alt="Literal Header Field without Indexing - Indexed Name"></p><p>可以发送 Max Size 为 0 的更新来清空动态索引表</p><p><img src="https://src.wangriyu.wang/images/blog/http/Dynamic-Table-Size-Update-1.png" alt="Literal Header Field without Indexing - Indexed Name"></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>RFC 中给出了很多实例 <a href="https://httpwg.org/specs/rfc7541.html#examples" target="_blank" rel="noopener">Examples - RFC 7541</a>，推荐看一遍加深理解</p><h2 id="What-then"><a href="#What-then" class="headerlink" title="What then ?"></a>What then ?</h2><h3 id="HTTP-2-演示"><a href="#HTTP-2-演示" class="headerlink" title="HTTP/2 演示"></a>HTTP/2 演示</h3><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a></p><p><a href="https://http2.golang.org/" target="_blank" rel="noopener">https://http2.golang.org/</a></p><p>网站启用 h2 的前后对比，使用 <a href="http://www.webpagetest.org/" target="_blank" rel="noopener">WebPageTest</a> 做的测试，第一张是 h1，第二张是 h2:</p><p><img src="https://src.wangriyu.wang/images/blog/http/webtest-h1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/webtest-h2.png" alt="image"></p><h3 id="使用-HTTP-2-建议"><a href="#使用-HTTP-2-建议" class="headerlink" title="使用 HTTP/2 建议"></a>使用 HTTP/2 建议</h3><p>nginx 开启 HTTP2 只需在相应的 HTTPS 设置后加上 <code>http2</code> 即可</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">443</span> <span class="token keyword">ssl</span> http2 ipv6only<span class="token operator">=</span>on<span class="token punctuation">;</span>
<span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="以下几点是-HTTP-1-和-HTTP-2-都同样适用的"><a href="#以下几点是-HTTP-1-和-HTTP-2-都同样适用的" class="headerlink" title="以下几点是 HTTP/1 和 HTTP/2 都同样适用的"></a>以下几点是 HTTP/1 和 HTTP/2 都同样适用的</h4><p>1、开启压缩</p><p>配置 gzip 等可以使传输内容更小，传输速度更快</p><p>例如 nginx 可以再 http 模块中加入以下字段，其他字段和详细解释可以谷歌</p><pre class="line-numbers language-nginx"><code class="language-nginx">    <span class="token keyword">gzip</span>  on<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 开启
    <span class="token keyword">gzip_min_length</span> 1k<span class="token punctuation">;</span>
    <span class="token keyword">gzip_comp_level</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 压缩级别
    <span class="token keyword">gzip_types</span> text<span class="token operator">/</span>plain application<span class="token operator">/</span>javascript application<span class="token operator">/</span>x<span class="token operator">-</span>javascript application<span class="token operator">/</span>octet<span class="token operator">-</span>stream application<span class="token operator">/</span>json text<span class="token operator">/</span>css application<span class="token operator">/</span>xml text<span class="token operator">/</span>javascript application<span class="token operator">/</span>x<span class="token operator">-</span>httpd<span class="token operator">-</span>php image<span class="token operator">/</span>jpeg image<span class="token operator">/</span>gif image<span class="token operator">/</span>png font<span class="token operator">/</span>ttf font<span class="token operator">/</span>otf image<span class="token operator">/</span>svg<span class="token operator">+</span>xml<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 需要压缩的文件类型
    <span class="token keyword">gzip_vary</span> on<span class="token punctuation">;</span>
    <span class="token keyword">gzip_disable</span> <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、使用缓存</p><p>给静态资源设置一个缓存期是非常有必要的，关于缓存见另一篇博文 <code>HTTP Message</code></p><p>例如 nginx 在 server 模块中添加以下字段可以设置缓存时间</p><pre class="line-numbers language-nginx"><code class="language-nginx"> <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>ico<span class="token operator">|</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token operator">|</span>png<span class="token operator">|</span>moc<span class="token operator">|</span>mtn<span class="token operator">|</span>mp3<span class="token operator">|</span><span class="token keyword">mp4</span><span class="token operator">|</span>mov<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
   <span class="token keyword">expires</span>      30d<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>css<span class="token operator">|</span>js<span class="token operator">|</span>txt<span class="token operator">|</span>xml<span class="token operator">|</span>swf<span class="token operator">|</span>wav<span class="token operator">|</span>json<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
   <span class="token keyword">expires</span>      5d<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>html<span class="token operator">|</span>htm<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">expires</span>      24h<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>eot<span class="token operator">|</span>ttf<span class="token operator">|</span>otf<span class="token operator">|</span>woff<span class="token operator">|</span>svg<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
   <span class="token keyword">expires</span> 30d<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、CDN 加速</p><p>CDN 的好处是就近访问，延迟低，访问快</p><p>4、减少 DNS 查询</p><p>每个域名都需要 DNS 查询，一般需要几毫秒到几百毫秒，移动环境下会更慢。DNS 解析完成之前，请求会被阻塞。减少 DNS 查询也是优化项之一</p><p>浏览器的 <a href="https://en.wikipedia.org/wiki/Link_prefetching" target="_blank" rel="noopener">DNS Prefetching</a> 技术也是一种优化手段</p><p>5、减少重定向</p><p>重定向可能引入新的 DNS 查询、新的 TCP 连接以及新的 HTTP 请求，所以减少重定向也很重要。</p><p>浏览器基本都会缓存通过 301 Moved Permanently 指定的跳转，所以对于永久性跳转，可以考虑使用状态码 301。对于启用了 HTTPS 的网站，配置 HSTS 策略，也可以减少从 HTTP 到 HTTPS 的重定向</p><h4 id="但以下几点就不推荐在-HTTP-2-中用了"><a href="#但以下几点就不推荐在-HTTP-2-中用了" class="headerlink" title="但以下几点就不推荐在 HTTP/2 中用了"></a>但以下几点就不推荐在 HTTP/2 中用了</h4><p>1、域名分片</p><p>HTTP/2 对于同一域名使用一个 TCP 连接足矣，过多 TCP 连接浪费资源而且效果不见得一定好</p><p>而且资源分域会破坏 HTTP/2 的优先级特性，还会降低头部压缩效果</p><p>2、资源合并</p><p>资源合并会不利于缓存机制，而且单文件过大对于 HTTP/2 的传输不好，尽量做到细粒化更有利于 HTTP/2 传输</p><p>3、资源内联</p><p>HTTP/2 支持 Server-Push，相比较内联优势更大效果更好</p><p>而且内联的资源不能有效缓存</p><p>如果有共用，多页面内联也会造成浪费</p><h4 id="HTTP-2-最佳实践"><a href="#HTTP-2-最佳实践" class="headerlink" title="HTTP/2 最佳实践"></a>HTTP/2 最佳实践</h4><p>使用 HTTP/2 尽可能用最少的连接，因为同一个连接上产生的请求和响应越多，动态字典积累得越全，头部压缩效果也就越好，而且多路复用效率高，不会像多连接那样造成资源浪费</p><p>为此需要注意以下两点:</p><ul><li>同一域名下的资源使用同一个连接，这是 HTTP/2 的特性</li><li>不同域名下的资源，如果满足能解析到同一 IP 或者使用的是同一个证书(比如泛域名证书)，HTTP/2 可以合并多个连接</li></ul><p>所以使用相同的 IP 和证书部署 Web 服务是目前最好的选择，因为这让支持 HTTP/2 的终端可以复用同一个连接，实现 HTTP/2 协议带来的好处；而只支持 HTTP/1.1 的终端则会不同域名建立不同连接，达到同时更多并发请求的目的</p><p>比如 Google 一系列网站都是用的同一个证书:</p><p><img src="https://src.wangriyu.wang/images/blog/http/google-dns.png" alt="image"></p><p>但是这好像也会造成一个问题，我使用 nginx 搭建的 webserver，有三个虚拟主机，它们共用一套证书，其中两个我显示地配置了 http2，而剩下一个我并没有配置 http2，结果我访问未配置 http2 的站点时也变成了 http2。</p><h3 id="大图片传输碰到的问题"><a href="#大图片传输碰到的问题" class="headerlink" title="大图片传输碰到的问题"></a>大图片传输碰到的问题</h3><p>先比较一下 h1 和 h2 的页面加载时间，图中绿色代表发起请求收到响应等待负载的时间，蓝色代表下载负载的时间:</p><p><img src="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h2.png" alt="image"></p><p>可以发现 h2 加载时间还比 h1 慢一点，特别是碰到大图片时差别更明显</p><p>这篇文章对不同场景下 h1 和 h2 加载图片做了测试: <a href="https://99designs.com/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/" target="_blank" rel="noopener">Real–world HTTP/2: 400gb of images per day</a></p><p>其结果是:</p><ul><li><p>对一个典型的富图像，延迟限制 (latency–bound) 的界面来说。使用一个高速，低延迟的连接，视觉完成度 (visual completion) 平均会快 5%。</p></li><li><p>对一个图像极其多，带宽限制 (bandwidth–bound) 的页面来说。使用同样的连接，视觉完成度平均将会慢 5–10%，但页面的整体加载时间实际是减少了，因为得益于连接延迟少。</p></li><li><p>一个高延迟，低速度的连接(比如移动端的慢速 3G) 会对页面的视觉完成造成极大的延迟，但 h2 的视觉完成度明显更高更好。</p></li></ul><p>在所有的测试中，都可以看到: h2 使整体页面的加载速度提高了，并且在初次绘制 (initial render) 上做的更好，虽然第二种情况中视觉完成度略微下降，但总体效果还是好的</p><p>视觉完成度下降的原因是因为没有 HTTP/1.x 同时连接数量的限制，h2 可以同时发起多张图片的请求，服务器可以同时响应图片的负载，可以从下面的动图中看到</p><p><img src="https://src.wangriyu.wang/images/blog/http/safari-h2.gif" alt="image"></p><p>一旦图片下载完成，浏览器就会绘制出它们，然而，小图片下载后会渲染地更快，但是如果一个大图片恰好是初始的视图，那就会花费较长的时间加载，延迟视觉上的完成度。</p><h4 id="chrome-bug"><a href="#chrome-bug" class="headerlink" title="chrome bug"></a>chrome bug</h4><p>上面的动图是在 Safari 上的测试结果，图片最后都下载成功了，而我在 Chrome 上测试时后面的部分图片直接挂了，都报 <code>ERR_SPDY_PROTOCOL_ERROR</code> 错误，而且是百分百复现</p><p><img src="https://src.wangriyu.wang/images/blog/http/chrome-h2.gif" alt="image"></p><p>去看了下 <code>ERR_SPDY_PROTOCOL_ERROR</code> 出在哪，发现是 Server reset stream，应该是哪出错了导致流提前终止</p><p><img src="https://src.wangriyu.wang/images/blog/http/spdyerror-0.png" alt="image"></p><p>然后再研究了一下 HTTP/2 的帧序列，发出的请求都在 629 号消息中响应成功了，但是返回的数据帧只有流 15 上的，实际收到的图片又不止流 15 对应的图片，这是为什么?</p><p><img src="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-0.png" alt="image"></p><p>后面我继续测试发现连续请求几张大图片，虽然 HEADERS 帧都打开的是不同的流，返回的响应的 HEADERS 帧也还是对应前面的流 ID，但是响应的 DATA 帧都是从第一个打开的流上返回的。</p><p>如果是小图片的话，一个请求响应过后这个流就关闭了，下一张小图是在其自己对应的流上返回的。只有连续几张大图会出现上述情形，这个机制很奇怪，我暂时还没有找到解释的文档。</p><p>至于 chrome 为什么出错呢，看一下 TCP 报文就会发现所有数据在一个连接上发送，到后面 TCP 包会出现各种问题，丢包、重传、失序、重包等等，不清楚 Safari 是否也是这样，因为 wireshark 只能解 chrome 的包解不了 Safari 的包</p><p><img src="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-1.png" alt="image"></p><blockquote><p>《web 性能权威指南》中提及 HTTP/2 中一个 TCP 可能会造成的问题:<br>虽然消除了 HTTP 队首阻塞现象，但 TCP 层次上仍存在队首阻塞问题；如果 TCP 窗口缩放被禁用，那带<a href="https://zh.wikipedia.org/wiki/%E5%B8%A6%E5%AE%BD%E6%97%B6%E5%BB%B6%E4%B9%98%E7%A7%AF" target="_blank" rel="noopener">宽延迟积效应</a>可能会限制连接的吞吐量；丢包时 TCP 拥塞窗口会缩小；</p></blockquote><p>TCP 是一方面原因，还有另一方面应该是浏览器策略问题，估计也是 chrome bug，对比两张动图你会发现，safari 接收负载是轮流接收，我们几个接收一点然后换几个人接收，直到所有都接受完；而 chrome 则是按顺序接收，这个接收完才轮到下一个接收，结果后面的图片可能长时间未响应就挂了。</p><h4 id="使用渐进式图片"><a href="#使用渐进式图片" class="headerlink" title="使用渐进式图片"></a>使用渐进式图片</h4><p>渐进式 jpg 代替普通 jpg 有利于提高视觉完成度，而且文件更小:</p><p>输入 <code>convert --version</code> 看看是否已安装 <a href="http://www.imagemagick.org/" target="_blank" rel="noopener">ImageMagic</a>，如果没有先安装: Mac 可以用 <code>brew install imagemagick</code>，Centos 可以用 <code>yum install imagemagick</code></p><p>检测是否为 progressive jpeg，如果输出 None 说明不是 progressive jpeg；如果输出 JPEG 说明是 progressive jpeg:</p><pre class="line-numbers language-bash"><code class="language-bash">$ identify -verbose filename.jpg <span class="token operator">|</span> <span class="token function">grep</span> Interlace
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 basic jpeg 转换成 progressive jpeg，<a href="https://www.imagemagick.org/script/command-line-options.php#interlace" target="_blank" rel="noopener">interlace 参数</a>:</p><pre class="line-numbers language-bash"><code class="language-bash">$ convert -strip -interlace Plane source.jpg destination.jpg // 还可以指定质量 -quality 90

// 批量处理
$ <span class="token keyword">for</span> i <span class="token keyword">in</span> ./*.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> convert -strip -interlace Plane <span class="token variable">$i</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也可以转换 PNG 和 GIF，但是我试过 <code>convert -strip -interlace Plane source.png destination.png</code> 但转换后的图片往往会更大，不推荐这么用，可以 convert source.png destination.jpg</p><p>ImageMagic 还有很多强大的功能</p><pre class="line-numbers language-bash"><code class="language-bash">// 图片缩放
$ convert -resize 50%x50% source.jpg destination.jpg
// 图片格式转换
$ convert source.jpg destination.png
// 配合 <span class="token function">find</span> 命令，将当前目录下大于 100kb 的图片按 75% 质量进行压缩
$ <span class="token function">find</span> -E <span class="token keyword">.</span> -iregex <span class="token string">'.*\.(jpg|png|bmp)'</span> -size +100k -exec convert -strip +profile “*” -quality 75 <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>png 压缩推荐使用 <a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a></p><p>另外 photoshop 保存图片时也可以设置渐进或交错:</p><p>渐进式图片：选择图片格式为 JPEG =&gt; 选中“连续”</p><p>交错式图片：选择图片格式为 PNG/GIF =&gt; 选中“交错”</p><h3 id="SPDY-与-HTTP2-的关系"><a href="#SPDY-与-HTTP2-的关系" class="headerlink" title="SPDY 与 HTTP2 的关系"></a>SPDY 与 HTTP2 的关系</h3><p><a href="https://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a> 是 HTTP2 的前身，大部分特性与 HTTP2 保持一致，包括服务器端推送，多路复用和帧作为传输的最小单位。但 SPDY 与 HTTP2 也有一些实现上的不同，比如 SPDY 的头部压缩使用的是 DEFLATE 算法，而 HTTP2 使用的是 HPACK 算法，压缩率更高。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>Google 的 <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">QUIC(Quick UDP Internet Connections)</a> 协议，继承了 SPDY 的特点。QUIC 是一个 UDP 版的 TCP + TLS + HTTP/2 替代实现。</p><p>QUIC 可以创建更低延迟的连接，并且也像 HTTP/2 一样，通过仅仅阻塞部分流解决了包裹丢失这个问题，让连接在不同网络上建立变得更简单 － 这其实正是 <a href="https://en.wikipedia.org/wiki/Multipath_TCP" target="_blank" rel="noopener">MPTCP</a> 想去解决的问题。</p><p>QUIC 现在还只有 Google 的 Chrome 和它后台服务器上的实现，虽然有第三方库 libquic，但这些代码仍然很难在其他地方被复用。该协议也被 IETF 通信工作组引入了草案。</p><p><a href="https://github.com/mholt/caddy" target="_blank" rel="noopener">Caddy</a>: 基于 Go 语言开发的 Web Server， 对 HTTP/2 和 HTTPS 有着良好的支持，也开始支持 QUIC 协议 (试验性)</p><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><ul><li>Chrome 插件: <a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">HTTP/2 and SPDY indicator</a></li></ul><p>如果你访问的站点开启了 HTTP/2，图标会亮起，而且点击会进入 chrome 内置的 HTTP/2 监视工具</p><ul><li>命令行工具: <a href="https://github.com/nghttp2/nghttp2" target="_blank" rel="noopener">nghttp2</a></li></ul><p>C 语言实现的 HTTP/2，可以用它调试 HTTP/2 请求</p><p>直接 <code>brew install nghttp2</code> 就可以安装，安装好后输入 <code>nghttp -nv https://nghttp2.org</code> 就可以查看 h2 请求</p><p><img src="https://src.wangriyu.wang/images/blog/http/nghttp2.png" alt="image"></p><ul><li><p>除 nghttp2 外还可以用 h2i 测试 http2: <a href="https://github.com/golang/net/blob/master/http2/h2i/README.md" target="_blank" rel="noopener">https://github.com/golang/net/blob/master/http2/h2i/README.md</a></p></li><li><p>还可以用 wireshark 解 h2 的包，不过得设置浏览器提供的对称协商密钥或者服务器提供的私钥，具体方法看此文: <a href="https://imququ.com/post/http2-traffic-in-wireshark.html" target="_blank" rel="noopener">使用 Wireshark 调试 HTTP/2 流量</a></p></li></ul><p>如果无法解包看一下 sslkeylog.log 文件有没有写入数据，如果没有数据说明浏览器打开方式不对，得用命令行打开浏览器，这样才能让浏览器读取环境变量然后向 sslkeylog 写入密钥，另外此方法好像支持谷歌浏览器和火狐，对 Safari 无效</p><p>如果 sslkeylog.log 有数据，wireshark 还是无法解包，打开设置的 SSL 选项重新选择一下文件试试，如果还是不行也用命令行打开 Wireshark</p><p>一次不行多试几次</p><ul><li><a href="https://github.com/h2o/h2o" target="_blank" rel="noopener">h2o</a>: 优化的 HTTP Server，对 HTTP/2 的支持性做的比较好</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.slideshare.net/qgy18/http2-55366951" target="_blank" rel="noopener">HTTP/2: 新的机遇与挑战</a></li><li><a href="https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.p19" target="_blank" rel="noopener">HTTP2 is here, let’s optimize!</a></li><li><a href="https://imququ.com/post/series.html" target="_blank" rel="noopener">JerryQu’s Blog</a></li><li><a href="https://daniel.haxx.se/http2/" target="_blank" rel="noopener">http2 explained</a></li><li><a href="https://cdn-1.wp.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf" target="_blank" rel="noopener">NGINX HTTP2 White Paper</a></li><li><a href="https://calendar.perfplanet.com/2016/http2-push-the-details/" target="_blank" rel="noopener">HTTP/2 Push: The details</a></li><li>《web 性能权威指南》</li></ul>]]></content>
    
    <summary type="html">
    
      秉着 WTF(What the hell is That, Find the answers!) 原则探究 HTTP2，结合理论与实践，广度与深度并存
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
      <category term="网络" scheme="https://blog.wangriyu.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家</title>
    <link href="https://blog.wangriyu.wang/2018/05-server-git.html"/>
    <id>https://blog.wangriyu.wang/2018/05-server-git.html</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-06-17T13:04:09.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>3 月份腾讯云搞了一波活动，我也跟了一波车，花了 360 换了五年的服务器，美滋滋！虽然后来四月份阿里云也出了活动，我是更喜欢阿里云的，但是这波也不算亏。有了服务器之后做的第一件事就是把博客搬到服务器上，其实两个月前就弄好了，后来又折腾服务器去了，本来想等各种东西都折腾一遍后再写这篇博客，但是一拖拖到现在，罪过罪过！</p><blockquote><p>系统环境为 CentOS 7.4，默认用户为 root</p></blockquote><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>新系统需要安装更新和一些常用工具</p><pre class="line-numbers language-bash"><code class="language-bash">$ yum -y update
// 安装 node 和 <span class="token function">npm</span>
$ yum <span class="token function">install</span> epel-release
$ yum <span class="token function">install</span> nodejs
$ node --version
$ <span class="token function">npm</span> --version
// 设置 <span class="token function">npm</span> 源
$ <span class="token function">npm</span> config get registry
$ <span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org
// 可以安装 node 版本管理工具 n
$ <span class="token function">npm</span> <span class="token function">install</span> -g n
$ n stable
// 安装 <span class="token function">git</span>
$ yum <span class="token function">install</span> <span class="token function">git</span>
$ <span class="token function">git</span> --version
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改域名解析"><a href="#修改域名解析" class="headerlink" title="修改域名解析"></a>修改域名解析</h2><p>原本域名是解析到 wangriyu.github.io 上，现在改为 A 类 ip 地址，填服务器的公有 ip</p><h2 id="设置-webserver"><a href="#设置-webserver" class="headerlink" title="设置 webserver"></a>设置 webserver</h2><h3 id="安装最新版-nginx"><a href="#安装最新版-nginx" class="headerlink" title="安装最新版 nginx"></a>安装最新版 nginx</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">vi</span> /etc/yum.repos.d/nginx.repo
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写入以下内容，baseurl 根据系统修改如果是 centos 6 的话把当中的 7 改成 6，输入 <code>cat /etc/centos-release</code> 或者 <code>hostnamectl</code> 可以查看系统版本信息</p><pre class="line-numbers language-vim"><code class="language-vim"><span class="token punctuation">[</span>nginx<span class="token punctuation">]</span>
name<span class="token operator">=</span>nginx repo
baseurl<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>nginx<span class="token operator">.</span>org<span class="token operator">/</span>packages<span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>$basearch<span class="token operator">/</span>
gpgcheck<span class="token operator">=</span><span class="token number">0</span>
enabled<span class="token operator">=</span><span class="token number">0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>清空缓存</p><pre class="line-numbers language-bash"><code class="language-bash">$ yum clean all
$ yum makecache
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入 list 可以查看是否包含最新版本</p><pre class="line-numbers language-bash"><code class="language-bash">$ yum list <span class="token operator">|</span> <span class="token function">grep</span> nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后安装</p><pre class="line-numbers language-bash"><code class="language-bash">$ yum <span class="token function">install</span> -y nginx
$ nginx -V <span class="token comment" spellcheck="true"># 查看版本</span>
$ rpm -ql nginx <span class="token comment" spellcheck="true"># 列出nginx的安装文件</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动服务并设置开机自启动</p><pre class="line-numbers language-bash"><code class="language-bash">$ systemctl start nginx
$ systemctl <span class="token function">enable</span> nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时访问服务器 ip 应该可以看到 nginx 的默认欢迎页了</p><h3 id="添加-Let’-Encrypt-通配符证书"><a href="#添加-Let’-Encrypt-通配符证书" class="headerlink" title="添加 Let’ Encrypt 通配符证书"></a>添加 Let’ Encrypt 通配符证书</h3><blockquote><p>国内的域名需要先备案，不然最后生成证书的时候可能会失败</p></blockquote><p>使用 CertBot 来生成证书，不同系统的方法可以到官网看: <a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/centosrhel7-nginx</a></p><p>安装 Certbot</p><pre class="line-numbers language-bash"><code class="language-bash">$ yum -y <span class="token function">install</span> yum-utils
$ yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional
$ yum <span class="token function">install</span> certbot-nginx
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>生成证书</p><pre class="line-numbers language-bash"><code class="language-bash">$ certbot certonly --manual -d *.wangriyu.wang -d wangriyu.wang --agree-tos --manual-public-ip-logging-ok --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一步会要求你去添加一条 TXT DNS 解析记录，添加完后最好多等几分钟，等 DNS 生效再进入下一步，<br>如果验证失败了需要重新解析</p><p><img src="https://src.wangriyu.wang/images/blog/server/certbot.png" alt="image"></p><p>证书创建好后会输出证书位置，可以到 nginx 里设置虚拟机的 ssl_certificate 和 ssl_certificate_key 为生成的证书位置</p><pre class="line-numbers language-bash"><code class="language-bash">$ certbot certificates // 查看本地证书信息

$ certbot delete // 删除证书
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Let’s Encrypt 证书只有 90 天有效期，快到期时可以用 <code>certbot renew</code> 更新证书，更简单的做法是添加一个 cron 任务</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">crontab</span> -e
写入 30 0 1 * * root /usr/bin/certbot renew --renew-hook <span class="token string">"/usr/sbin/nginx -s reload"</span>
$ <span class="token function">crontab</span> -l <span class="token comment" spellcheck="true"># 查看所有任务</span>
$ <span class="token function">service</span> crond restart
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>每个月 1 号 0 点 30 分会自动执行该任务并重载 nginx</p><blockquote><p>如果之后使用 certbot 出现 ImportError: ‘pyOpenSSL’ module missing required functionality. Try upgrading to v0.14 or newer. 错误<br>依次输入以下命令修复</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ pip uninstall requests
$ pip uninstall urllib3
$ yum remove python-urllib3
$ yum remove python-requests
$ yum remove certbot
$ yum <span class="token function">install</span> python-urllib3
$ yum <span class="token function">install</span> python-requests
$ yum <span class="token function">install</span> certbot
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置服务器和虚拟机"><a href="#配置服务器和虚拟机" class="headerlink" title="配置服务器和虚拟机"></a>配置服务器和虚拟机</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> /etc/nginx
$ tree <span class="token keyword">.</span>
├── conf.d <span class="token comment" spellcheck="true"># 虚拟机文件，最好一个域名一个文件</span>
│   ├── default.conf
│   ├── blog.wangriyu.wang.conf
│   └── wangriyu.wang.conf
├── default.d
├── nginx.conf <span class="token comment" spellcheck="true"># 服务器配置文件</span>
├── ssl
│   └── dhparam.pem
└── <span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>详细的设置我这不多说，上网搜一下 nginx 配置大把教程，我这里贴一下我的配置，仅作参考</p><ul><li>nginx.conf</li></ul><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">http</span> <span class="token punctuation">{</span>
    <span class="token keyword">include</span>       <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>mime<span class="token punctuation">.</span><span class="token keyword">types</span><span class="token punctuation">;</span>
    <span class="token keyword">default_type</span>  application<span class="token operator">/</span>octet<span class="token operator">-</span>stream<span class="token punctuation">;</span>

    <span class="token keyword">log_format</span>  main  <span class="token string">'$remote_addr - $remote_user [$time_local] "$request" '</span>
                      <span class="token string">'$status $body_bytes_sent "$http_referer" '</span>
                      <span class="token string">'"$http_user_agent" "$http_x_forwarded_for"'</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true"># access_log  /var/log/nginx/access.log  main;</span>

    <span class="token keyword">sendfile</span>        on<span class="token punctuation">;</span>
    <span class="token keyword">tcp_nopush</span>     on<span class="token punctuation">;</span>
    <span class="token keyword">tcp_nodelay</span>    on<span class="token punctuation">;</span>

    <span class="token keyword">keepalive_timeout</span>  <span class="token number">60</span><span class="token punctuation">;</span>

    <span class="token keyword">server_tokens</span> off<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true"># 设置 gzip 压缩</span>
    <span class="token keyword">gzip</span>  on<span class="token punctuation">;</span>
    <span class="token keyword">gzip_min_length</span> 1k<span class="token punctuation">;</span>
    <span class="token keyword">gzip_comp_level</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">gzip_buffers</span>    <span class="token number">16</span> 8k<span class="token punctuation">;</span>
    <span class="token keyword">gzip_types</span> text<span class="token operator">/</span>plain application<span class="token operator">/</span>javascript application<span class="token operator">/</span>x<span class="token operator">-</span>javascript application<span class="token operator">/</span>octet<span class="token operator">-</span>stream application<span class="token operator">/</span>json text<span class="token operator">/</span>css application<span class="token operator">/</span>xml text<span class="token operator">/</span>javascript application<span class="token operator">/</span>x<span class="token operator">-</span>httpd<span class="token operator">-</span>php image<span class="token operator">/</span>jpeg image<span class="token operator">/</span>jpg image<span class="token operator">/</span>gif image<span class="token operator">/</span>png font<span class="token operator">/</span>ttf font<span class="token operator">/</span>otf image<span class="token operator">/</span>svg<span class="token operator">+</span>xml<span class="token punctuation">;</span>
    <span class="token keyword">gzip_vary</span> on<span class="token punctuation">;</span>
    <span class="token keyword">gzip_proxied</span>       any<span class="token punctuation">;</span>
    <span class="token keyword">gzip_disable</span> <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span>

    <span class="token keyword">fastcgi_intercept_errors</span> on<span class="token punctuation">;</span>

    <span class="token keyword">include</span> <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token punctuation">.</span>d<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>conf<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>blog.wangriyu.wang.conf</li></ul><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>
     <span class="token keyword">server_name</span>  blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"># Load configuration files for the default server block.</span>
     <span class="token keyword">include</span> <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>default<span class="token punctuation">.</span>d<span class="token operator">/</span><span class="token operator">*</span><span class="token punctuation">.</span>conf<span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"># 开启 tls 和 http2</span>
     <span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">443</span> <span class="token keyword">ssl</span> http2 ipv6only<span class="token operator">=</span>on<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
     <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
     <span class="token keyword">ssl_certificate</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>fullchain<span class="token punctuation">.</span>pem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
     <span class="token keyword">ssl_certificate_key</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>privkey<span class="token punctuation">.</span>pem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
     <span class="token keyword">include</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>options<span class="token operator">-</span><span class="token keyword">ssl</span><span class="token operator">-</span>nginx<span class="token punctuation">.</span>conf<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
     <span class="token keyword">ssl_dhparam</span> <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>letsencrypt<span class="token operator">/</span><span class="token keyword">ssl</span><span class="token operator">-</span>dhparams<span class="token punctuation">.</span>pem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>

     <span class="token comment" spellcheck="true"># 优化 OCSP 查询</span>
     ssl_stapling on<span class="token punctuation">;</span>
     ssl_stapling_verify on<span class="token punctuation">;</span>
     ssl_trusted_certificate <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>wangriyu<span class="token punctuation">.</span>wang<span class="token operator">/</span>chain<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>

     <span class="token keyword">resolver</span>                 <span class="token number">8.8</span><span class="token punctuation">.</span><span class="token number">4.4</span> <span class="token number">8.8</span><span class="token punctuation">.</span><span class="token number">8.8</span>  valid<span class="token operator">=</span>300s<span class="token punctuation">;</span>
     <span class="token keyword">resolver_timeout</span>         10s<span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"># HSTS 策略</span>
     <span class="token keyword">add_header</span> Strict<span class="token operator">-</span>Transport<span class="token operator">-</span>Security <span class="token string">"max-age=63072000; includeSubdomains"</span> always<span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"># 静态文件目录</span>
     <span class="token keyword">root</span> <span class="token operator">/</span>www<span class="token operator">/</span>website<span class="token punctuation">;</span>
     <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"># 设置 http2 的 ServerPush 文件，需要 nginx/1.13.9 以上才支持此功能</span>
     <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span><span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token punctuation">{</span>
       http2_push <span class="token operator">/</span>css<span class="token operator">/</span>style<span class="token punctuation">.</span>css<span class="token punctuation">;</span>
       http2_push <span class="token operator">/</span>js<span class="token operator">/</span>main<span class="token punctuation">.</span>js<span class="token punctuation">;</span>
       http2_push <span class="token operator">/</span>img<span class="token operator">/</span>yule<span class="token punctuation">.</span>jpg<span class="token punctuation">;</span>
       http2_push <span class="token operator">/</span>img<span class="token operator">/</span>avatar<span class="token punctuation">.</span>jpg<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token comment" spellcheck="true"># 设置静态文件缓存时间</span>
     <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>ico<span class="token operator">|</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token operator">|</span>png<span class="token operator">|</span>moc<span class="token operator">|</span>mtn<span class="token operator">|</span>mp3<span class="token operator">|</span><span class="token keyword">mp4</span><span class="token operator">|</span>mov<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
       <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
       etag         on<span class="token punctuation">;</span>
       <span class="token keyword">expires</span>      30d<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>css<span class="token operator">|</span>js<span class="token operator">|</span>txt<span class="token operator">|</span>xml<span class="token operator">|</span>swf<span class="token operator">|</span>wav<span class="token operator">|</span>json<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
       <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
       etag         on<span class="token punctuation">;</span>
       <span class="token keyword">expires</span>      5d<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>html<span class="token operator">|</span>htm<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
       etag         on<span class="token punctuation">;</span>
       <span class="token keyword">expires</span>      24h<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>eot<span class="token operator">|</span>ttf<span class="token operator">|</span>otf<span class="token operator">|</span>woff<span class="token operator">|</span>svg<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
       <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
       etag         on<span class="token punctuation">;</span>
       <span class="token keyword">expires</span>      30d<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token comment" spellcheck="true"># 设置 404 错误页</span>
     <span class="token keyword">error_page</span> <span class="token number">404</span> <span class="token number">403</span> <span class="token operator">/</span><span class="token number">404</span><span class="token punctuation">.</span>html<span class="token punctuation">;</span>
     <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span><span class="token number">404</span><span class="token punctuation">.</span>html <span class="token punctuation">{</span>
       <span class="token keyword">root</span> <span class="token operator">/</span>www<span class="token operator">/</span>website<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">error_page</span> <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span> <span class="token operator">/</span>50x<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
       <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span>50x<span class="token punctuation">.</span>html <span class="token punctuation">{</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true"># 重定向非加密连接的访问</span>
<span class="token keyword">server</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$host</span> <span class="token operator">=</span> blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">301</span> <span class="token keyword">https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$host</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>

    <span class="token keyword">listen</span>       <span class="token number">80</span> default_server<span class="token punctuation">;</span>
    <span class="token keyword">listen</span>       <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">80</span> default_server<span class="token punctuation">;</span>
    <span class="token keyword">server_name</span>  blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">404</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># managed by Certbot</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>wangriyu.wang.conf</li></ul><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>
    <span class="token keyword">server_name</span> wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>

    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">301</span> <span class="token keyword">https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token variable">$request_uri</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 nginx 的配置推荐看下屈大大的博客: <a href="https://imququ.com/post/my-nginx-conf-for-wpo.html" target="_blank" rel="noopener">Nginx 配置之性能篇</a> 和 <a href="https://imququ.com/post/my-nginx-conf-for-security.html" target="_blank" rel="noopener">Nginx 配置之安全篇</a></p><p>通过优化 SEO 分数比 githubpage 要高得多</p><p><img src="https://src.wangriyu.wang/images/blog/server/blog.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/server/home.png" alt="image"></p><p>nginx 访问的目录要存放博客生成的静态文件，接下来会介绍如何使用 git 部署</p><h2 id="搭建-Git-服务"><a href="#搭建-Git-服务" class="headerlink" title="搭建 Git 服务"></a>搭建 Git 服务</h2><p>之前博客是托管在 github 上的，我是在本地编辑完后再 push 到远端。现在放到服务器上，若用 git 部署，需要在服务器上搭建 Git 服务。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建一个 git 专用的用户</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">useradd</span> -m <span class="token function">git</span>
$ <span class="token function">passwd</span> <span class="token function">git</span> <span class="token comment" spellcheck="true"># 设置密码，之后部署时登录用</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>禁用 git 用户的 shell 登录权限</p><p>出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd 来实现，在 /etc/passwd 中找到类似下面的一行：</p><pre class="line-numbers language-vim"><code class="language-vim">git<span class="token punctuation">:</span><span class="token keyword">x</span><span class="token punctuation">:</span><span class="token number">1001</span><span class="token punctuation">:</span><span class="token number">1001</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">/</span>home<span class="token operator">/</span>git<span class="token punctuation">:</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>bash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 bash 改为 git-shell，可以通过 <code>which git-shell</code> 获取</p><pre class="line-numbers language-vim"><code class="language-vim">git<span class="token punctuation">:</span><span class="token keyword">x</span><span class="token punctuation">:</span><span class="token number">1001</span><span class="token punctuation">:</span><span class="token number">1001</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">/</span>home<span class="token operator">/</span>git<span class="token punctuation">:</span><span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>git<span class="token operator">-</span><span class="token keyword">shell</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>新建一个 git 仓库地址比如 <code>/data/git-repo</code>。然后在这个文件夹里创建 blog.git 这个仓库。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> /data/git-repo
$ <span class="token function">cd</span> /data/git-repo
$ <span class="token function">git</span> init --bare blog.git
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后进入 blog.git 可以看到 hooks 文件夹，可以再这里面写 Git Hook 脚本，不了解钩子的可以看下 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Git 钩子</a></p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> blog.git/hooks
$ <span class="token function">vi</span> post-update

写入:

<span class="token comment" spellcheck="true">#!/bin/sh</span>
<span class="token function">git</span> --work-tree<span class="token operator">=</span>/www/website --git-dir<span class="token operator">=</span>/data/git-repo/blog.git checkout -f
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>worktree 就是我们要放置静态文件的目录，每次这个裸库收到 git 更新时会把文件更新到 worktree，这样 nginx 就可以访问新部署的文件了</p><p>如果 post-update 不是可执行权限，输入 <code>chmod +x post-update</code> 设置为可执行</p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>这里要注意的一点是除了要设置仓库的所有者和可读写权限外，还要设置工作目录，即静态文件存放的地方，要不然钩子函数可能更新不了工作目录</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">chown</span> -R git:git /data/git-repo/blog.git
$ <span class="token function">chmod</span> 755 /data/git-repo/blog.git

$ <span class="token function">chown</span> -R git:git /www/website
$ <span class="token function">chmod</span> 755 /www/website
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到本地使用 git 克隆服务器上的仓库测试一下是否可用:</p><pre class="line-numbers language-git"><code class="language-git"><span class="token command">$ git clone git@&lt;CVM IP>:/data/git-repo/blog.git</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此服务器的配置应该已经结束</p><h2 id="测试本地编辑部署"><a href="#测试本地编辑部署" class="headerlink" title="测试本地编辑部署"></a>测试本地编辑部署</h2><p>到 hexo 博客目录，编辑站点配置文件 <code>_config.yml</code> 的 deploy 选项</p><pre class="line-numbers language-stylus"><code class="language-stylus">deploy<span class="token punctuation">:</span>
  - type<span class="token punctuation">:</span> git
    repo<span class="token punctuation">:</span>
      <span class="token property-declaration"><span class="token property">github</span><span class="token punctuation">:</span> git@github<span class="token operator">.</span>com<span class="token punctuation">:</span>wangriyu<span class="token operator">/</span>wangriyu<span class="token operator">.</span>github<span class="token operator">.</span>io<span class="token operator">.</span>git</span>
      <span class="token property-declaration"><span class="token property">server</span><span class="token punctuation">:</span> git@<span class="token operator">&lt;</span>CVM IP<span class="token operator">></span><span class="token punctuation">:</span><span class="token operator">/</span>data<span class="token operator">/</span>git-repo<span class="token operator">/</span>blog<span class="token operator">.</span>git</span>
    <span class="token property-declaration"><span class="token property">branch</span><span class="token punctuation">:</span> master</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后同样使用 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 命令，然后输入 git 用户的密码就可部署到服务器上了</p><p>如果不想每次都输密码可以去创建一个密钥放到本地，这里就不叙述了</p><h2 id="升级-vim"><a href="#升级-vim" class="headerlink" title="升级 vim"></a>升级 vim</h2><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> /etc/yum.repos.d/
$ <span class="token function">wget</span> https://copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo
$ rpm --import https://copr-be.cloud.fedoraproject.org/results/mcepl/vim8/pubkey.gpg
$ yum update vim
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 update vim 报错:</p><pre class="line-numbers language-stylus"><code class="language-stylus">Transaction check error<span class="token punctuation">:</span>
  <span class="token property-declaration"><span class="token property">file</span> <span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>man<span class="token operator">/</span>man1<span class="token operator">/</span>vim<span class="token operator">.</span><span class="token number">1</span><span class="token operator">.</span>gz from install of vim-common-<span class="token number">2</span><span class="token punctuation">:</span><span class="token number">8.0</span><span class="token operator">.</span><span class="token number">1735</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token operator">.</span><span class="token number">96</span><span class="token operator">.</span>el7<span class="token operator">.</span>centos<span class="token operator">.</span>x86_64 conflicts with file from package vim-minimal-<span class="token number">2</span><span class="token punctuation">:</span><span class="token number">7.4</span><span class="token operator">.</span><span class="token number">160</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64</span>

<span class="token property-declaration"><span class="token property">Error</span> Summary</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先执行一下 <code>yum erase vim-minimal</code> 再 <code>yum update vim</code></p><p>如果升级后发现只能用 <code>vim</code> 命令不能用 <code>vi</code>，设置如下</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /usr/bin <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">vi</span>
$ <span class="token function">cp</span> /usr/bin/vim /usr/bin/vi
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>推荐安装 oh-my-zsh，配合 <a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a> 插件和合适的主题，可以大大改善 shell 使用体验</p><p>接下来会写几篇折腾服务器的博客，比如搭建 FTP、nextcloud、docker 等等</p>]]></content>
    
    <summary type="html">
    
      把博客从 github 搬到自己的服务器上，如何搭建 git 服务并用 git 部署
    
    </summary>
    
      <category term="Server" scheme="https://blog.wangriyu.wang/categories/Server/"/>
    
    
      <category term="hexo" scheme="https://blog.wangriyu.wang/tags/hexo/"/>
    
      <category term="git" scheme="https://blog.wangriyu.wang/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Golang http/server</title>
    <link href="https://blog.wangriyu.wang/2018/04-go-http.html"/>
    <id>https://blog.wangriyu.wang/2018/04-go-http.html</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p><img src="https://src.wangriyu.wang/images/blog/go/server.png" alt="image"></p><h3 id="server-与-conn-等接口"><a href="#server-与-conn-等接口" class="headerlink" title="server 与 conn 等接口"></a>server 与 conn 等接口</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Server <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Addr              <span class="token builtin">string</span>        <span class="token comment" spellcheck="true">// 要监听的 TCP 地址</span>
    Handler           Handler       <span class="token comment" spellcheck="true">// 调用的 handler, 如果为空则用 http.DefaultServeMux</span>
    TLSConfig         <span class="token operator">*</span>tls<span class="token punctuation">.</span>Config   <span class="token comment" spellcheck="true">// 用于 ServeTLS 和 ListenAndServeTLS</span>
    ReadTimeout       time<span class="token punctuation">.</span>Duration <span class="token comment" spellcheck="true">// 读取完整 request (包括 body) 的最大时长，可以和 ReadHeaderTimeout 同时使用</span>
    ReadHeaderTimeout time<span class="token punctuation">.</span>Duration <span class="token comment" spellcheck="true">// 读取 request headers 的最大时长</span>
    WriteTimeout      time<span class="token punctuation">.</span>Duration <span class="token comment" spellcheck="true">// 写 response 的最大时长</span>
    IdleTimeout       time<span class="token punctuation">.</span>Duration <span class="token comment" spellcheck="true">// 当 keepalive 开启时等待下个 request 的最大时长，此值为空时使用 ReadTimeout 值代替，ReadTimeout 也为空使用 ReadHeaderTimeout 代替</span>
    MaxHeaderBytes    <span class="token builtin">int</span>           <span class="token comment" spellcheck="true">// 解析 request headers 里键值对的最大字节数 (包含请求行)，不限制 body. 如果为 0, 使用 DefaultMaxHeaderBytes 代替</span>
    TLSNextProto      <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当 '应用层协议协商 (NPN/ALPN)' 时发生协议升级时，TLSNextProto 需要指定可选的 function 去接管 TLS 连接</span>
    ConnState         <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 指定一个可选的钩子函数，由 client 连接状态改变触发</span>
    ErrorLog          <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger   <span class="token comment" spellcheck="true">// 指定一个可选的 logger 接收错误日志. 如果为空则由 log 包接管</span>
    disableKeepAlives <span class="token builtin">int32</span>         <span class="token comment" spellcheck="true">// 在 SetKeepAlivesEnabled 中设置，为 1 表示取消长连接，为 0 保持长连接 (默认)</span>
    inShutdown        <span class="token builtin">int32</span>         <span class="token comment" spellcheck="true">// 非零代表 in Shutdown</span>
    nextProtoOnce     sync<span class="token punctuation">.</span>Once     <span class="token comment" spellcheck="true">// 设置 HTTP/2</span>
    nextProtoErr      <span class="token builtin">error</span>         <span class="token comment" spellcheck="true">// http2.ConfigureServer 的结果</span>
    mu                sync<span class="token punctuation">.</span>Mutex
    listeners         <span class="token keyword">map</span><span class="token punctuation">[</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    activeConn        <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>conn<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    doneChan          <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// doneChan 代表任务结束</span>
    onShutdown        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 通过 RegisterOnShutdown 注册，在 Shutdown 时调用当中的钩子函数</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 此接口由 ResponseWriters 执行去检测连接是否已断开，此机制允许客户端断开后服务端取消一个长连接</span>
<span class="token keyword">type</span> CloseNotifier <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">CloseNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">bool</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// conn 代表服务端的 HTTP 连接</span>
<span class="token keyword">type</span> conn <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    server     <span class="token operator">*</span>Server
    cancelCtx  context<span class="token punctuation">.</span>CancelFunc   <span class="token comment" spellcheck="true">// 撤销连接层的 context，读写出错时会调用</span>
    rwc        net<span class="token punctuation">.</span>Conn             <span class="token comment" spellcheck="true">//</span>
    remoteAddr <span class="token builtin">string</span>               <span class="token comment" spellcheck="true">// rwc.RemoteAddr().String()</span>
    tlsState   <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionState <span class="token comment" spellcheck="true">// TLS 连接状态，nil 代表非 TSL</span>
    werr       <span class="token builtin">error</span>                <span class="token comment" spellcheck="true">// rwc 写入时的首个错误 (bufw 写入时)</span>
    r          <span class="token operator">*</span>connReader          <span class="token comment" spellcheck="true">// 一个 *conn 使用的 io.reader 封装，存有 bufr 的读取内容</span>
    bufr       <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader        <span class="token comment" spellcheck="true">// 从 r 读取</span>
    bufw       <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Writer        <span class="token comment" spellcheck="true">// 要写入 checkConnErrorWriter{c} 的缓冲</span>
    lastMethod <span class="token builtin">string</span>
    curReq     atomic<span class="token punctuation">.</span>Value <span class="token comment" spellcheck="true">// 存入 *response (response 中包含 request)</span>
    curState   atomic<span class="token punctuation">.</span>Value <span class="token comment" spellcheck="true">// 存入 ConnState</span>
    mu         sync<span class="token punctuation">.</span>Mutex   <span class="token comment" spellcheck="true">// 保护 hijackedv</span>
    hijackedv  <span class="token builtin">bool</span>         <span class="token comment" spellcheck="true">// 代表连接是否已经被 hijacke</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 一个 ctx 带有一个截止期限，一个取消信号，或者其他绑定值</span>
<span class="token comment" spellcheck="true">// 其函数可以被多个 goroutines 同时使用</span>
<span class="token comment" spellcheck="true">// 一个请求过来时可能会涉及到多个 goroutines，Ctx 可以控制关闭与之相关联和派生出的子 ctx 相关联的 goroutines</span>
<span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Deadline 方法是获取设置的截止时间，第一个返回值是截止时间，到了这个时间点，Context 会自动发起取消请求；</span>
    <span class="token comment" spellcheck="true">// 第二个返回值 ok==false 时表示没有设置截止时间，如果需要取消的话，需要调用 cancel 函数进行取消，取消操作包括派生出去的子 Ctx</span>
    <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 在 goroutine 中，如果该方法返回的 chan 可以读取，则意味着 parent context 已经发起了取消请求，</span>
    <span class="token comment" spellcheck="true">// 我们通过 Done 方法收到这个信号后，就应该做清理操作，然后退出 goroutine，释放资源</span>
    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 如果 Done 还没关闭，Err 返回 nil</span>
    <span class="token comment" spellcheck="true">// 如果 Done 已经关闭，返回非空 err，告知 Ctx 因何取消</span>
    <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 键值对形式，与 Ctx 绑定，可以为空</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Serve 接收 listener 上过来的连接，并为每个连接创建 service 线程</span>
<span class="token comment" spellcheck="true">// 在 service 线程中会读取 request 并调用 srv.Handler 进行服务</span>
<span class="token comment" spellcheck="true">// handler 参数一般传 nil 就行，代表使用的是 DefaultServeMux</span>
<span class="token keyword">func</span> <span class="token function">Serve</span><span class="token punctuation">(</span>l net<span class="token punctuation">.</span>Listener<span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// HTTPS: ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error</span>
    srv <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>
    <span class="token keyword">return</span> srv<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// HTTPS: srv.ServeTLS(l, certFile, keyFile)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// func HelloServer(w http.ResponseWriter, req *http.Request) {</span>
<span class="token comment" spellcheck="true">//     io.WriteString(w, "hello, world!\n")</span>
<span class="token comment" spellcheck="true">// }</span>
<span class="token comment" spellcheck="true">//</span>
<span class="token comment" spellcheck="true">// func main() {</span>
<span class="token comment" spellcheck="true">//     http.HandleFunc("/hello", HelloServer)</span>
<span class="token comment" spellcheck="true">//     log.Fatal(http.ListenAndServe(":12345", nil))</span>
<span class="token comment" spellcheck="true">// }</span>
<span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>
    <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)</span>
<span class="token comment" spellcheck="true">// HTTPS 方式，可以使用 crypto/tls 中的 generate_cert.go 生成 cert.pem 和 key.pem</span>
<span class="token keyword">func</span> <span class="token function">ListenAndServeTLS</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> certFile<span class="token punctuation">,</span> keyFile <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>
    <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServeTLS</span><span class="token punctuation">(</span>certFile<span class="token punctuation">,</span> keyFile<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// ListenAndServe 监听 srv.Addr 地址上的 tcp 网络，然后调用 Serve 服务连接，连接会设置 keep-alives</span>
<span class="token comment" spellcheck="true">// 如果 srv.Addr 为空则用 ":http" 代替</span>
<span class="token comment" spellcheck="true">// ListenAndServe 总是返回非空 err</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    addr <span class="token operator">:=</span> srv<span class="token punctuation">.</span>Addr
    <span class="token keyword">if</span> addr <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>
        addr <span class="token operator">=</span> <span class="token string">":http"</span>
    <span class="token punctuation">}</span>
    ln<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// HTTP:</span>
    <span class="token keyword">return</span> srv<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>tcpKeepAliveListener<span class="token punctuation">{</span>ln<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>net<span class="token punctuation">.</span>TCPListener<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// HTTPS 方式调用 ListenAndServeTLS(certFile, keyFile string) error</span>
    <span class="token comment" spellcheck="true">// 与 ListenAndServe 类似，只是最后要关闭 ln 并返回 srv.ServeTLS</span>
    <span class="token comment" spellcheck="true">// defer ln.Close()</span>
    <span class="token comment" spellcheck="true">// return srv.ServeTLS(tcpKeepAliveListener{ln.(*net.TCPListener)}, certFile, keyFile)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="server-的服务函数"><a href="#server-的服务函数" class="headerlink" title="server 的服务函数"></a>server 的服务函数</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ServeTLS</span><span class="token punctuation">(</span>l net<span class="token punctuation">.</span>Listener<span class="token punctuation">,</span> certFile<span class="token punctuation">,</span> keyFile <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 在 srv.Serve 之前尝试设置 HTTP/2</span>
    <span class="token comment" spellcheck="true">// setupHTTP2_ServeTLS 中调用 onceSetNextProtoDefaults_Serve，只有 srv.TLSNextProto 为 nil 时才可以设置 HTTP/2</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">setupHTTP2_ServeTLS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>

    config <span class="token operator">:=</span> <span class="token function">cloneTLSConfig</span><span class="token punctuation">(</span>srv<span class="token punctuation">.</span>TLSConfig<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">strSliceContains</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>NextProtos<span class="token punctuation">,</span> <span class="token string">"http/1.1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// strSliceContains 判断是否包含字符串</span>
        config<span class="token punctuation">.</span>NextProtos <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>NextProtos<span class="token punctuation">,</span> <span class="token string">"http/1.1"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    configHasCert <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>Certificates<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> config<span class="token punctuation">.</span>GetCertificate <span class="token operator">!=</span> <span class="token boolean">nil</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>configHasCert <span class="token operator">||</span> certFile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token operator">||</span> keyFile <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> err <span class="token builtin">error</span>
        config<span class="token punctuation">.</span>Certificates <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>tls<span class="token punctuation">.</span>Certificate<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        config<span class="token punctuation">.</span>Certificates<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> err <span class="token operator">=</span> tls<span class="token punctuation">.</span><span class="token function">LoadX509KeyPair</span><span class="token punctuation">(</span>certFile<span class="token punctuation">,</span> keyFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// LoadX509KeyPair 解析证书，文件中必须含有 PEM 编码数据</span>
        <span class="token comment" spellcheck="true">// PEM (Privacy Enhancement Message)，定义见 RFC1421，是一种基于 base64 的编码格式</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> err
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    tlsListener <span class="token operator">:=</span> tls<span class="token punctuation">.</span><span class="token function">NewListener</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> config<span class="token punctuation">)</span>
    <span class="token keyword">return</span> srv<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>tlsListener<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 若启用 HTTP/2，在调用 Serve 前需要根据 listener's TLS Config 初始化 srv.TLSConfig</span>
<span class="token comment" spellcheck="true">// Serve 总是返回非空的 err，在 Shutdown 或 Close 后返回 ErrServerClosed</span>
<span class="token comment" spellcheck="true">// Close 是立即关闭 Server 和与之相关的 listeners 和 connections，而 shutdown 是逐步关闭 listeners 和闲置的 connections，两者不会管已被 hijack 的连接</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span>l net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    <span class="token keyword">defer</span> l<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> fn <span class="token operator">:=</span> testHookServerServe<span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果钩子函数 testHookServerServe 非空则调用</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>srv<span class="token punctuation">,</span> l<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> tempDelay time<span class="token punctuation">.</span>Duration <span class="token comment" spellcheck="true">// accept 失败时 sleep 多长时间</span>

    <span class="token comment" spellcheck="true">// setupHTTP2_Serve 和 setupHTTP2_ServeTLS 两者都是调用 onceSetNextProtoDefaults() 去尝试设置 HTTP/2</span>
    <span class="token comment" spellcheck="true">// 只是考虑到多并发情况下的 Serve 请求，setupHTTP2_Serve 采用了更保守的政策去设置 HTTP/2</span>
    <span class="token comment" spellcheck="true">// setupHTTP2_Serve 先调用 shouldConfigureHTTP2ForServe 判断是否应该为 Server.Serve 设置 HTTP/2</span>
    <span class="token comment" spellcheck="true">// shouldConfigureHTTP2ForServe 中如果 srv.TLSConfig 为 nil 或者 srv.TLSConfig.NextProtos 包含 "h2" 字样返回真，否则返回假，</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">setupHTTP2_Serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>

    srv<span class="token punctuation">.</span><span class="token function">trackListener</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将 l 添加进 server.listeners</span>
    <span class="token keyword">defer</span> srv<span class="token punctuation">.</span><span class="token function">trackListener</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 结束后删去 l</span>

    baseCtx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// baseContext 会一直存在，但没有值也没有 deadline，用于主函数或者初始化或者测试或者顶层接收请求的 context</span>
    ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>baseCtx<span class="token punctuation">,</span> ServerContextKey<span class="token punctuation">,</span> srv<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// WithValue 返回 baseCtx 的副本，副本内的值是一个键值对 ServerContextKey - srv</span>
    <span class="token comment" spellcheck="true">// ServerContextKey = &amp;contextKey{"http-server"} 与其绑定的 value 类型为 *Server</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        rw<span class="token punctuation">,</span> e <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 接收到连接</span>
        <span class="token keyword">if</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">select</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>srv<span class="token punctuation">.</span><span class="token function">getDoneChan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// server 已关闭</span>
                <span class="token keyword">return</span> ErrServerClosed
            <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> ne<span class="token punctuation">,</span> ok <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> ne<span class="token punctuation">.</span><span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> tempDelay <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
                    tempDelay <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    tempDelay <span class="token operator">*=</span> <span class="token number">2</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> max <span class="token operator">:=</span> <span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">;</span> tempDelay <span class="token operator">></span> max <span class="token punctuation">{</span>
                    tempDelay <span class="token operator">=</span> max
                <span class="token punctuation">}</span>
                srv<span class="token punctuation">.</span><span class="token function">logf</span><span class="token punctuation">(</span><span class="token string">"http: Accept error: %v; retrying in %v"</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> tempDelay<span class="token punctuation">)</span>
                time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>tempDelay<span class="token punctuation">)</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> e
        <span class="token punctuation">}</span>
        tempDelay <span class="token operator">=</span> <span class="token number">0</span>
        c <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// conn.setState 根据传入的状态调用 trackConn 来设置 server.activeConn 集合，再改变当前 conn.curState</span>
        <span class="token comment" spellcheck="true">// 如果 server 设置了 ConnState 这个钩子函数，就调用</span>
        c<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> StateNew<span class="token punctuation">)</span>
        <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="server-Serve-最后调用-conn-serve"><a href="#server-Serve-最后调用-conn-serve" class="headerlink" title="server.Serve 最后调用 conn.serve"></a>server.Serve 最后调用 conn.serve</h3><p>在此函数中调用 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 转入路由模块</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">.</span>remoteAddr <span class="token operator">=</span> c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">RemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ctx <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> LocalAddrContextKey<span class="token punctuation">,</span> c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">LocalAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// LocalAddrContextKey = &amp;contextKey{"local-addr"} 与其绑定的 value 类型是 net.Addr</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> ErrAbortHandler <span class="token punctuation">{</span>
            <span class="token keyword">const</span> size <span class="token operator">=</span> <span class="token number">64</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span> <span class="token comment" spellcheck="true">// 64 KB</span>
            buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
            buf <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span>runtime<span class="token punctuation">.</span><span class="token function">Stack</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            c<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">logf</span><span class="token punctuation">(</span><span class="token string">"http: panic serving %v: %v\n%s"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>remoteAddr<span class="token punctuation">,</span> err<span class="token punctuation">,</span> buf<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">hijacked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 已经被 hijack 的连接不用管理，由 hijack 的调用者处理</span>
            c<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            c<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> StateClosed<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> tlsConn<span class="token punctuation">,</span> ok <span class="token operator">:=</span> c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// HTTPS</span>
        <span class="token keyword">if</span> d <span class="token operator">:=</span> c<span class="token punctuation">.</span>server<span class="token punctuation">.</span>ReadTimeout<span class="token punctuation">;</span> d <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> d <span class="token operator">:=</span> c<span class="token punctuation">.</span>server<span class="token punctuation">.</span>WriteTimeout<span class="token punctuation">;</span> d <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">SetWriteDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> err <span class="token operator">:=</span> tlsConn<span class="token punctuation">.</span><span class="token function">Handshake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">logf</span><span class="token punctuation">(</span><span class="token string">"http: TLS handshake error from %s: %v"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">RemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        c<span class="token punctuation">.</span>tlsState <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>tls<span class="token punctuation">.</span>ConnectionState<span class="token punctuation">)</span>
        <span class="token operator">*</span>c<span class="token punctuation">.</span>tlsState <span class="token operator">=</span> tlsConn<span class="token punctuation">.</span><span class="token function">ConnectionState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取当前 TLS 连接的详细信息</span>
        <span class="token comment" spellcheck="true">// NegotiatedProtocol 协商的协议，validNPN 判断 proto 是否属于 "", "http/1.1", "http/1.0" 之一，不属于返回真</span>
        <span class="token keyword">if</span> proto <span class="token operator">:=</span> c<span class="token punctuation">.</span>tlsState<span class="token punctuation">.</span>NegotiatedProtocol<span class="token punctuation">;</span> <span class="token function">validNPN</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> fn <span class="token operator">:=</span> c<span class="token punctuation">.</span>server<span class="token punctuation">.</span>TLSNextProto<span class="token punctuation">[</span>proto<span class="token punctuation">]</span><span class="token punctuation">;</span> fn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                h <span class="token operator">:=</span> initNPNRequest<span class="token punctuation">{</span>tlsConn<span class="token punctuation">,</span> serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">}</span>
                <span class="token function">fn</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>server<span class="token punctuation">,</span> tlsConn<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 发生协议切换时触发钩子函数</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// HTTP/1.x following</span>

    ctx<span class="token punctuation">,</span> cancelCtx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// WithCancel 返回 &amp;c, func() { c.cancel(true, Canceled) }</span>
    <span class="token comment" spellcheck="true">// ctx.cancel close ctx.done 取消所有 ctx 的 children，如果第一个参数为 true，则把 ctx 从其 parent 的 children 列表删去</span>
    c<span class="token punctuation">.</span>cancelCtx <span class="token operator">=</span> cancelCtx
    <span class="token keyword">defer</span> <span class="token function">cancelCtx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 关闭 ctx，以及相关 goroutines</span>

    c<span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>connReader<span class="token punctuation">{</span>conn<span class="token punctuation">:</span> c<span class="token punctuation">}</span>
    c<span class="token punctuation">.</span>bufr <span class="token operator">=</span> <span class="token function">newBufioReader</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>r<span class="token punctuation">)</span>
    c<span class="token punctuation">.</span>bufw <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span>checkConnErrorWriter<span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 读取 request 返回 response 和可能的 err</span>
        <span class="token keyword">if</span> c<span class="token punctuation">.</span>r<span class="token punctuation">.</span>remain <span class="token operator">!=</span> c<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">initialReadLimitSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// remain 代表 io.reader 剩余空间，initialReadLimitSize 返回 int64(srv.MaxHeaderBytes > 0 ? srv.MaxHeaderBytes : DefaultMaxHeaderBytes) + 4096</span>
            c<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> StateActive<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// StateActive 代表连接已经从 request 读到数据</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> errorHeaders <span class="token operator">=</span> <span class="token string">"\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</span>

            <span class="token keyword">if</span> err <span class="token operator">==</span> errTooLarge <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// errors.New("http: request too large")</span>
                <span class="token keyword">const</span> publicErr <span class="token operator">=</span> <span class="token string">"431 Request Header Fields Too Large"</span>
                fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> <span class="token string">"HTTP/1.1 "</span><span class="token operator">+</span>publicErr<span class="token operator">+</span>errorHeaders<span class="token operator">+</span>publicErr<span class="token punctuation">)</span>
                c<span class="token punctuation">.</span><span class="token function">closeWriteAndWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">// closewrite flush 所有缓存的数据并发送一个 FIN 包（如果客户端是通过 TCP 连接的），表示我们这边已结束，然后 sleep 500 ms</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token function">isCommonNetReadError</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// err 是否是 io.EOF 或者是网络超时 (net.Error) 或者是读 request 的 net.OpError 之一</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>

            publicErr <span class="token operator">:=</span> <span class="token string">"400 Bad Request"</span>
            <span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span>badRequestError<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
                publicErr <span class="token operator">=</span> publicErr <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> <span class="token string">"HTTP/1.1 "</span><span class="token operator">+</span>publicErr<span class="token operator">+</span>errorHeaders<span class="token operator">+</span>publicErr<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// request Header : Expect 100 Continue</span>
        req <span class="token operator">:=</span> w<span class="token punctuation">.</span>req
        <span class="token keyword">if</span> req<span class="token punctuation">.</span><span class="token function">expectsContinue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> req<span class="token punctuation">.</span><span class="token function">ProtoAtLeast</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> req<span class="token punctuation">.</span>ContentLength <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// after first '100 Continue' request, wrapper response with 'HTTP/1.1 100 Continue'</span>
                req<span class="token punctuation">.</span>Body <span class="token operator">=</span> <span class="token operator">&amp;</span>expectContinueReader<span class="token punctuation">{</span>readCloser<span class="token punctuation">:</span> req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span> resp<span class="token punctuation">:</span> w<span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Expect"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">sendExpectationFailed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// response with status code 417 (Expectation Failed)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>

        c<span class="token punctuation">.</span>curReq<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token function">requestBodyRemains</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>Body<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 之后是否还能从 body 读取到数据，true 表示能继续读 (未到 io.EOF)</span>
            <span class="token function">registerOnHitEOF</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span> w<span class="token punctuation">.</span>conn<span class="token punctuation">.</span>r<span class="token punctuation">.</span>startBackgroundRead<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 当 body 读到 EOF，调用传入的 startBackgroundRead 函数</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 长连接下 HTTP 管线化请求时的处理</span>
            <span class="token keyword">if</span> w<span class="token punctuation">.</span>conn<span class="token punctuation">.</span>bufr<span class="token punctuation">.</span><span class="token function">Buffered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// [HTTP pipelining](https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96)</span>
                w<span class="token punctuation">.</span>conn<span class="token punctuation">.</span>r<span class="token punctuation">.</span><span class="token function">closeNotifyFromPipelinedRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// closeNotify()</span>
            <span class="token punctuation">}</span>
            w<span class="token punctuation">.</span>conn<span class="token punctuation">.</span>r<span class="token punctuation">.</span><span class="token function">startBackgroundRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// server.Handler == nil -> DefaultServeMux.ServeHTTP</span>
        w<span class="token punctuation">.</span><span class="token function">cancelCtx</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> c<span class="token punctuation">.</span><span class="token function">hijacked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        w<span class="token punctuation">.</span><span class="token function">finishRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>w<span class="token punctuation">.</span><span class="token function">shouldReuseConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// tcp 连接是否可以继续使用</span>
            <span class="token keyword">if</span> w<span class="token punctuation">.</span>requestBodyLimitHit <span class="token operator">||</span> w<span class="token punctuation">.</span><span class="token function">closedRequestBodyEarly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// requestBodyLimitHit 在 requestTooLarge 函数中设置，当此值为真，停止读取后续的 request 和输入</span>
                <span class="token comment" spellcheck="true">// closedRequestBodyEarly 表示连接之前是否已关闭</span>
                c<span class="token punctuation">.</span><span class="token function">closeWriteAndWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        c<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> StateIdle<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// StateIdle 表示此连接已处理完一个 request 并处于 keep-alive 状态，等待后续 request</span>
        c<span class="token punctuation">.</span>curReq<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token operator">!</span>w<span class="token punctuation">.</span>conn<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">doKeepAlives</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// doKeepAlives 判断是否满足 disableKeepAlives == 0 &amp;&amp; inShutdown == 0 (处于 keep-alive 模式且不在 shutdown 状态)</span>
            <span class="token comment" spellcheck="true">// We're in shutdown mode. We might've replied</span>
            <span class="token comment" spellcheck="true">// to the user without "Connection: close" and</span>
            <span class="token comment" spellcheck="true">// they might think they can send another</span>
            <span class="token comment" spellcheck="true">// request, but such is life with HTTP/1.1.</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> d <span class="token operator">:=</span> c<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">idleTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> d <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>bufr<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// SetReadDeadline 设置后续读去调用的截止时间，如果传入零值表示不会 timeout</span>
        c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">SetReadDeadline</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Time<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>流程：<br>当一个请求 request 进来的时候，server 会依次根据 ServeMux.m 中的 string（路由表达式）来一个一个匹配，<br>如果找到了可以匹配的 muxEntry，就取出 muxEntry.h，这是个 handler，<br>调用 handler 中的 ServeHTTP（ResponseWriter, *Request）来组装 Response，并返回。</p></blockquote><hr><h3 id="路由接口"><a href="#路由接口" class="headerlink" title="路由接口"></a>路由接口</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ResponseWriter 接口用于 HTTP handler 生成 response</span>
<span class="token comment" spellcheck="true">// 在 Handler.ServeHTTP 返回后，ResponseWriter 不应该再被使用</span>
<span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Header             <span class="token comment" spellcheck="true">// Header() 返回 WriteHeader 要发送的 Header map 集合</span>
    <span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Write 写入响应的 body</span>
    <span class="token function">WriteHeader</span><span class="token punctuation">(</span>statusCode <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这个方法发送 Response 的 Header 和传入的 HTTP 状态码</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Flusher 由 ResponseWriters 执行去允许 HTTP handler 将缓存中的数据推给客户端, 默认的 HTTP/1.x 和 HTTP/2 ResponseWriter 支持 Flusher，</span>
<span class="token comment" spellcheck="true">// 但是 ResponseWriter 的封装可能会不支持，Handlers 在运行时需要测试是否支持此函数</span>
<span class="token comment" spellcheck="true">// 即使 ResponseWriters 支持 Flush，如果客户端使用了 HTTP proxy，直到响应结束，缓存的数据也有可能到达不了客户端</span>
<span class="token keyword">type</span> Flusher <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Hijacker 接口由 ResponseWriters 执行去允许 HTTP handler 接管连接</span>
<span class="token comment" spellcheck="true">// 默认的 ResponseWriter 支持 HTTP/1.x 连接下的 Hijacker，但是 HTTP/2 连接不支持，HTTP/2 多路复用等情况不适合使用 Hijack 。</span>
<span class="token comment" spellcheck="true">// ResponseWriter 封装也可能不支持 Hijacker. Handlers 在运行时需要测试是否支持此函数</span>
<span class="token keyword">type</span> Hijacker <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// ServeMux 类型是 HTTP 请求的路由规则转换器。它会将每一个接收的请求的 URL 与一个注册路由的列表进行匹配，并调用和 URL 最匹配的 handler.</span>
<span class="token comment" spellcheck="true">// 匹配到多个时较长的模式优先于较短的模式，模式也可以主机名开始，表示只匹配该主机上的路径，指定主机的模式优先于一般的模式，</span>
<span class="token comment" spellcheck="true">// ServeMux 还会规范化请求的 URL 路径，将任何包含 "." 或 ".." 元素的请求重定向到等价的没有这两种元素的 URL</span>
<span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    mu    sync<span class="token punctuation">.</span>RWMutex <span class="token comment" spellcheck="true">// 读写锁</span>
    m     <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry <span class="token comment" spellcheck="true">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span>
    hosts <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// 是否在任意的规则中带有 host 信息</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    h        Handler <span class="token comment" spellcheck="true">// 这个路由表达式对应哪个 handler</span>
    pattern  <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// 固定的、由根开始的路径，如 "/favicon.ico"，或由根开始的子树，如 "/images/"，也可以主机名开头</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 一个 Handler 响应一个 HTTP 请求</span>
<span class="token comment" spellcheck="true">// ServeHTTP 应该将回复的头域和数据写入 ResponseWriter 接口然后返回。返回标志着该请求已经结束，HTTP 服务端可以转移向该连接上的下一个请求。</span>
<span class="token comment" spellcheck="true">// 在 ServeHTTP 调用结束之后或者并发执行时，使用 ResponseWriter 或者读取请求体是不可取的</span>
<span class="token comment" spellcheck="true">// handler 应该第一时间读取请求体并作出应答，在向 ResponseWriter 写入数据后就不能读取 request body 了. 同时 handler 不应该修改传入的 request</span>
<span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// HandlerFunc(f) 是一个调用 f 的 handler</span>
<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// ServeHTTP calls f(w, r).</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="请求-响应实例"><a href="#请求-响应实例" class="headerlink" title="请求 - 响应实例"></a>请求 - 响应实例</h3><h4 id="这里实现了一个-404-not-found-响应"><a href="#这里实现了一个-404-not-found-响应" class="headerlink" title="这里实现了一个 404 not found 响应"></a>这里实现了一个 <code>404 not found</code> 响应</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NotFound</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"404 page not found"</span><span class="token punctuation">,</span> StatusNotFound<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 定义 handler</span>

<span class="token keyword">func</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Handler <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>NotFound<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="server-导出的注册函数使用-DefaultServeMux-相应方法"><a href="#server-导出的注册函数使用-DefaultServeMux-相应方法" class="headerlink" title="server 导出的注册函数使用 DefaultServeMux 相应方法"></a>server 导出的注册函数使用 DefaultServeMux 相应方法</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span> DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> pattern <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: invalid pattern"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> exist <span class="token operator">:=</span> mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>pattern<span class="token punctuation">]</span><span class="token punctuation">;</span> exist <span class="token punctuation">{</span>
        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: multiple registrations for "</span> <span class="token operator">+</span> pattern<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> mux<span class="token punctuation">.</span>m <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        mux<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>pattern<span class="token punctuation">]</span> <span class="token operator">=</span> muxEntry<span class="token punctuation">{</span>h<span class="token punctuation">:</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> pattern<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 注册成功</span>

    <span class="token keyword">if</span> pattern<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'/'</span> <span class="token punctuation">{</span>
        mux<span class="token punctuation">.</span>hosts <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ServeHTTP-调用-Handler-给-request-分派与-request-URL-最匹配的-handler"><a href="#ServeHTTP-调用-Handler-给-request-分派与-request-URL-最匹配的-handler" class="headerlink" title="ServeHTTP 调用 Handler() 给 request 分派与 request URL 最匹配的 handler"></a>ServeHTTP 调用 Handler() 给 request 分派与 request URL 最匹配的 handler</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> r<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> r<span class="token punctuation">.</span><span class="token function">ProtoAtLeast</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ProtoAtLeast 判断是否大于等于协议最低标准，第一个参数是 major 版本号，第二个参数是 minor 版本号，即 http/1.1</span>
            w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Connection"</span><span class="token punctuation">,</span> <span class="token string">"close"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 小于要求则在响应头返回关闭信息</span>
        <span class="token punctuation">}</span>
        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>StatusBadRequest<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 状态码 400</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    h<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调用对应 handler 的 ServeHTTP，即执行注册好的 handler 函数，比如 NotFound 函数</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Handler 通过判断 r.Method, r.Host, and r.URL.Path 返回与 request 对应的 handler</span>
<span class="token comment" spellcheck="true">// 此函数总会返回非空的 handler. 如果 path 不符合规范形式，返回的是内部生成的重定向到规范路径的 handler</span>
<span class="token comment" spellcheck="true">// 如果 host 包含端口，匹配 handlers 时会忽略端口。第二个参数返回已注册的与请求匹配的路由</span>
<span class="token comment" spellcheck="true">// 如果没有已注册的 handler 与请求匹配, 则返回 ``page not found'' handler 和空的 pattern</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"CONNECT"</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// redirectToPathSlash 判断 path 是否需要追加 "/"，因为存在 "path + /" 已注册但 "path"</span>
        <span class="token comment" spellcheck="true">// 本身未注册的情况。如果需要追加 "/"，则返回追加的 url 和 true</span>
        <span class="token keyword">if</span> u<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">redirectToPathSlash</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">RedirectHandler</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StatusMovedPermanently<span class="token punctuation">)</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Path
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> mux<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    host <span class="token operator">:=</span> <span class="token function">stripHostPort</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 去掉 ":&lt;port>"</span>
    path <span class="token operator">:=</span> <span class="token function">cleanPath</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 规范 path 格式，比如缺失多余 '/'、存在相对路径'.'、'..' 等</span>

    <span class="token keyword">if</span> u<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">redirectToPathSlash</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">RedirectHandler</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StatusMovedPermanently<span class="token punctuation">)</span><span class="token punctuation">,</span> u<span class="token punctuation">.</span>Path
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 修改 request 的不规范路径</span>
    <span class="token keyword">if</span> path <span class="token operator">!=</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token punctuation">{</span>
        <span class="token boolean">_</span><span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
        url <span class="token operator">:=</span> <span class="token operator">*</span>r<span class="token punctuation">.</span>URL
        url<span class="token punctuation">.</span>Path <span class="token operator">=</span> path
        <span class="token keyword">return</span> <span class="token function">RedirectHandler</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StatusMovedPermanently<span class="token punctuation">)</span><span class="token punctuation">,</span> pattern
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> mux<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 在 ServerMux.handler 中当匹配不到注册的路由时返回 NotFoundHandler</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> mux<span class="token punctuation">.</span>hosts <span class="token punctuation">{</span>
        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>host <span class="token operator">+</span> path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// match 根据完整 URL 优先匹配 handler</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果 URL 匹配不到再根据路径匹配</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener">Package http</a></li><li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/" target="_blank" rel="noopener">Go Web 编程</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">wiki NPN/ALPN</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">wiki TLS</a></li></ul>]]></content>
    
    <summary type="html">
    
      go http/server 源码解读
    
    </summary>
    
      <category term="go" scheme="https://blog.wangriyu.wang/categories/go/"/>
    
    
      <category term="go 源码" scheme="https://blog.wangriyu.wang/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Golang RPC</title>
    <link href="https://blog.wangriyu.wang/2018/04-go-rpc.html"/>
    <id>https://blog.wangriyu.wang/2018/04-go-rpc.html</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2018-06-17T13:05:39.875Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://src.wangriyu.wang/images/blog/go/rpc.svg" alt="image"></p><h2 id="1-server"><a href="#1-server" class="headerlink" title="1. server"></a>1. server</h2><h3 id="service-与-server-结构体"><a href="#service-与-server-结构体" class="headerlink" title="service 与 server 结构体"></a>service 与 server 结构体</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> service <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name   <span class="token builtin">string</span>                 <span class="token comment" spellcheck="true">// 服务名</span>
    rcvr   reflect<span class="token punctuation">.</span>Value          <span class="token comment" spellcheck="true">// 服务中函数的接收者</span>
    typ    reflect<span class="token punctuation">.</span>Type           <span class="token comment" spellcheck="true">// 接收者类型</span>
    method <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>methodType <span class="token comment" spellcheck="true">// 已注册的函数集</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Server <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    serviceMap sync<span class="token punctuation">.</span>Map   <span class="token comment" spellcheck="true">// 服务对象集合</span>
    reqLock    sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">// 请求锁用来保护 freeReq</span>
    freeReq    <span class="token operator">*</span>Request
    respLock   sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">// 响应锁保护 freeResp</span>
    freeResp   <span class="token operator">*</span>Response
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="rpc-Register-调用-DefaultServer-Register，主要实现在内部函数-register-中"><a href="#rpc-Register-调用-DefaultServer-Register，主要实现在内部函数-register-中" class="headerlink" title="rpc.Register 调用 DefaultServer.Register，主要实现在内部函数 register 中"></a>rpc.Register 调用 DefaultServer.Register，主要实现在内部函数 register 中</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Register 在 server 中注册并发布 receiver 的函数集时需满足以下条件:</span>
<span class="token comment" spellcheck="true">//   * 函数和函数的类型名是已导出的</span>
<span class="token comment" spellcheck="true">//   * 两个参数都是导出类型 (或內建类型)</span>
<span class="token comment" spellcheck="true">//   * 第二个参数是指针</span>
<span class="token comment" spellcheck="true">//   * 函数只有一个类型为 error 的返回类型</span>
<span class="token comment" spellcheck="true">// 如果 receiver 不是导出的类型或者没有符合条件的函数，将会返回一个错误。Register 将会使用 log 包记录出现的 error</span>
<span class="token comment" spellcheck="true">// 客户端使用 "Type.Method" 的格式来调用函数，比如上文例子中 Arith.Multiply，这里的 Type 是 receiver 的具体类型.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">register</span><span class="token punctuation">(</span>rcvr <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> name <span class="token builtin">string</span><span class="token punctuation">,</span> useName <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 新起一个 service 服务对象</span>
    s <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>typ <span class="token operator">=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>rcvr<span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>rcvr <span class="token operator">=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>rcvr<span class="token punctuation">)</span>
    sname <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">Indirect</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>rcvr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 默认服务名是 receiver 的反射类型</span>
    <span class="token comment" spellcheck="true">// 在 server.Register 中调用 register(rcvr, "", false)</span>
    <span class="token comment" spellcheck="true">// 在 server.RegisterName 中调用 register(rcvr, name, true)</span>
    <span class="token comment" spellcheck="true">// 这里使用的 name 可以指定服务对象名，客户端调用 rpc 服务时可以使用 "name.Method" 代替原来的 "Type.Method"</span>
    <span class="token keyword">if</span> useName <span class="token punctuation">{</span>
        sname <span class="token operator">=</span> name
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> sname <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>
        s <span class="token operator">:=</span> <span class="token string">"rpc.Register: no service name for type "</span> <span class="token operator">+</span> s<span class="token punctuation">.</span>typ<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isExported</span><span class="token punctuation">(</span>sname<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>useName <span class="token punctuation">{</span>
        s <span class="token operator">:=</span> <span class="token string">"rpc.Register: type "</span> <span class="token operator">+</span> sname <span class="token operator">+</span> <span class="token string">" is not exported"</span>
        log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    s<span class="token punctuation">.</span>name <span class="token operator">=</span> sname

    <span class="token comment" spellcheck="true">// 判断传入的接口对象的函数集是否符合 RPC 规范</span>
    s<span class="token punctuation">.</span>method <span class="token operator">=</span> <span class="token function">suitableMethods</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>typ<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        str <span class="token operator">:=</span> <span class="token string">""</span>

        <span class="token comment" spellcheck="true">// 如果满足条件的函数集为空，根据 s.typ 的指针地址对象是否有符合条件的函数返回错误说明</span>
        method <span class="token operator">:=</span> <span class="token function">suitableMethods</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">PtrTo</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>typ<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 此错误说明传入的 s.typ 不符合条件，应该传入 *s.typ</span>
            str <span class="token operator">=</span> <span class="token string">"rpc.Register: type "</span> <span class="token operator">+</span> sname <span class="token operator">+</span> <span class="token string">" has no exported methods of suitable type (hint: pass a pointer to value of that type)"</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            str <span class="token operator">=</span> <span class="token string">"rpc.Register: type "</span> <span class="token operator">+</span> sname <span class="token operator">+</span> <span class="token string">" has no exported methods of suitable type"</span>
        <span class="token punctuation">}</span>
        log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// LoadOrStore 会检查 sync.Map 类型对象中是否存在传入的键名，如果存在则返回相应的值和 true</span>
    <span class="token comment" spellcheck="true">// 反之会先存入键值对再返回值和 false</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> dup <span class="token operator">:=</span> server<span class="token punctuation">.</span>serviceMap<span class="token punctuation">.</span><span class="token function">LoadOrStore</span><span class="token punctuation">(</span>sname<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> dup <span class="token punctuation">{</span>
        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"rpc: service already defined: "</span> <span class="token operator">+</span> sname<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注册后监听请求"><a href="#注册后监听请求" class="headerlink" title="注册后监听请求"></a>注册后监听请求</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Accept 从监听器上接收获取到的连接并服务每个连接的请求</span>
<span class="token comment" spellcheck="true">// Accept 在监听器返回非空的错误前都处于阻塞态</span>
<span class="token comment" spellcheck="true">// 调用者一般应使用 goroutine 启用 Accept，比如 `go server.Accept(l)`</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>lis net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> lis<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"rpc.Serve: accept:"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">go</span> server<span class="token punctuation">.</span><span class="token function">ServeConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在-Accept-中调用-ServeConn-函数进行服务"><a href="#在-Accept-中调用-ServeConn-函数进行服务" class="headerlink" title="在 Accept 中调用 ServeConn 函数进行服务"></a>在 Accept 中调用 ServeConn 函数进行服务</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ServeConn 在一个连接上运行 server 并服务该连接.</span>
<span class="token comment" spellcheck="true">// ServeConn 在服务该连接到客户端挂起的期间处于阻塞态.</span>
<span class="token comment" spellcheck="true">// 一般另起线程来调用本函数，比如 `go server.ServeConn(conn)` (Accept 函数中有调用)</span>
<span class="token comment" spellcheck="true">// ServeConn 在该连接上使用 gob 包的有线格式 (参见 gob 包) .</span>
<span class="token comment" spellcheck="true">// 如需使用其他备份编解码器, 可以使用 ServeCodec 函数.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ServeConn</span><span class="token punctuation">(</span>conn io<span class="token punctuation">.</span>ReadWriteCloser<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buf <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
    srv <span class="token operator">:=</span> <span class="token operator">&amp;</span>gobServerCodec<span class="token punctuation">{</span>
        rwc<span class="token punctuation">:</span>    conn<span class="token punctuation">,</span>
        dec<span class="token punctuation">:</span>    gob<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">,</span>
        enc<span class="token punctuation">:</span>    gob<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span>
        encBuf<span class="token punctuation">:</span> buf<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    server<span class="token punctuation">.</span><span class="token function">ServeCodec</span><span class="token punctuation">(</span>srv<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// ServeCodec 与 ServeConn 类似，只是使用了指定的编解码器来解码 requests 和编码 responses</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ServeCodec</span><span class="token punctuation">(</span>codec ServerCodec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sending <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">)</span>
    wg <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        service<span class="token punctuation">,</span> mtype<span class="token punctuation">,</span> req<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> replyv<span class="token punctuation">,</span> keepReading<span class="token punctuation">,</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>codec<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 读取请求信息</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> debugLog <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"rpc:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>keepReading <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果读请求的 header 就出错了，keepReading 为 false，跳出此循环；如果能读取 header 信息便继续</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 发送一个 response 表示此请求无效</span>
            <span class="token keyword">if</span> req <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                server<span class="token punctuation">.</span><span class="token function">sendResponse</span><span class="token punctuation">(</span>sending<span class="token punctuation">,</span> req<span class="token punctuation">,</span> invalidRequest<span class="token punctuation">,</span> codec<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                server<span class="token punctuation">.</span><span class="token function">freeRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">go</span> service<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> sending<span class="token punctuation">,</span> wg<span class="token punctuation">,</span> mtype<span class="token punctuation">,</span> req<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> replyv<span class="token punctuation">,</span> codec<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 没有 request 后需等待 response 发送完成再关闭 codec</span>
    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    codec<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端请求某个服务后，服务端在-ServeCodec-中通过调用-service-call-调用相应服务"><a href="#客户端请求某个服务后，服务端在-ServeCodec-中通过调用-service-call-调用相应服务" class="headerlink" title="客户端请求某个服务后，服务端在 ServeCodec 中通过调用 service.call 调用相应服务"></a>客户端请求某个服务后，服务端在 ServeCodec 中通过调用 service.call 调用相应服务</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>service<span class="token punctuation">)</span> <span class="token function">call</span><span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">,</span> sending <span class="token operator">*</span>sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">,</span> wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">,</span> mtype <span class="token operator">*</span>methodType<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> replyv reflect<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> codec ServerCodec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> wg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    mtype<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    mtype<span class="token punctuation">.</span>numCalls<span class="token operator">++</span>
    mtype<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    function <span class="token operator">:=</span> mtype<span class="token punctuation">.</span>method<span class="token punctuation">.</span>Func
    <span class="token comment" spellcheck="true">// 执行函数, 返回新的值给 reply</span>
    returnValues <span class="token operator">:=</span> function<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>reflect<span class="token punctuation">.</span>Value<span class="token punctuation">{</span>s<span class="token punctuation">.</span>rcvr<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> replyv<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 返回值里的错误</span>
    errInter <span class="token operator">:=</span> returnValues<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    errmsg <span class="token operator">:=</span> <span class="token string">""</span>
    <span class="token keyword">if</span> errInter <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        errmsg <span class="token operator">=</span> errInter<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 发送响应，然后释放当前请求节点</span>
    server<span class="token punctuation">.</span><span class="token function">sendResponse</span><span class="token punctuation">(</span>sending<span class="token punctuation">,</span> req<span class="token punctuation">,</span> replyv<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> codec<span class="token punctuation">,</span> errmsg<span class="token punctuation">)</span>
    server<span class="token punctuation">.</span><span class="token function">freeRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTTP-方式"><a href="#HTTP-方式" class="headerlink" title="HTTP 方式"></a>HTTP 方式</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ServeHTTP 实现一个用于回应 RPC 请求的 http.Handler</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> req<span class="token punctuation">.</span>Method <span class="token operator">!=</span> <span class="token string">"CONNECT"</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"text/plain; charset=utf-8"</span><span class="token punctuation">)</span>
        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusMethodNotAllowed<span class="token punctuation">)</span>
        io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"405 must CONNECT\n"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    conn<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> w<span class="token punctuation">.</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>Hijacker<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 让调用者主动接管连接</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"rpc hijacking "</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">"HTTP/1.0 "</span><span class="token operator">+</span>connected<span class="token operator">+</span><span class="token string">"\n\n"</span><span class="token punctuation">)</span>
    server<span class="token punctuation">.</span><span class="token function">ServeConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// HandleHTTP 注册 server 的 RPC 信息到 rpcPath 上，注册 server 的 debug 信息到 debugPath 上</span>
<span class="token comment" spellcheck="true">// HandleHTTP 会注册到 http.DefaultServeMux 上</span>
<span class="token comment" spellcheck="true">// 之后，仍需要调用 http.Serve()，一般会另起线程："go http.Serve(l, nil)"</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">HandleHTTP</span><span class="token punctuation">(</span>rpcPath<span class="token punctuation">,</span> debugPath <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>rpcPath<span class="token punctuation">,</span> server<span class="token punctuation">)</span>
    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>debugPath<span class="token punctuation">,</span> debugHTTP<span class="token punctuation">{</span>server<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-client"><a href="#2-client" class="headerlink" title="2. client"></a>2. client</h2><p><img src="https://src.wangriyu.wang/images/blog/go/RPC-Client.png" alt="image"><br></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Call 代表一个活跃的 RPC.</span>
<span class="token keyword">type</span> Call <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ServiceMethod <span class="token builtin">string</span>      <span class="token comment" spellcheck="true">// 调用的服务名</span>
    Args          <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 函数传入参数 (*struct)</span>
    Reply         <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 函数返回结果 (*struct)</span>
    Error         <span class="token builtin">error</span>       <span class="token comment" spellcheck="true">// 结束后的错误状态</span>
    Done          <span class="token keyword">chan</span> <span class="token operator">*</span>Call  <span class="token comment" spellcheck="true">// 非空表示一个 rpc 调用结束</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Client 代表一个 RPC 客户端，同一个客户端可能有多个未返回的调用，也可能被多个 go 线程同时使用</span>
<span class="token keyword">type</span> Client <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    codec ClientCodec
    reqMutex sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">// 保护 request</span>
    request  Request
    mutex    sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">// 保护 seq</span>
    seq      <span class="token builtin">uint64</span> <span class="token comment" spellcheck="true">// 一个序列值，request 和 response 会以此标识</span>
    pending  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">uint64</span><span class="token punctuation">]</span><span class="token operator">*</span>Call <span class="token comment" spellcheck="true">// 等待响应的 Call 集合</span>
    closing  <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// 用户已调用 Close</span>
    shutdown <span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// 服务器已告知停止</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// ClientCodec 接口实现了 RPC 会话的客户端一侧 RPC 请求的写入和 RPC 响应的读取。</span>
<span class="token comment" spellcheck="true">// 客户端调用 WriteRequest 来写入请求到连接，然后成对调用 ReadRsponseHeader 和</span>
<span class="token comment" spellcheck="true">// ReadResponseBody 以读取响应。客户端在结束该连接的事务时调用 Close 方法。</span>
<span class="token comment" spellcheck="true">// ReadResponseBody 可以使用 nil 参数调用，以强制回复的主体被读取然后丢弃。</span>
<span class="token keyword">type</span> ClientCodec <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// WriteRequest 必须能安全的被多个 go 协程同时使用</span>
    <span class="token function">WriteRequest</span><span class="token punctuation">(</span><span class="token operator">*</span>Request<span class="token punctuation">,</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">ReadResponseHeader</span><span class="token punctuation">(</span><span class="token operator">*</span>Response<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token function">ReadResponseBody</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">error</span>

    <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端获取-Client-对象"><a href="#客户端获取-Client-对象" class="headerlink" title="客户端获取 Client 对象"></a>客户端获取 Client 对象</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// DialHTTP 通过地址连向一个 HTTP RPC server (建立 HTTP 连接)</span>
<span class="token keyword">func</span> <span class="token function">DialHTTP</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Client<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">DialHTTPPath</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address<span class="token punctuation">,</span> DefaultRPCPath<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// DialHTTPPath 通过地址和路径连向一个 HTTP RPC server</span>
<span class="token keyword">func</span> <span class="token function">DialHTTPPath</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Client<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> err <span class="token builtin">error</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">"CONNECT "</span><span class="token operator">+</span>path<span class="token operator">+</span><span class="token string">" HTTP/1.0\n\n"</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 在切换 RPC 协议前需要保证成功的 HTTP 响应</span>
    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ReadResponse</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">{</span>Method<span class="token punctuation">:</span> <span class="token string">"CONNECT"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> resp<span class="token punctuation">.</span>Status <span class="token operator">==</span> connected <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">NewClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"unexpected HTTP response: "</span> <span class="token operator">+</span> resp<span class="token punctuation">.</span>Status<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>OpError<span class="token punctuation">{</span>
        Op<span class="token punctuation">:</span>   <span class="token string">"dial-http"</span><span class="token punctuation">,</span>
        Net<span class="token punctuation">:</span>  network <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> address<span class="token punctuation">,</span>
        Addr<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>
        Err<span class="token punctuation">:</span>  err<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Dial 通过指定的地址连向一个 RPC server (建立 TCP 连接)</span>
<span class="token keyword">func</span> <span class="token function">Dial</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Client<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span>network<span class="token punctuation">,</span> address<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">NewClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-Client-对象"><a href="#新建-Client-对象" class="headerlink" title="新建 Client 对象"></a>新建 Client 对象</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewClient</span><span class="token punctuation">(</span>conn io<span class="token punctuation">.</span>ReadWriteCloser<span class="token punctuation">)</span> <span class="token operator">*</span>Client <span class="token punctuation">{</span>
    encBuf <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
    client <span class="token operator">:=</span> <span class="token operator">&amp;</span>gobClientCodec<span class="token punctuation">{</span>conn<span class="token punctuation">,</span> gob<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">,</span> gob<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>encBuf<span class="token punctuation">)</span><span class="token punctuation">,</span> encBuf<span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">NewClientWithCodec</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewClientWithCodec</span><span class="token punctuation">(</span>codec ClientCodec<span class="token punctuation">)</span> <span class="token operator">*</span>Client <span class="token punctuation">{</span>
    client <span class="token operator">:=</span> <span class="token operator">&amp;</span>Client<span class="token punctuation">{</span>
        codec<span class="token punctuation">:</span>   codec<span class="token punctuation">,</span>
        pending<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">uint64</span><span class="token punctuation">]</span><span class="token operator">*</span>Call<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">go</span> client<span class="token punctuation">.</span><span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 另起线程接收 response</span>
    <span class="token keyword">return</span> client
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从连接中读取-response-根据-seq-找到-pending-集合中对应的-Call-对象，获取响应内容，Done-结束"><a href="#从连接中读取-response-根据-seq-找到-pending-集合中对应的-Call-对象，获取响应内容，Done-结束" class="headerlink" title="从连接中读取 response, 根据 seq 找到 pending 集合中对应的 Call 对象，获取响应内容，Done 结束"></a>从连接中读取 response, 根据 seq 找到 pending 集合中对应的 Call 对象，获取响应内容，Done 结束</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>client <span class="token operator">*</span>Client<span class="token punctuation">)</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> err <span class="token builtin">error</span>
    <span class="token keyword">var</span> response Response
    <span class="token keyword">for</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        response <span class="token operator">=</span> Response<span class="token punctuation">{</span><span class="token punctuation">}</span>
        err <span class="token operator">=</span> client<span class="token punctuation">.</span>codec<span class="token punctuation">.</span><span class="token function">ReadResponseHeader</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>response<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        seq <span class="token operator">:=</span> response<span class="token punctuation">.</span>Seq
        client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        call <span class="token operator">:=</span> client<span class="token punctuation">.</span>pending<span class="token punctuation">[</span>seq<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 等待队列中的对应当前 response 的序列号的 Call 对象</span>
        <span class="token function">delete</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span>pending<span class="token punctuation">,</span> seq<span class="token punctuation">)</span>
        client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">switch</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> call <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true">// call == nil 代表等待序列中没有对应的 Call 对象，一般意味着 WriteRequest 时失败了并且 call 已经被删去</span>
            <span class="token comment" spellcheck="true">// 返回的 response 是读取错误 request 的错误信息</span>
            err <span class="token operator">=</span> client<span class="token punctuation">.</span>codec<span class="token punctuation">.</span><span class="token function">ReadResponseBody</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"reading error body: "</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">case</span> response<span class="token punctuation">.</span>Error <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true">// 获取到一个错误响应. 将这个传给 Call;</span>
            call<span class="token punctuation">.</span>Error <span class="token operator">=</span> <span class="token function">ServerError</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>Error<span class="token punctuation">)</span>
            err <span class="token operator">=</span> client<span class="token punctuation">.</span>codec<span class="token punctuation">.</span><span class="token function">ReadResponseBody</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"reading error body: "</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            call<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
            err <span class="token operator">=</span> client<span class="token punctuation">.</span>codec<span class="token punctuation">.</span><span class="token function">ReadResponseBody</span><span class="token punctuation">(</span>call<span class="token punctuation">.</span>Reply<span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                call<span class="token punctuation">.</span>Error <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"reading body "</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            call<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 关闭等待中的 calls.</span>
    client<span class="token punctuation">.</span>reqMutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>shutdown <span class="token operator">=</span> <span class="token boolean">true</span>
    closing <span class="token operator">:=</span> client<span class="token punctuation">.</span>closing
    <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>
        <span class="token keyword">if</span> closing <span class="token punctuation">{</span>
            err <span class="token operator">=</span> ErrShutdown
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            err <span class="token operator">=</span> io<span class="token punctuation">.</span>ErrUnexpectedEOF
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> call <span class="token operator">:=</span> <span class="token keyword">range</span> client<span class="token punctuation">.</span>pending <span class="token punctuation">{</span>
        call<span class="token punctuation">.</span>Error <span class="token operator">=</span> err
        call<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    client<span class="token punctuation">.</span>reqMutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> debugLog <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>closing <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"rpc: client protocol error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Client-使用不同函数去调取-rpc-服务，Go-可以异步执行，Call-是同步的"><a href="#Client-使用不同函数去调取-rpc-服务，Go-可以异步执行，Call-是同步的" class="headerlink" title="Client 使用不同函数去调取 rpc 服务，Go 可以异步执行，Call 是同步的"></a>Client 使用不同函数去调取 rpc 服务，Go 可以异步执行，Call 是同步的</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Go 异步地执行函数. 本方法 Call 结构体类型指针的返回值代表该次远程调用.</span>
<span class="token comment" spellcheck="true">// 通道类型的参数 done 会在本次调用完成时发出信号（通过返回本次 Go 方法的返回值）</span>
<span class="token comment" spellcheck="true">// 如果 done 为 nil，Go 会申请一个新的通道（写入返回值的 Done 字段）</span>
<span class="token comment" spellcheck="true">// 如果 done 非 nil，done 必须有缓冲，否则 Go 方法会崩溃。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>client <span class="token operator">*</span>Client<span class="token punctuation">)</span> <span class="token function">Go</span><span class="token punctuation">(</span>serviceMethod <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> reply <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> done <span class="token keyword">chan</span> <span class="token operator">*</span>Call<span class="token punctuation">)</span> <span class="token operator">*</span>Call <span class="token punctuation">{</span>
    call <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Call<span class="token punctuation">)</span>
    call<span class="token punctuation">.</span>ServiceMethod <span class="token operator">=</span> serviceMethod
    call<span class="token punctuation">.</span>Args <span class="token operator">=</span> args
    call<span class="token punctuation">.</span>Reply <span class="token operator">=</span> reply
    <span class="token keyword">if</span> done <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        done <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Call<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// buffered.</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果调用者传的 done != nil，则必须确保通道有足够的缓冲来给多个同步 RPCs 使用</span>
        <span class="token comment" spellcheck="true">// 如果通道完全没有缓冲，最好不要去运行</span>
        <span class="token keyword">if</span> <span class="token function">cap</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">Panic</span><span class="token punctuation">(</span><span class="token string">"rpc: done channel is unbuffered"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    call<span class="token punctuation">.</span>Done <span class="token operator">=</span> done
    client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span>
    <span class="token keyword">return</span> call
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Call 调用传入名的远程服务，并等待结束返回结果和错误状态</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>client <span class="token operator">*</span>Client<span class="token punctuation">)</span> <span class="token function">Call</span><span class="token punctuation">(</span>serviceMethod <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> reply <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    call <span class="token operator">:=</span> <span class="token operator">&lt;-</span>client<span class="token punctuation">.</span><span class="token function">Go</span><span class="token punctuation">(</span>serviceMethod<span class="token punctuation">,</span> args<span class="token punctuation">,</span> reply<span class="token punctuation">,</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>Call<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Done
    <span class="token keyword">return</span> call<span class="token punctuation">.</span>Error
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Go-中调用的函数"><a href="#Go-中调用的函数" class="headerlink" title="Go 中调用的函数"></a>Go 中调用的函数</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>client <span class="token operator">*</span>Client<span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>call <span class="token operator">*</span>Call<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client<span class="token punctuation">.</span>reqMutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> client<span class="token punctuation">.</span>reqMutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 将 call 转入等待集合</span>
    client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> client<span class="token punctuation">.</span>shutdown <span class="token operator">||</span> client<span class="token punctuation">.</span>closing <span class="token punctuation">{</span>
        call<span class="token punctuation">.</span>Error <span class="token operator">=</span> ErrShutdown
    client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        call<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    seq <span class="token operator">:=</span> client<span class="token punctuation">.</span>seq
    client<span class="token punctuation">.</span>seq<span class="token operator">++</span>
    client<span class="token punctuation">.</span>pending<span class="token punctuation">[</span>seq<span class="token punctuation">]</span> <span class="token operator">=</span> call
    client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 将 request 编码并发送</span>
    client<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Seq <span class="token operator">=</span> seq
    client<span class="token punctuation">.</span>request<span class="token punctuation">.</span>ServiceMethod <span class="token operator">=</span> call<span class="token punctuation">.</span>ServiceMethod
    err <span class="token operator">:=</span> client<span class="token punctuation">.</span>codec<span class="token punctuation">.</span><span class="token function">WriteRequest</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">.</span>request<span class="token punctuation">,</span> call<span class="token punctuation">.</span>Args<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        call <span class="token operator">=</span> client<span class="token punctuation">.</span>pending<span class="token punctuation">[</span>seq<span class="token punctuation">]</span>
        <span class="token function">delete</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span>pending<span class="token punctuation">,</span> seq<span class="token punctuation">)</span>
        client<span class="token punctuation">.</span>mutex<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> call <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            call<span class="token punctuation">.</span>Error <span class="token operator">=</span> err
            call<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-jsonrpc"><a href="#3-jsonrpc" class="headerlink" title="3. jsonrpc"></a>3. jsonrpc</h2><p>jsonrpc 主要将 gob 序列化工具换成 json 序列化工具，主要函数还是调用 server 里的 FuncWithCodec 函数，原理基本一致</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.gitbook.com/book/smallnest/go-rpc-programming-guide/details" target="_blank" rel="noopener">Go RPC 开发指南</a></li><li><a href="http://colobu.com/2016/09/18/go-net-rpc-guide/" target="_blank" rel="noopener">Go 官方库 RPC 开发指南</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.4.md" target="_blank" rel="noopener">build-web-application-with-golang</a></li><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">rpc wikipedia</a></li><li><a href="https://technet.microsoft.com/en-us/library/cc738291%28v=ws.10%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">How RPC Works</a></li></ul>]]></content>
    
    <summary type="html">
    
      go net/rpc 包源码解读
    
    </summary>
    
      <category term="go" scheme="https://blog.wangriyu.wang/categories/go/"/>
    
    
      <category term="go 源码" scheme="https://blog.wangriyu.wang/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>PKI 体系</title>
    <link href="https://blog.wangriyu.wang/2018/04-http-pki.html"/>
    <id>https://blog.wangriyu.wang/2018/04-http-pki.html</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-06-22T02:08:27.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中间人攻击和信息抵赖"><a href="#中间人攻击和信息抵赖" class="headerlink" title="中间人攻击和信息抵赖"></a>中间人攻击和信息抵赖</h2><p>没有身份验证的情况下，在非对称加密中实现身份验证和密钥协商时，比如常用的 RSA 算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息。可能出现如下两种情况:</p><ul><li>中间人攻击 (MITM): 攻击者介入通信双方，C - M 通信时使用的是中间人自己的一对公私钥 Key_M，中间人可以解密客户端用 Key_M 加密的信看;<br>M - S 通信时使用的是服务器提供的公钥，加密从客户端得到的消息给服务器完成双方通信</li><li>信息抵赖: 发送消息者可以否认之前发过的消息，因为接收端使用公钥不能确定之前接收的消息来源身份</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/MITM.png" alt="image"></p><p>此时需要一种认证体系以确保通信者是安全可靠的。</p><h2 id="PKI-互联网公钥基础设施"><a href="#PKI-互联网公钥基础设施" class="headerlink" title="PKI - 互联网公钥基础设施"></a>PKI - 互联网公钥基础设施</h2><p><strong>PKI</strong> 的目标就是实现不同成员在不见面的情况下进行安全通信，当前采用的模型是基于可信的第三方机构，也就是 <strong>证书颁发机构 (certification authority，CA)</strong> 签发的证书。<br>PKI 通过数字证书认证机构 (CA) 将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系由注册和发布过程确定，取决于担保级别，链接关系可能由 CA 的各种软件或在人为监督下完成。</p><p><img src="https://src.wangriyu.wang/images/blog/http/PKI.png" alt="image"></p><ul><li>订阅人: 或者叫最终实体，是指那些需要证书来提供安全服务的团体，维护服务端的人</li><li>登记机构 (registration authority - RA): 主要是完成一些证书签发的相关管理工作。例如， RA 会首先对用户进行必要的身份验证，然后才会去找 CA 签发证书。在某些情况下，<br>当 CA 希望在用户附近建立一个分支机构时（例如在不同的国家建立当地登记中心），我们也称 RA 为本地登记机构（local registration authority，LRA）。实际上，很多 CA 也执行 RA 的职责。RA 确保公开密钥和个人身份链接，可以防抵赖。</li><li>凭证签发请求文件 (Certificate Signing Request - CSR): 一种包含凭证签发时所需的公钥、组织信息、个人信息 (域名) 等信息的 (.csr) 文件，不含私钥信息。</li><li>证书颁发机构 (certification authority - CA): 是指我们都信任的证书颁发机构，CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等，确认申请用户的身份之后再签发证书。<br>同时 CA 会在线提供其所签发证书的最新吊销信息，这样信赖方就可以验证证书是否仍然有效。</li><li>证书 (certificate) 包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名（使用散列函数计算公开的明文信息的信息摘要，<br>然后采用 CA 的私钥对信息摘要进行加密，此密文即签名）。<strong>证书 = 公钥 + 申请者与颁发者信息 + 签名</strong></li><li>信赖方 (relying party): 是指那些证书使用者。一般是指那些需要证书验证的网页浏览器、其他程序以及操作系统。他们通过维护根可信证书库来执行验证，<br>这些证书库包含某些 CA 的最终可信证书（信任密钥，trust anchor）。更广泛地说，信赖方是指那些需要通过证书在互联网上进行安全通信的最终用户。用户接收到证书后，读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，<br>然后利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性；然后去查询证书的吊销情况</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/certificate-status.png" alt="image"></p><ul><li>证书吊销列表 (Certificate Revocation List - CRL): 一个单独的文件。该文件包含了 CA 已经吊销的证书序列号 (唯一) 与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。<br>证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。</li><li>证书状态在线查询协议 (Online Certificate Status Protocol - OCSP): 一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。<br>部分 CA 或大部分的 <a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89#%E8%87%AA%E7%B0%BD%E8%AD%89%E6%9B%B8" target="_blank" rel="noopener">自签 CA (根证书)</a> 都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。</li></ul><p>一个具体实例: <a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89#%E7%94%B3%E9%A0%98%E5%8F%8A%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89#%E7%94%B3%E9%A0%98%E5%8F%8A%E4%BD%BF%E7%94%A8</a></p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><h3 id="证书大致分为三类"><a href="#证书大致分为三类" class="headerlink" title="证书大致分为三类"></a>证书大致分为三类</h3><ul><li>自签名 CA: 在自签名 CA 中，证书中的公钥和用于验证证书的密钥是相同的。一些自签名 CA 是根 CA。这种自签名证书通常不会被广泛信任，使用时可能会遇到电脑软件的安全警告。自签名证书本身就是根证书。</li><li>从属 CA: 在从属 CA 中，证书中的公钥和用于核实证书的密钥是不同的。一个 CA 向另一个 CA 颁发证书的过程叫做交叉认证 。</li><li>根 CA: 根 CA 是一种特殊的 CA，它受到客户无条件地信任，位于证书层次结构的最高层。所有证书链均终止于根 CA。根颁发机构必须对它自己的证书签名，因为在证书层次结构中再也没有更高的认证机构了。根证书也是自签名证书。</li></ul><p>其他的还可以细分为中介证书、终端实体证书、授权证书、TLS 服务器证书、通配符证书、TLS 客户端证书</p><h3 id="审核级别-担保级别"><a href="#审核级别-担保级别" class="headerlink" title="审核级别 (担保级别)"></a>审核级别 (担保级别)</h3><ul><li>域名验证 (DV): 最基本的审核级别，如果申领代表可以证明他拥有管理某域名的权力，认证机构就可以发放域名验证（DV）证书，一般认证机构通常使用自动机制或通过电邮确认审核域名拥有权，成本较低</li><li>组织验证 (OV): 代表可以证明他拥有管理某域名的权力，而且相关组织是实际存在的法人，认证机构可以发放组织验证（OV）证书。审核程序通常需要经过人手处理。</li><li>扩展验证 (EV): 最严格的审核级别，审核过程可能牵涉专业法律人员的调查及独立审计人员的确认，成本也更高；成功获得扩展验证证书的网站，浏览器通常会在地址栏以绿色表示相关机构的法人名称及所属国家代码。扩展验证证书的主体名称或主体别名上不可以有通配符</li></ul><h3 id="证书结构"><a href="#证书结构" class="headerlink" title="证书结构"></a>证书结构</h3><p><img src="https://src.wangriyu.wang/images/blog/http/certificate-struct.png" alt="image"></p><ul><li>版本号 (version): 证书一共有 3 个版本号，分别用 0、1、2 编码表示版本 1、版本 2 和版本 3。版本 1 只支持简单的字段，版本 2 增加了两个标识符，而版本 3 则增加了扩展功能。现在大部分的证书都采用版本 3 的格式。</li><li>序列号 (serialNumber): 在一开始，序列号只要是正整数即可，是每个 CA 用来唯一标识其所签发的证书。但是在出现了针对证书签名的预选 <a href="http://www.freebuf.com/articles/database/133391.html" target="_blank" rel="noopener">前缀攻击</a> 之后，序列号增加了更多的要求来防止此类攻击；现在序列号需要是无序的（无法被预测）而且至少包括 20 位的熵</li><li>签名算法 (signture Algorithm): 这个字段指明证书签名所用的算法，需要放到证书里面，这样才能被证书签名保护</li><li>颁发者 (issuer): 证书颁发者的可分辨名称（distinguished name，DN），这个字段比较复杂，根据不同的实体会包含许多部分。举例来说，Verisign 根证书的可分辨名称是 /C=US/O=VeriSign, Inc./OU=Class 3 Public Primary Certification Authority；它包括了国家、组织和组织单位三个部分。</li><li>有效期 (validity): 证书的有效期包括开始日期和结束日期，在这段时间内证书是有效的。</li><li>使用者 (subject): 证书使用实体的可分辨名称，和公钥一起用于证书的签发。在自签名证书里，使用者 (subject) 和颁发者 (issuer) 字段的可分辨名称是一样的。在最开始，可分辨名称里面的公用名（common name， CN）主要用于服务器主机名（例如 /CN=<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 用于 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 域名的证书）</li><li>公钥 (subject public-key info): 这个字段包含了公钥、算法 ID、可选参数</li><li>扩展 (extensions): 比如密钥用法、证书策略、CRL 分发点、使用者密钥标识符等等</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/github-certificate.png" alt="image"></p><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>CA 根证书和服务器实体证书中间增加一层证书机构，即中介证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的 CA 根证书验证合法即可</p><ol><li>服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书;</li><li>中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书;</li><li>客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 被信任。</li></ol><p><img src="https://src.wangriyu.wang/images/blog/http/certificate-chain.png" alt="certificate-chain"></p><p><img src="https://src.wangriyu.wang/images/blog/http/ssllabs-certificate-chain.png" alt="ssllabs-certificate-chain"></p><p>具体例子可以看维基百科的例子: <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88#%E8%88%89%E4%BE%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88#%E8%88%89%E4%BE%8B</a></p><p>点击浏览器地址栏的绿色小锁可以查看网站的证书链:</p><p><img src="https://src.wangriyu.wang/images/blog/http/chrome-certificate-chain.png" alt="chrome-certificate-chain"></p><p>二级证书结构存在的优势：</p><ul><li>减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发;</li><li>根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救;</li><li>中介证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书;</li><li>证书链四级以内一般不会对 HTTPS 的性能造成明显影响</li></ul><p>服务器一般提供一条证书链，但也有多条路径的可能。以 <a href="https://blog.csdn.net/fangwm2011/article/details/6623887" target="_blank" rel="noopener">交叉证书</a> 为例，一条可信路径可以一直到 CA 的主要根证书，另外一条则是到可选根证书上。<br>CA 有时候会为同样的密钥签发多张证书，例如现在最常使用的签名算法是 SHA1，因为安全原因正在逐步迁移到 SHA256， CA 可以使用同样的密钥签发出不同签名的新证书。如果信赖方恰好有两张这样的证书，那么就可以构建出两条不同的可信路径。</p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>再回过头来看中间人攻击，需要身份验证后中间人与 Server 通信时接收服务器的证书实现身份验证，但与客户端通信时无法向用户提供可信任的证书。</p><p><img src="https://src.wangriyu.wang/images/blog/http/MITM-Cert.png" alt="image"></p><p>除非伪造一份证书 (很困难)，或者骗取客户端信任，比如在客户机操作系统上添加中间人证书的完全信任，以此实现用户的信任和身份验证。</p><p>举个栗子:</p><p>使用抓包工具 Charles 时，如果想抓取 HTTPS 的内容，就需要安装其提供的证书并添加信任</p><p><img src="https://src.wangriyu.wang/images/blog/http/Charles.png" alt="image"></p><p>没有信任时，抓取的 HTTPS 内容无法解析</p><p><img src="https://src.wangriyu.wang/images/blog/http/nossl.png" alt="image"></p><p>取得信任后，抓取的 HTTPS 请求可以和 HTTP 请求一样直接读取</p><p><img src="https://src.wangriyu.wang/images/blog/http/withssl.png" alt="image"></p><p>在这个过程中 Charles 就是一个中间人，而且可以完全获取 HTTPS 信息，因为用户安装并信任它的证书，也就可以做到身份验证。</p><blockquote><p>可以看到加密协议下所有连接都是 Connect 形式，这涉及到 <a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议 - Tunneling Protocol</a> 的概念</p></blockquote><p>使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。</p><p>隧道通信的机制如下:</p><pre class="line-numbers language-http"><code class="language-http">The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination.
The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server,
the Proxy server continues to proxy the TCP stream to and from the client.The client is now being proxied to the remote host.
Any data sent to the proxy server is now forwarded, unmodified, to the remote host and the client can communicate using any protocol accepted by the remote host

Proxy servers may also limit connections by only allowing connections to the default HTTPS port 443, whitelisting hosts, or blocking traffic which doesn't appear to be SSL.

客户端先请求一个代理服务器去建立和目标服务器之间的 tcp tunnel，目标服务器尝试连接客户端 (实际是代理服务器)，如果连接成功建立，代理服务器会给客户端返回 200 ok 并继续代理客户端和目标服务器之间的 tcp 流。
任何发送给代理服务器的数据都会不加修改地被转发，远程主机和客户端可以通过任何协议 (TLS、SSH、SOCKS、PPTP...) 进行后续交互。

代理服务器也可以通过端口限制 (443)、host 白名单、阻止非 SSL 的数据流来限制连接
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些代理服务器需要认证信息来建立 tunnel. 常见的是 Proxy-Authorization 头域:</p><pre class="line-numbers language-http"><code class="language-http">CONNECT server.example.com:80 HTTP/1.1
<span class="token header-name keyword">Host:</span> server.example.com:80
<span class="token header-name keyword">Proxy-Authorization:</span> basic aGVsbG86d29ybGQ=
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于这个中间代理的详细信息见 <a href="https://en.wikipedia.org/wiki/DMZ_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/DMZ_(computing)</a></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>讲到 Charles，不得不提另一个抓包工具 Wireshark。这两个工具的抓包原理不同，Charles 是通过代理过滤抓取本机的网络请求，主要抓 HTTP、HTTPS 的请求；<br>Wireshark 则是使用了 <a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">网卡混杂模式 - promiscuous mode</a>，可以抓取指定网卡上所有流过的包，可以抓取应用层、传输层、网络层的各种封包，但是正常情况下不能解析 HTTPS 的内容 (可以通过配置浏览器提供的对称协商密钥或者服务器的私钥来解密 TLS 内容)。</p><p>开启混杂模式时除了可以看到自己电脑上的网络封包，还可以看到目标地址不是本机的网络包 (如果路由器没有做网络分发的工作的话，完全有可能接收到其他电脑的网络包)，还可以看到局域网内的广播等等。我看了一篇于此相关的网络攻击手段 - <a href="https://zhuanlan.zhihu.com/p/28818627" target="_blank" rel="noopener">ARP 攻击</a>。</p><p>ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址，如图</p><p><img src="https://src.wangriyu.wang/images/blog/http/ARP.png" alt="image"></p><p>而 ARP 攻击者可以通过两种方式实现抓取监听局域网内全部或者想要的目标的网络数据:</p><ul><li>通过大密集的 ARP 回应抢占或覆盖路由的映射表，使路由以为攻击者就是目标，然后把 ip 映射到错误对象的 mac 上，之后攻击者便能接收目标 ip 的网络数据</li><li>在局域网内向所有 ip 客户机广播，假装自己是网关，然后所有目标机器向自己发送外网或者转发请求数据</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD" target="_blank" rel="noopener">PKI - wiki</a></li><li><a href="https://www.wosign.com/faq/faq2016-0309-03.htm" target="_blank" rel="noopener">PKI 体系</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88" target="_blank" rel="noopener">信任链 - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">MITM</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">数字证书 - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">数字签名 - wiki</a></li><li><a href="https://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="noopener">http tunnel</a></li><li><a href="https://en.wikipedia.org/wiki/Tunneling_protocol" target="_blank" rel="noopener">Tunneling protocol</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">代理服务器 - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">反向代理 - wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      了解证书的相关内容以及 PKI 体系的规范和流程
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
      <category term="网络" scheme="https://blog.wangriyu.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SSL/TLS 详解</title>
    <link href="https://blog.wangriyu.wang/2018/03-http-tls.html"/>
    <id>https://blog.wangriyu.wang/2018/03-http-tls.html</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-06-17T13:08:52.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-TLS-定义"><a href="#1-TLS-定义" class="headerlink" title="1. TLS 定义"></a>1. TLS 定义</h2><p><strong>SSL</strong>(Secure Sockets Layer) 安全套接层，是一种安全协议，经历了 SSL 1.0、2.0、3.0 版本后发展成了标准安全协议 - <strong>TLS</strong>(Transport Layer Security) 传输层安全性协议。TLS 有 1.0 (RFC 2246)、1.1(RFC 4346)、1.2(RFC 5246)、1.3(1.3 在 3.26 号正式被批准) 版本。</p><p>TLS 在实现上分为 <strong>记录层</strong> 和 <strong>握手层</strong> 两层，其中握手层又含四个子协议: 握手协议（handshake protoco 协议（change cipher spec protocol）、应用数据协议（application data protocol）和警报协议（alert protocol）</p><p><img src="https://src.wangriyu.wang/images/blog/http/tls.png" alt="image"></p><h2 id="2-HTTPS-HTTP-over-TLS"><a href="#2-HTTPS-HTTP-over-TLS" class="headerlink" title="2. HTTPS = HTTP over TLS."></a>2. HTTPS = HTTP over TLS.</h2><p>只需配置浏览器和服务器相关设置开启 TLS，即可实现 HTTPS，TLS 高度解耦，可装可卸，与上层高级应用层协议相互协作又相互独立。</p><p><img src="https://src.wangriyu.wang/images/blog/http/https.png" alt="image"></p><h2 id="3-加密"><a href="#3-加密" class="headerlink" title="3. 加密"></a>3. 加密</h2><p>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p><p><img src="https://src.wangriyu.wang/images/blog/http/encrypt.png" alt="image"></p><p>TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p><p>例如，在 HTTPS 协议中，客户端发出请求，服务端会将公钥发给客户端，客户端验证过后生成一个密钥再用公钥加密后发送给服务端，成功后建立连接。通信过程中客户端将请求数据用得到的公钥加密后发送，服务端用私钥解密；服务端用客户端给的密钥加密响应报文，回复客户端，客户端再用存好的相同的密钥解密。</p><h2 id="4-记录层"><a href="#4-记录层" class="headerlink" title="4. 记录层"></a>4. 记录层</h2><p>记录协议负责在传输连接上交换的所有底层消息，并且可以配置加密。每一条 TLS 记录以一个短标头开始。标头包含记录内容的类型 (或子协议)、协议版本和长度。原始消息经过分段 (或者合并)、压缩、添加认证码、加密转为 TLS 记录的数据部分。</p><p><img src="https://src.wangriyu.wang/images/blog/http/message.png" alt="image"></p><h3 id="分片-Fragmentation"><a href="#分片-Fragmentation" class="headerlink" title="分片 (Fragmentation)"></a>分片 (Fragmentation)</h3><p>记录层将信息块分割成携带 2^14 字节 (16KB) 或更小块的数据的 TLSPlaintext 记录。</p><p>记录协议传输由其他协议层提交给它的不透明数据缓冲区。如果缓冲区超过记录的长度限制（2^14），记录协议会将其切分成更小的片段。反过来也是可能的，属于同一个子协议的小缓冲区也可以组合成一个单独的记录。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  <span class="token builtin">uint8</span> major<span class="token punctuation">,</span> minor<span class="token punctuation">;</span>
<span class="token punctuation">}</span> ProtocolVersion<span class="token punctuation">;</span>

enum <span class="token punctuation">{</span>
  <span class="token function">change_cipher_spec</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">handshake</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">application_data</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> ContentType<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token punctuation">{</span>
  ContentType <span class="token keyword">type</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于处理封闭片段的较高级协议</span>
  ProtocolVersion version<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用的安全协议版本</span>
  <span class="token builtin">uint16</span> length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TLSPlaintext.fragment 的长度（以字节为单位），不超过 2^14</span>
  opaque fragment<span class="token punctuation">[</span>TLSPlaintext<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 透明的应用数据，被视为独立的块，由类型字段指定的较高级协议处理</span>
<span class="token punctuation">}</span> TLSPlaintext<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="记录压缩和解压缩-Record-compression-and-decompression"><a href="#记录压缩和解压缩-Record-compression-and-decompression" class="headerlink" title="记录压缩和解压缩 (Record compression and decompression)"></a>记录压缩和解压缩 (Record compression and decompression)</h3><p>压缩算法将 TLSPlaintext 结构转换为 TLSCompressed 结构。如果定义 CompressionMethod 为 null 表示不压缩</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  ContentType <span class="token keyword">type</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same as TLSPlaintext.type</span>
  ProtocolVersion version<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same as TLSPlaintext.version</span>
  <span class="token builtin">uint16</span> length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TLSCompressed.fragment 的长度，不超过 2^14 + 1024</span>
  opaque fragment<span class="token punctuation">[</span>TLSCompressed<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> TLSCompressed<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空或标准流加密-Null-or-standard-stream-cipher"><a href="#空或标准流加密-Null-or-standard-stream-cipher" class="headerlink" title="空或标准流加密 (Null or standard stream cipher)"></a>空或标准流加密 (Null or standard stream cipher)</h3><p>流加密（BulkCipherAlgorithm）将 TLSCompressed.fragment 结构转换为流 TLSCiphertext.fragment 结构</p><pre class="line-numbers language-go"><code class="language-go">stream<span class="token operator">-</span>ciphered <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    opaque content<span class="token punctuation">[</span>TLSCompressed<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    opaque MAC<span class="token punctuation">[</span>CipherSpec<span class="token punctuation">.</span>hash_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> GenericStreamCipher<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>MAC 产生方法如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token function">HMAC_hash</span><span class="token punctuation">(</span>MAC_write_secret<span class="token punctuation">,</span> seq_num <span class="token operator">+</span> TLSCompressed<span class="token punctuation">.</span><span class="token keyword">type</span> <span class="token operator">+</span> TLSCompressed<span class="token punctuation">.</span>version <span class="token operator">+</span> TLSCompressed<span class="token punctuation">.</span>length <span class="token operator">+</span> TLSCompressed<span class="token punctuation">.</span>fragment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>seq_num（记录的序列号）、hash（SecurityParameters.mac_algorithm 指定的哈希算法）</p><blockquote><p>MAC(Message authentication code) - 消息认证码</p></blockquote><blockquote><p>注意，MAC 是在加密之前计算的。流加密加密整个块，包括 MAC。对于不使用同步向量 (例如 RC4) 的流加密，从一个记录结尾处的流加密状态仅用于后续数据包。如果 CipherSuite 是 TLS_NULL_WITH_NULL_NULL，则加密由身份操作 (数据未加密，MAC 大小为零，暗示不使用 MAC) 组成。TLSCiphertext.length 是 TLSCompressed.length 加上 CipherSpec.hash_size。</p></blockquote><h3 id="CBC-块加密-分组加密"><a href="#CBC-块加密-分组加密" class="headerlink" title="CBC 块加密 (分组加密)"></a>CBC 块加密 (分组加密)</h3><p>块加密（如 RC2 或 DES），将 TLSCompressed.fragment 结构转换为块 TLSCiphertext.fragment 结构</p><pre class="line-numbers language-go"><code class="language-go">block<span class="token operator">-</span>ciphered <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  opaque content<span class="token punctuation">[</span>TLSCompressed<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
  opaque MAC<span class="token punctuation">[</span>CipherSpec<span class="token punctuation">.</span>hash_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token builtin">uint8</span> padding<span class="token punctuation">[</span>GenericBlockCipher<span class="token punctuation">.</span>padding_length<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token builtin">uint8</span> padding_length<span class="token punctuation">;</span>
<span class="token punctuation">}</span> GenericBlockCipher<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>padding: 添加的填充将明文长度强制为块密码块长度的整数倍。填充可以是长达 255 字节的任何长度，只要满足 TLSCiphertext.length 是块长度的整数倍。长度大于需要的值可以阻止基于分析交换信息长度的协议攻击。填充数据向量中的每个 uint8 必须填入填充长度值 (即 padding_length)。</p><p>padding_length: 填充长度应该使得 GenericBlockCipher 结构的总大小是加密块长度的倍数。合法值范围从零到 255（含）。<strong>该长度指定 padding_length 字段本身除外的填充字段的长度</strong></p><p>加密块的数据长度（TLSCiphertext.length）是 TLSCompressed.length，CipherSpec.hash_size 和 padding_length 的总和加一</p><blockquote><p>示例: 如果块长度为 8 字节，压缩内容长度（TLSCompressed.length）为 61 字节，MAC 长度为 20 字节，则填充前的长度为 82 字节（padding_length 占 1 字节）。<br>因此，为了使总长度为块长度 (8 字节) 的偶数倍，模 8 的填充长度必须等于 6，所以填充长度可以为 6，14，22 等。如果填充长度是需要的最小值，比如 6，填充将为 6 字节，每个块都包含值 6。因此，块加密之前的 GenericBlockCipher 的最后 8 个八位字节将为 xx 06 06 06 06 06 06 06，其中 xx 是 MAC 的最后一个八位字节。</p><pre class="line-numbers language-http"><code class="language-http">XX  - 06 06 06 06 06 06 - 06
MAC -     padding[6]    - padding_length
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h3 id="记录有效载荷保护-Record-payload-protection"><a href="#记录有效载荷保护-Record-payload-protection" class="headerlink" title="记录有效载荷保护 (Record payload protection)"></a>记录有效载荷保护 (Record payload protection)</h3><p>加密和 MAC 功能将 TLSCompressed 结构转换为 TLSCiphertext。记录的 MAC 还包括序列号，以便可以检测到丢失，额外或重复的消息。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  ContentType <span class="token keyword">type</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same</span>
  ProtocolVersion version<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same</span>
  <span class="token builtin">uint16</span> length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TLSCiphertext.fragment 的长度，不超过 2^14 + 2048</span>
  <span class="token keyword">select</span> <span class="token punctuation">(</span>CipherSpec<span class="token punctuation">.</span>cipher_type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> stream<span class="token punctuation">:</span> GenericStreamCipher<span class="token punctuation">;</span>
    <span class="token keyword">case</span> block<span class="token punctuation">:</span> GenericBlockCipher<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> fragment<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TLSCompressed.fragment 的加密形式，带有 MAC</span>
<span class="token punctuation">}</span> TLSCiphertext<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意<br>这里提到的都是先 MAC 再加密，是基于 RFC 2246 的方案 (TLS 1.0) 写的。但新的方案选择先加密再 MAC，这种替代方案中，首先对明文和填充进行加密，再将结果交给 MAC 算法。这可以保证主动网络攻击者不能操纵任何加密数据。</p></blockquote><h3 id="密钥计算-Key-calculation"><a href="#密钥计算-Key-calculation" class="headerlink" title="密钥计算 (Key calculation)"></a>密钥计算 (Key calculation)</h3><p>记录协议需要一种算法，从握手协议提供的安全性参数生成密钥、<a href="https://zh.wikipedia.org/wiki/%E5%88%9D%E5%A7%8B%E5%90%91%E9%87%8F" target="_blank" rel="noopener">IV</a> 和 MAC secret.</p><p>主密钥 (Master secret): 在连接中双方共享的一个 48 字节的密钥<br>客户随机数 (client random): 由客户端提供的 32 字节值<br>服务器随机数 (server random): 由服务器提供的 32 字节值</p><h2 id="5-握手层"><a href="#5-握手层" class="headerlink" title="5. 握手层"></a>5. 握手层</h2><ul><li>握手协议的职责是生成通信过程所需的共享密钥和进行身份认证。这部分使用无密码套件，为防止数据被窃听，通过公钥密码或 Diffie-Hellman 密钥交换技术通信。</li><li>密码规格变更协议，用于密码切换的同步，是在握手协议之后的协议。握手协议过程中使用的协议是“不加密”这一密码套件，握手协议完成后则使用协商好的密码套件。</li><li>警告协议，当发生错误时使用该协议通知通信对方，如握手过程中发生异常、消息认证码错误、数据无法解压缩等。</li><li>应用数据协议，通信双方真正进行应用数据传输的协议，传送过程通过 TLS 应用数据协议和 TLS 记录协议来进行传输。</li></ul><p>握手是 TLS 协议中最精密复杂的部分。在这个过程中，通信双方协商连接参数，并且完成身 份验证。根据使用的功能的不同，整个过程通常需要交换 6~10 条消息。根据配置和支持的协议扩展的不同，交换过程可能有许多变种。在使用中经常可以观察到以下三种流程：(1) 完整的握手， 对服务器进行身份验证；(2) 恢复之前的会话采用的简短握手；(3) 对客户端和服务器都进行身份验证的握手。</p><p>握手协议消息的标头信息包含消息类型（1 字节）和长度（3 字节），余下的信息则取决于消息类型：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  HandshakeType msg_type<span class="token punctuation">;</span>
  uint24 length<span class="token punctuation">;</span>
  HandshakeMessage message<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Handshake<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-完整握手"><a href="#5-1-完整握手" class="headerlink" title="5.1 完整握手"></a>5.1 完整握手</h3><p>每一个 TLS 连接都会以握手开始。如果客户端此前并未与服务器建立会话，那么双方会执行一次完整的握手流程来协商 TLS 会话。握手过程中，客户端和服务器将进行以下四个主要步骤:</p><ul><li>交换各自支持的功能，对需要的连接参数达成一致</li><li>验证出示的证书，或使用其他方式进行身份验证</li><li>对将用于保护会话的共享主密钥达成一致</li><li>验证握手消息并未被第三方团体修改</li></ul><p>下面介绍最常见的握手规则，一种不需要验证客户端身份但需要验证服务器身份的握手:</p><p><img src="https://src.wangriyu.wang/images/blog/http/full-handshake.png" alt="image"></p><h4 id="5-1-1-ClientHello"><a href="#5-1-1-ClientHello" class="headerlink" title="5.1.1 ClientHello"></a>5.1.1 ClientHello</h4><p>这条消息将客户端的功能和首选项传送给服务器。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-clienthello.png" alt="image"></p><ul><li>Version: 协议版本（protocol version）指示客户端支持的最佳协议版本</li><li>Random: 一个 32 字节数据，28 字节是随机生成的 (图中的 Random Bytes)；剩余的 4 字节包含额外的信息，与客户端时钟有关 (图中使用的是 GMT Unix Time)。在握手时，客户端和服务器都会提供随机数，客户端的暂记作 random_C (用于后续的密钥的生成)。这种随机性对每次握手都是独一无二的，在身份验证中起着举足轻重的作用。它可以防止 <a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">重放攻击</a>，并确认初始数据交换的完整性。</li><li>Session ID: 在第一次连接时，会话 ID（session ID）字段是空的，这表示客户端并不希望恢复某个已存在的会话。典型的会话 ID 包含 32 字节随机生成的数据，一般由服务端生成通过 ServerHello 返回给客户端。</li><li>Cipher Suites: 密码套件（cipher suite）块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的</li><li>Compression: 客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是 null，代表没有压缩</li><li>Extensions: 扩展（extension）块由任意数量的扩展组成。这些扩展会携带额外数据</li></ul><h4 id="5-1-2-ServerHello"><a href="#5-1-2-ServerHello" class="headerlink" title="5.1.2 ServerHello"></a>5.1.2 ServerHello</h4><p>是将服务器选择的连接参数传回客户端。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-serverhello.png" alt="image"></p><p>这个消息的结构与 ClientHello 类似，只是每个字段只包含一个选项，其中包含服务端的 random_S 参数 (用于后续的密钥协商)。服务器无需支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受</p><p>图中的 <code>Cipher Suite</code> 是后续密钥协商和身份验证要用的加密套件，此处选择的密钥交换与签名算法是 ECDHE_RSA，对称加密算法是 AES-GCM，后面会讲到这个</p><p>还有一点默认情况下 TLS 压缩都是关闭的，因为 <a href="https://zh.wikipedia.org/wiki/CRIME" target="_blank" rel="noopener">CRIME</a> 攻击会利用 TLS 压缩恢复加密认证 cookie，实现会话劫持，而且一般配置 gzip 等内容压缩后再压缩 TLS 分片效益不大又额外占用资源，所以一般都关闭 TLS 压缩</p><h4 id="5-1-3-Certificate"><a href="#5-1-3-Certificate" class="headerlink" title="5.1.3 Certificate"></a>5.1.3 Certificate</h4><p>典型的 Certificate 消息用于携带服务器 X.509 <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88" target="_blank" rel="noopener">证书链</a>。<br>服务器必须保证它发送的证书与选择的算法套件一致。比方说，公钥算法与套件中使用的必须匹配。除此以外，一些密钥交换算法依赖嵌入证书的特定数据，而且要求证书必须以客户端支持的算法签名。所有这些都表明服务器需要配置多个证书（每个证书可能会配备不同的证书链）。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-certificate.png" alt="image"></p><p>Certificate 消息是可选的，因为并非所有套件都使用身份验证，也并非所有身份验证方法都需要证书。更进一步说，虽然消息默认使用 X.509 证书，但是也可以携带其他形式的标志；一些套件就依赖 <a href="https://zh.wikipedia.org/wiki/PGP" target="_blank" rel="noopener">PGP 密钥</a></p><h4 id="5-1-4-ServerKeyExchange"><a href="#5-1-4-ServerKeyExchange" class="headerlink" title="5.1.4 ServerKeyExchange"></a>5.1.4 ServerKeyExchange</h4><p>携带密钥交换需要的额外数据。ServerKeyExchange 是可选的，消息内容对于不同的协商算法套件会存在差异。部分场景下，比如使用 RSA 算法时，服务器不需要发送此消息。</p><p>ServerKeyExchange 仅在服务器证书消息（也就是上述 Certificate 消息）不包含足够的数据以允许客户端交换预主密钥（premaster secret）时才由服务器发送。</p><p>比如基于 DH 算法的握手过程中，需要单独发送一条 ServerKeyExchange 消息带上 DH 参数:</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-serverhellodone.png" alt="image"></p><h4 id="5-1-5-ServerHelloDone"><a href="#5-1-5-ServerHelloDone" class="headerlink" title="5.1.5 ServerHelloDone"></a>5.1.5 ServerHelloDone</h4><p>表明服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。</p><h4 id="5-1-6-verify-certificate"><a href="#5-1-6-verify-certificate" class="headerlink" title="5.1.6 verify certificate"></a>5.1.6 verify certificate</h4><p>客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证内容包括如下:</p><ul><li>证书链的可信性 trusted certificate path;</li><li>证书是否吊销 revocation，有两类方式 - 离线 CRL 与在线 OCSP，不同的客户端行为会不同;</li><li>有效期 expiry date，证书是否在有效时间范围;</li><li>域名 domain，核查证书域名是否与当前的访问域名匹配;</li></ul><p>由 <code>PKI 体系</code> 的内容可知，对端发来的证书签名是 CA 私钥加密的，接收到证书后，先读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性；然后去查询证书的吊销情况等</p><h4 id="5-1-7-ClientKeyExchange"><a href="#5-1-7-ClientKeyExchange" class="headerlink" title="5.1.7 ClientKeyExchange"></a>5.1.7 ClientKeyExchange</h4><p>合法性验证通过之后，客户端计算产生随机数字的预主密钥（Pre-master），并用证书公钥加密，发送给服务器并携带客户端为密钥交换提供的所有信息。这个消息受协商的密码套件的影响，内容随着不同的协商密码套件而不同。</p><p>此时客户端已经获取全部的计算协商密钥需要的信息: 两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，然后得到协商密钥(用于之后的消息加密)</p><pre class="line-numbers language-go"><code class="language-go">enc_key <span class="token operator">=</span> <span class="token function">PRF</span><span class="token punctuation">(</span>Pre_master<span class="token punctuation">,</span> <span class="token string">"master secret"</span><span class="token punctuation">,</span> random_C <span class="token operator">+</span> random_S<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-clientkeychange.png" alt="image"></p><p>图中使用的是 ECDHE 算法，ClientKeyExchange 传递的是 DH 算法的客户端参数，如果使用的是 RSA 算法则此处应该传递加密的预主密钥</p><h4 id="5-1-8-ChangeCipherSpec"><a href="#5-1-8-ChangeCipherSpec" class="headerlink" title="5.1.8 ChangeCipherSpec"></a>5.1.8 ChangeCipherSpec</h4><p>通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信</p><blockquote><p>注意<br>ChangeCipherSpec 不属于握手消息，它是另一种协议，只有一条消息，作为它的子协议进行实现。</p></blockquote><h4 id="5-1-9-Finished-Encrypted-Handshake-Message"><a href="#5-1-9-Finished-Encrypted-Handshake-Message" class="headerlink" title="5.1.9 Finished (Encrypted Handshake Message)"></a>5.1.9 Finished (Encrypted Handshake Message)</h4><p>Finished 消息意味着握手已经完成。消息内容将加密，以便双方可以安全地交换验证整个握手完整性所需的数据。</p><p>这个消息包含 verify_data 字段，它的值是握手过程中所有消息的散列值。这些消息在连接两端都按照各自所见的顺序排列，并以协商得到的主密钥 (enc_key) 计算散列。这个过程是通过一个伪随机函数（pseudorandom function，PRF）来完成的，这个函数可以生成任意数量的伪随机数据。<br>两端的计算方法一致，但会使用不同的标签（finished_label）：客户端使用 client finished，而服务器则使用 server finished。</p><pre class="line-numbers language-go"><code class="language-go">verify_data <span class="token operator">=</span> <span class="token function">PRF</span><span class="token punctuation">(</span>master_secret<span class="token punctuation">,</span> finished_label<span class="token punctuation">,</span> <span class="token function">Hash</span><span class="token punctuation">(</span>handshake_messages<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为 Finished 消息是加密的，并且它们的完整性由协商 MAC 算法保证，所以主动网络攻击者不能改变握手消息并对 vertify_data 的值造假。在 TLS 1.2 版本中，Finished 消息的长度默认是 12 字节（96 位），并且允许密码套件使用更长的长度。在此之前的版本，除了 SSL 3 使用 36 字节的定长消息，其他版本都使用 12 字节的定长消息。</p><h4 id="5-1-10-Server"><a href="#5-1-10-Server" class="headerlink" title="5.1.10 Server"></a>5.1.10 Server</h4><p>服务器用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，同样计算得到协商密钥: <code>enc_key = PRF(Pre_master, &quot;master secret&quot;, random_C + random_S)</code>;</p><p>同样计算之前所有收发信息的 hash 值，然后用协商密钥解密客户端发送的 verify_data_C，验证消息正确性;</p><h4 id="5-1-11-change-cipher-spec"><a href="#5-1-11-change-cipher-spec" class="headerlink" title="5.1.11 change_cipher_spec"></a>5.1.11 change_cipher_spec</h4><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-serverchangecipher.png" alt="image"></p><p>服务端验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信（图中多了一步 New Session Ticket，此为会话票证，会在会话恢复中解释）;</p><h4 id="5-1-12-Finished-Encrypted-Handshake-Message"><a href="#5-1-12-Finished-Encrypted-Handshake-Message" class="headerlink" title="5.1.12 Finished (Encrypted Handshake Message)"></a>5.1.12 Finished (Encrypted Handshake Message)</h4><p>服务器也结合所有当前的通信参数信息生成一段数据 (verify_data_S) 并采用协商密钥 session secret (enc_key) 与算法加密并发送到客户端;</p><h4 id="5-1-13-握手结束"><a href="#5-1-13-握手结束" class="headerlink" title="5.1.13 握手结束"></a>5.1.13 握手结束</h4><p>客户端计算所有接收信息的 hash 值，并采用协商密钥解密 verify_data_S，验证服务器发送的数据和密钥，验证通过则握手完成;</p><h4 id="5-1-14-加密通信"><a href="#5-1-14-加密通信" class="headerlink" title="5.1.14 加密通信"></a>5.1.14 加密通信</h4><p>开始使用协商密钥与算法进行加密通信。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-applicationdata.png" alt="image"></p><h3 id="5-2-密钥交换和签名算法"><a href="#5-2-密钥交换和签名算法" class="headerlink" title="5.2 密钥交换和签名算法"></a>5.2 密钥交换和签名算法</h3><h4 id="常用的密钥交换和签名算法"><a href="#常用的密钥交换和签名算法" class="headerlink" title="常用的密钥交换和签名算法"></a>常用的密钥交换和签名算法</h4><p>HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能。加密过程中，需要用到非对称密钥交换和对称内容加密两大算法。</p><p>对称内容加密强度非常高，加解密速度也很快，只是无法安全地生成和保管密钥。在 TLS 协议中，最后的应用数据都是经过对称加密后传输的，传输中所使用的对称协商密钥(上文中的 enc_key)，则是在握手阶段通过非对称密钥交换而来。常见的 AES-GCM、ChaCha20-Poly1305，都是对称加密算法。</p><p>非对称密钥交换能在不安全的数据通道中，产生只有通信双方才知道的对称加密密钥。目前最常用的密钥交换算法有 RSA 和 ECDHE。</p><p>RSA 历史悠久，支持度好，但不支持 <a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E5%90%91%E5%AE%89%E5%85%A8%E6%80%A7" target="_blank" rel="noopener">完美前向安全 - PFS(Perfect Forward Secrecy)</a>；而 ECDHE 是使用了 ECC（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，且支持 PFS。</p><p>在 <code>PKI 体系</code> 一节中说明了仅有非对称密钥交换还是无法抵御 MITM 攻击的，所以需要引入了 PKI 体系的证书来进行身份验证，其中服务端非对称加密产生的公钥会放在证书中传给客户端。</p><p>在 RSA 密钥交换中，浏览器使用证书提供的 RSA 公钥加密相关信息，如果服务端能解密，意味着服务端拥有与公钥对应的私钥，同时也能算出对称加密所需密钥。密钥交换和服务端认证合并在一起。</p><p>在 ECDH 密钥交换中，服务端使用私钥 (RSA 或 ECDSA) 对相关信息进行签名，如果浏览器能用证书公钥验证签名，就说明服务端确实拥有对应私钥，从而完成了服务端认证。密钥交换则是各自发送 DH 参数完成的，密钥交换和服务端认证是完全分开的。</p><p>可用于 ECDHE 数字签名的算法主要有 <a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">RSA</a> 和 <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener">ECDSA - 椭圆曲线数字签名算法</a>，也就是目前密钥交换 + 签名有三种主流选择:</p><ul><li><code>RSA</code> - RSA 密钥交换（无需签名）</li><li><code>ECDHE_RSA</code> - ECDHE 密钥交换、RSA 签名</li><li><code>ECDHE_ECDSA</code> - ECDHE 密钥交换、ECDSA 签名</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/signatureAlgorithm.png" alt="image"></p><p>比如我的网站使用的加密套件是 ECDHE_RSA，可以看到数字签名算法是 sha256 哈希加 RSA 加密，在 <code>PKI 体系</code> 一节中讲了签名是服务器信息摘要的哈希值加密生成的</p><p>内置 ECDSA 公钥的证书一般被称之为 ECC 证书，内置 RSA 公钥的证书就是 RSA 证书。因为 256 位 ECC Key 在安全性上等同于 3072 位 RSA Key，所以 ECC 证书体积比 RSA 证书小，而且 ECC 运算速度更快，ECDHE 密钥交换 + ECDSA 数字签名是目前最好的加密套件</p><p>以上内容来自本文: <a href="https://imququ.com/post/ecc-certificate.html" target="_blank" rel="noopener">开始使用 ECC 证书</a></p><p>关于 ECC 证书的更多细节可见文档: <a href="https://www.rfc-editor.org/rfc/rfc4492.txt" target="_blank" rel="noopener">ECC Cipher Suites for TLS - RFC4492</a></p><h4 id="RSA-密钥交换和-DH-密钥交换的区别"><a href="#RSA-密钥交换和-DH-密钥交换的区别" class="headerlink" title="RSA 密钥交换和 DH 密钥交换的区别"></a>RSA 密钥交换和 DH 密钥交换的区别</h4><p>使用 RSA 进行密钥交换的握手过程与前面说明的基本一致，只是没有 ServerKeyExchange 消息，其中协商密钥涉及到三个参数 (客户端随机数 random_C、服务端随机数 random_S、预主密钥 Premaster secret)，<br>其中前两个随机数和协商使用的算法是明文的很容易获取，最后一个 Premaster secret 会用服务器提供的公钥加密后传输给服务器 (密钥交换)，如果这个预主密钥被截取并破解则协商密钥也可以被破解。</p><p>RSA 算法的细节见: <a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">wiki</a> 和 <a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理（二）- 阮一峰</a></p><p>RSA 的算法核心思想是利用了极大整数 <a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">因数分解</a> 的计算复杂性</p><p>而使用 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">DH(Diffie-Hellman) 算法</a> 进行密钥交换，双方只要交换各自的 DH 参数(在 ServerKeyExchange 发送 Server params，在 ClientKeyExchange 发送 Client params)，不需要传递 Premaster secret，就可以各自算出这个预主密钥</p><p>DH 的握手过程如下，大致过程与 RSA 类似，图中只表达如何生成预主密钥:</p><p><img src="https://src.wangriyu.wang/images/blog/http/DH-handshake.png" alt="image"></p><p>服务器通过私钥将客户端随机数 random_C，服务端随机数 random_S，服务端 DH 参数 Server params 签名生成 signature，然后在 ServerKeyExchange 消息中发送服务端 DH 参数和该签名；</p><p>客户端收到后用服务器给的公钥解密验证签名，并在 ClientKeyExchange 消息中发送客户端 DH 参数 Client params；</p><p>服务端收到后，双方都有这两个参数，再各自使用这两个参数生成预主密钥 Premaster secret，之后的协商密钥等步骤与 RSA 基本一致。</p><blockquote><p>基于 RSA 算法与 DH 算法的握手最大的区别就在于密钥交换与身份认证。前者客户端使用公钥加密预主密钥并发送给服务端完成密钥交换，服务端利用私钥解密完成身份认证。后者利用各自发送的 DH 参数完成密钥交换，服务器私钥签名数据，客户端公钥验签完成身份认证。</p></blockquote><p>关于 DH 算法如何生成预主密钥，推荐看下 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">Wiki</a> 和 <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/#ephemeraldiffiehellmanhandshake" target="_blank" rel="noopener">Ephemeral Diffie-Hellman handshake</a></p><p>其核心思想是利用了 <a href="https://en.wikipedia.org/wiki/Discrete_logarithm" target="_blank" rel="noopener">离散对数问题</a> 的计算复杂性</p><blockquote><p>原根：假设一个整数 g 对于质数 P 来说是原根，那么 g^i mod P (1 ≦ i &lt; P) 的结果各不相同，且其结果按一定顺序排列后是 1 到 P-1 的所有整数，<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9#%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">例子</a></p></blockquote><blockquote><p>离散对数：如果对于一个整数 n 和质数 P 的一个原根 g，可以找到一个唯一的指数 i，使得 n = g^i mod P (0 ≦ i &lt; P)，那么指数 i 称为 n 的以 g 为基数的模 P 的离散对数</p></blockquote><blockquote><p>Diffie-Hellman 算法的有效性依赖于计算离散对数的难度，其含义是：当已知大素数 P 和它的一个原根 g 后，对给定的 n，要计算 i，被认为是很困难的，而给定 i 计算 n 却相对容易</p></blockquote><p>算法过程可以抽象成下图:</p><p><img src="https://src.wangriyu.wang/images/blog/http/Diffie-Hellman.png" alt="image"></p><p>双方预先商定好了一对 P g 值 (公开的)，而 Alice 有一个私密数 a(非公开，对应一个私钥)，Bob 有一个私密数 b(非公开，对应一个私钥)</p><ul><li><p>Alice 计算 A = g^a mod P，并把 A(公开，对应一个公钥) 发给 Bob</p></li><li><p>Bob 计算 B = g^b mod P，并把 B(公开，对应一个公钥) 发给 Alice</p></li><li><p>双方计算出共享密钥，K = B^a mod P = A^b mod P (= g^ab mod P)</p></li></ul><p>对于 Alice 和 Bob 来说通过对方发过来的公钥参数和自己手中的私钥可以得到最终相同的密钥</p><p>而第三方最多知道 P g A B，想得到私钥和最后的密钥很困难，当然前提是 a b P 足够大 (RFC3526 文档中有几个常用的大素数可供使用)，否则暴力破解也有可能试出答案，至于 g 一般取个较小值就可以</p><p>如下几张图是实际 DH 握手发送的内容:</p><p><img src="https://src.wangriyu.wang/images/blog/http/Cipher-suite.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/Server-params.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/Client-params.png" alt="image"></p><p>可以看到双方发给对方的参数中携带了一个公钥值，对应上述的 A 和 B</p><p>而且实际用的加密套件是 <a href="https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">椭圆曲线 DH 密钥交换 (ECDH)</a>，利用由椭圆曲线加密建立公钥与私钥对可以更进一步加强 DH 的安全性，因为目前解决椭圆曲线离散对数问题要比因式分解困难的多，而且 ECC 使用的密钥长度比 RSA 密钥短得多(目前 RSA 密钥需要 2048 位以上才能保证安全，而 ECC 密钥 256 位就足够)</p><p>关于 <a href="https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6" target="_blank" rel="noopener">椭圆曲线密码学 - ECC</a>，推荐看下 <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/" target="_blank" rel="noopener">A Primer on Elliptic Curve Cryptography - 原文</a> - <a href="https://zhuanlan.zhihu.com/p/26029199" target="_blank" rel="noopener">译文</a></p><h3 id="5-3-客户端身份验证"><a href="#5-3-客户端身份验证" class="headerlink" title="5.3 客户端身份验证"></a>5.3 客户端身份验证</h3><p>尽管可以选择对任意一端进行身份验证，但人们几乎都启用了对服务器的身份验证。如果服 务器选择的套件不是匿名的，那么就需要在 Certificate 消息中跟上自己的证书。</p><p><img src="https://src.wangriyu.wang/images/blog/http/mutualAuthentication.png" alt="image"></p><p>相比之下，服务器通过发送 CertificateRequest 消息请求对客户端进行身份验证。消息中列 出所有可接受的客户端证书。作为响应，客户端发送自己的 Certificate 消息（使用与服务器发 送证书相同的格式），并附上证书。此后，客户端发送 CertificateVerify 消息，证明自己拥有对应的私钥。</p><p>只有已经过身份验证的服务器才被允许请求客户端身份验证。基于这个原因，这个选项也被称为相互身份验证（mutual authentication）。</p><h4 id="5-3-1-CertificateRequest"><a href="#5-3-1-CertificateRequest" class="headerlink" title="5.3.1 CertificateRequest"></a>5.3.1 CertificateRequest</h4><p>在 ServerHello 的过程中发出，请求对客户端进行身份验证，并将其接受的证书的公钥 和签名算法传送给客户端。</p><p>它也可以选择发送一份自己接受的证书颁发机构列表，这些机构都用其可分辨名称来表示:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  ClientCertificateType certificate_types<span class="token punctuation">;</span>
  SignatureAndHashAlgorithm supported_signature_algorithms<span class="token punctuation">;</span>
  DistinguishedName certificate_authorities<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CertificateRequest<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-CertificateVerify"><a href="#5-3-2-CertificateVerify" class="headerlink" title="5.3.2 CertificateVerify"></a>5.3.2 CertificateVerify</h4><p>在 ClientKeyExchange 的过程中发出，证明自己拥有的私钥与之前发送的客户端证书中的公钥匹配。消息中包含一条到这一步为止的所有握手消息的签名：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Signature handshake_messages_signature<span class="token punctuation">;</span>
<span class="token punctuation">}</span> CertificateVerify<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-4-会话恢复"><a href="#5-4-会话恢复" class="headerlink" title="5.4 会话恢复"></a>5.4 会话恢复</h3><p>最初的会话恢复机制是，在一次完整协商的连接断开时，客户端和服务器都会将会话的安全参数保存一段时间。希望使用会话恢复的服务器为会话指定唯一的标识，称为会话 ID(Session ID)。服务器在 ServerHello 消息中将会话 ID 发回客户端。</p><p>希望恢复早先会话的客户端将适当的 Session ID 放入 ClientHello 消息，然后提交。服务器如果同意恢复会话，就将相同的 Session ID 放入 ServerHello 消息返回，接着使用之前协商的主密钥生成一套新的密钥，再切换到加密模式，发送 Finished 消息。<br>客户端收到会话已恢复的消息以后，也进行相同的操作。这样的结果是握手只需要一次网络往返。</p><p>Session ID 由服务器端支持，协议中的标准字段，因此基本所有服务器都支持，服务器端保存会话 ID 以及协商的通信信息，占用服务器资源较多。</p><p><img src="https://src.wangriyu.wang/images/blog/http/simple-handshake.png" alt="image"></p><p>用来替代服务器会话缓存和恢复的方案是使用会话票证（Session ticket）。使用这种方式，除了所有的状态都保存在客户端（与 HTTP Cookie 的原理类似）之外，其消息流与服务器会话缓存是一样的。</p><p>其思想是服务器取出它的所有会话数据（状态）并进行加密 (密钥只有服务器知道)，再以票证的方式发回客户端。在接下来的连接中，客户端恢复会话时在 <strong>ClientHello 的扩展字段</strong> session_ticket 中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话。</p><p>这种方法有可能使扩展服务器集群更为简单，因为如果不使用这种方式，就需要在服务集群的各个节点之间同步会话。<br>Session ticket 需要服务器和客户端都支持，属于一个扩展字段，占用服务器资源很少。</p><blockquote><p>警告<br>会话票证破坏了 TLS 安全模型。它使用票证密钥加密的会话状态并将其暴露在线路上。有些实现中的票证密钥可能会比连接使用的密码要弱。如果票证密钥被暴露，就可以解密连接上的全部数据。因此，使用会话票证时，票证密钥需要频繁轮换。</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="noopener">RFC 2246 - The TLS Protocol Version 1.0</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">NPN/ALPN - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">TLS - wiki</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc785811(v=ws.10" target="_blank" rel="noopener">SSL/TLS in detail</a>)</li><li><a href="https://www.wosign.com/faq/faq2016-0309-02.htm" target="_blank" rel="noopener">HTTPS 加密协议详解</a></li><li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/#rsahandshake" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a></li><li><a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm" target="_blank" rel="noopener">DSA - 数字签名算法</a></li><li>《HTTPS 权威指南 - 在服务器和 web 应用上部署 SSL/TLS 和 PKI》</li></ul>]]></content>
    
    <summary type="html">
    
      深入 tls 协议，了解 https 加密的过程
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
      <category term="网络" scheme="https://blog.wangriyu.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Message</title>
    <link href="https://blog.wangriyu.wang/2018/03-http-message.html"/>
    <id>https://blog.wangriyu.wang/2018/03-http-message.html</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-06-17T13:13:19.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="noopener">RFC2616</a> 中定义的 HTTP Request 消息体结构：</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">Request</span> <span class="token operator">=</span> Request-Line             </span><span class="token comment" spellcheck="true">// 请求行</span>
          *<span class="token punctuation">(</span><span class="token punctuation">(</span> general-header       <span class="token comment" spellcheck="true">// 通用首部</span>
            | request-header       <span class="token comment" spellcheck="true">// 请求首部</span>
            | entity-header <span class="token punctuation">)</span>CRLF<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 实体首部</span>
          CRLF
          <span class="token punctuation">[</span> message-body <span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/request.png" alt="image"></p><p>一个 HTTP 的 request 消息以一个请求行开始，从第二行开始是 headers (️每个键值对都以 CRLF 结尾)，接下来是一个 CRLF 开头的空行，表示 header 结束，最后是消息主体。</p><h3 id="请求行的定义如下"><a href="#请求行的定义如下" class="headerlink" title="请求行的定义如下:"></a>请求行的定义如下:</h3><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">Request-Line</span> <span class="token operator">=</span> Method SP Request-URI SP HTTP-Version CRLF</span>

<span class="token variable-declaration"><span class="token variable">Method</span> <span class="token operator">=</span> <span class="token string">"OPTIONS"</span> | <span class="token string">"GET"</span> | <span class="token string">"HEAD"</span> | <span class="token string">"POST"</span> | <span class="token string">"PUT"</span> | <span class="token string">"DELETE"</span> | <span class="token string">"TRACE"</span> | <span class="token string">"CONNECT"</span> | extension-method</span>

<span class="token variable-declaration"><span class="token variable">Request-URI</span> <span class="token operator">=</span> <span class="token string">"*"</span> | absoluteURI | abs_path | authotity（CONNECT）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="请求方法（也叫请求动作）"><a href="#请求方法（也叫请求动作）" class="headerlink" title="请求方法（也叫请求动作）"></a>请求方法（也叫请求动作）</h3><ul><li>GET 请求会显示请求指定的资源。一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET 会方法请求指定的页面信息，并返回响应主体，GET 被认为是不安全的方法，因为 GET 方法会被网络蜘蛛等任意的访问。</li><li>HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。</li><li>POST 请求会向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或 / 和修改现有资源。</li><li>PUT 请求会身向指定资源位置上传其最新内容，PUT 方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</li><li>DELETE 请求用于请求服务器删除所请求 URI 所标识的资源。DELETE 请求后指定资源会被删除，DELETE 方法也是幂等的。</li><li>CONNECT 方法是 HTTP/1.1 协议预留的，代表使用隧道协议 (Tunneling Protocol) 进行连接。通常用于 SSL/TLS 加密服务器的链接与非加密的 HTTP 代理服务器的通信。</li><li>OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用 ‘*’ 来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li><li>TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。</li></ul><h3 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h3><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">Request-URI</span> <span class="token operator">=</span> <span class="token string">"*"</span> | absoluteURI | abs_path | authority（CONNECT）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>“*“ 代表请求不指向特定的资源，而是服务器本身，且只在所使用的方法没必要应用到资源时允许。一个典型的例子是 <code>OPTIONS * HTTP/1.1</code></li><li>absoluteURI 绝对地址，比如 <code>GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1</code>。只用于向代理服务器 (proxy) 发送请求</li><li>abs_path 相对路径，“/” 代表服务器根</li><li>只有 CONNECT 方法使用 authority 形式，由域名和可选端口组成的 URL，比如 <code>CONNECT developer.mozilla.org:80 HTTP/1.1</code></li></ul><blockquote><p>向一个代理服务器发送 HTTP 请求时，请求行中应该使用绝对路径的 URL。如果向目标服务器直接发送请求，则请求行中只会包含相对路径的 URL(完整 URL 的 path 部分)。<br>为了能在后续 http 版本中过渡，所有 http/1.1 服务器都应该能够处理 absoluteURI 形式的请求，即使客户端只会向代理发送这种形式的请求，详见 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2</a></p></blockquote><p>HTTP/1.1 中 Host 和 Request-URI 一起作为 Request 消息接收者判断请求资源的条件, 确认主机资源的方法如下：</p><ul><li><p>如果 Request-URI 是绝对地址（absoluteURI），这时请求里的主机存在于 Request-URI 里。忽略任何出现在请求里 Host 头域值</p></li><li><p>假如 Request-URI 不是绝对地址（absoluteURI），并且请求包括一个 Host 头域，则主机由该 Host 头域值决定</p></li><li><p>假如由规则１或规则２定义的主机是一个无效的主机，则应当以一个 400（错误请求）错误消息返回</p></li></ul><blockquote><p>⚠️ HTTP/1.1 请求必须带 Host 头域，否则会报 bad request;</p></blockquote><blockquote><p>HTTP/1.0 不支持 Host 头域，因为 1.0 认为一个 ip 只绑定一个主机，通过 ip 就能确认主机，但后来一台服务器可以存在多个虚拟主机 (virtual host) 共用一个 ip 的情况，所以 1.1 添加 Host 头域显示指定主机。</p></blockquote><h3 id="URI-统一资源标识符，Uniform-Resource-Identifier"><a href="#URI-统一资源标识符，Uniform-Resource-Identifier" class="headerlink" title="URI(统一资源标识符，Uniform Resource Identifier)"></a>URI(统一资源标识符，Uniform Resource Identifier)</h3><p>URI 就是由某个协议方案表示的资源的定位标识符，这个协议可以使 htpp、https、ftp 等，比如：</p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">ftp:</span>//ftp.is.co.za/rfc/rfc1808.txt
<span class="token header-name keyword">http:</span>//www.ietf.org/rfc/rfc2396.txt
<span class="token header-name keyword">ldap:</span>//[2001:db8::7]/c=GB?objectClass?one
<span class="token header-name keyword">mailto:</span>John.Doe@example.com
<span class="token header-name keyword">news:</span>comp.infosystems.www.servers.unix
<span class="token header-name keyword">tel:</span>+1-816-555-1212 telnet://192.0.2.16:80/
<span class="token header-name keyword">urn:</span><span class="token header-name keyword">oasis:</span><span class="token header-name keyword">names:</span><span class="token header-name keyword">specification:</span><span class="token header-name keyword">docbook:</span><span class="token header-name keyword">dtd:</span><span class="token header-name keyword">xml:</span>4.1.2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>绝对 URI 的格式应该是这样的:</p><hr><p><u>http</u>://<u>user:pass</u>@<u><a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></u>:<u>80</u>/<u>dir/index.html</u>?<u>uid=1</u>#<u>ch1</u></p><p>协议:// 登录信息 @服务器地址: 端口号 / 文件路径? 查询字符串#片段标识符</p><hr><blockquote><p>与 URL(统一资源定位符，Universal Resource Locator) 和 URN(统一资源名，Uniform Resource Name) 的关系：</p></blockquote><blockquote><blockquote><p>URL 和 URN 是 URI 的两个子集，URI 唯一标识了文件资源对象 (类似身份证)，URN 标识资源名称，URL 标识资源地址</p></blockquote></blockquote><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">Response</span> <span class="token operator">=</span> Status-Line             </span><span class="token comment" spellcheck="true">// 状态行</span>
           *<span class="token punctuation">(</span><span class="token punctuation">(</span> general-header      <span class="token comment" spellcheck="true">// 通用首部</span>
            | response-header      <span class="token comment" spellcheck="true">// 响应首部</span>
            | entity-header <span class="token punctuation">)</span>CRLF<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 实体首部</span>
           CRLF
           <span class="token punctuation">[</span> message-body <span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/http/response.png" alt="image"></p><p>response 第一行是状态行，包含状态码 Status-Code，Reason-Phrase 是状态码的简单文本描述 (比如 200 - OK、404 - Not Found)</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">Status-Line</span> <span class="token operator">=</span> HTTP-Version SP Status-Code SP Reason-Phrase CRLF</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Status-Code:</p><ul><li>1xx: 信息性——收到请求，继续处理</li><li>2xx: 成功性——成功收到、理解并接受行动</li><li>3xx: 重定向——必须采取进一步行动来完成请求</li><li>4xx: 客户端错误——请求包含错误语法或不能完成</li><li>5xx: 服务器错误——服务器没有成功完成显然有效的请求</li></ul><h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><p>HTTP 消息的 message-body（如果存在）用于挟带与请求或响应相关联的 entity-body.<br>message-body 只有在应用了 transfer-coding 时，通过 Transfer-Encoding 头部域指出，与 entity-body 不同。</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">message-body</span> <span class="token operator">=</span> entity-body | <span class="token operator">&lt;</span>entity-body encoded as per Transfer-Encoding<span class="token operator">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><p>这里只列举了 2616 中提到的头部域，还有很多新添加的头部域，可以自行查找</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">general-header</span> <span class="token operator">=</span> Cache-Control      </span><span class="token comment" spellcheck="true">// 控制缓存的行为，比如 `private, max-age=0, no-cache`</span>
                | Connection        <span class="token comment" spellcheck="true">// 控制不再转发给代理的首部字段或者管理持久连接 (Keep-Alive 或者 close)</span>
                | Date              <span class="token comment" spellcheck="true">// 表明创建 HTTP 报文的日期和时间</span>
                | Pragma            <span class="token comment" spellcheck="true">// 唯一字段 `no-cache`，用于兼容 HTTP/1.1 之前的版本，客户端会要求所有的中间服务器不返回缓存的资源</span>
                | Trailer           <span class="token comment" spellcheck="true">// 事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码</span>
                | Transfer-Encoding <span class="token comment" spellcheck="true">// 规定了传输报文主体时采用的编码方式，比如 `chunked`</span>
                | Upgrade           <span class="token comment" spellcheck="true">// 检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade</span>
                | Via               <span class="token comment" spellcheck="true">// 追踪客户端与服务器之间的请求和响应报文 的传输路径</span>
                | Warning           <span class="token comment" spellcheck="true">// 从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告，字段格式:`[警告码][警告的主机: 端口号]“[警告内容]”([日期时间])`</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">request-header</span> <span class="token operator">=</span> Accept               </span><span class="token comment" spellcheck="true">// 通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级（可用权重 q=0~1 来表示相对优先级）。可使用 type/subtype 这种形式，一次指定多种媒体类型，支持通配符。例如 `text/html, text/plain, text/css, image/jpeg, video/mpeg, application/zip` 等</span>
                | Accept-Charset      <span class="token comment" spellcheck="true">// 通知服务器用户代理支持的字符集及字符集的相对优先顺序，可一次性指定多种字符集</span>
                | Accept-Encoding     <span class="token comment" spellcheck="true">// 告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码，例如: `gzip, compress, deflate, identity`</span>
                | Accept-Language     <span class="token comment" spellcheck="true">// 告知服务器用户代理能够处理的自然语言集及优先级顺序，例如: `zh-cn,zh;q=0.7,en-us,en;q=0.3` 优先返回中文版响应</span>
                | Authorization       <span class="token comment" spellcheck="true">// 告知服务器，用户代理的认证信息（证书值），例如: `Basic dWVub3NlbjpwYXNzd29yZA==`</span>
                | Expect              <span class="token comment" spellcheck="true">// 告知服务器，客户端期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</span>
                | From                <span class="token comment" spellcheck="true">// 告知服务器使用用户代理的用户的电子邮件地址</span>
                | Host                <span class="token comment" spellcheck="true">// Host 会告知服务器，请求的资源所处的互联网主机名和端口号</span>
                | If-Match            <span class="token comment" spellcheck="true">// 只有当 If-Match 的字段值跟资源的 ETag 值匹配一致时，服务器才会接受请求，否则返回状态码 412 Precondition Failed</span>
                | If-Modified-Since   <span class="token comment" spellcheck="true">// If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器才会接受请求，否则返回状态码 304 Not Modified</span>
                | If-None-Match       <span class="token comment" spellcheck="true">// If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反</span>
                | If-Range            <span class="token comment" spellcheck="true">// 告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</span>
                | If-Unmodified-Since <span class="token comment" spellcheck="true">// 与 If-Modified-Since 的作用相反</span>
                | Max-Forwards        <span class="token comment" spellcheck="true">// 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目，服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，直接返回响应。</span>
                | Proxy-Authorization <span class="token comment" spellcheck="true">// 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</span>
                | Range               <span class="token comment" spellcheck="true">// 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。例如: `bytes=5001-10000` 表示请求获取从第 5001 字节至第 10000 字节的资源。服务器会在处理请求之后返回 206 Partial Content 的响应。无法处理该范围请求时，则返回 200 OK 的响应及全部资源。</span>
                | Referer             <span class="token comment" spellcheck="true">// 告知服务器请求的原始资源的 URI。</span>
                | TE                  <span class="token comment" spellcheck="true">// 告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</span>
                | User-Agent          <span class="token comment" spellcheck="true">// 将创建请求的浏览器和用户代理名称等信息传达给服务器</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">response-header</span> <span class="token operator">=</span> Accept-Ranges      </span><span class="token comment" spellcheck="true">// 告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可处理范围请求时指定其为 bytes，反之则指定其为 none。</span>
                | Age                <span class="token comment" spellcheck="true">// 告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</span>
                | ETag               <span class="token comment" spellcheck="true">// 告知客户端实体标签 (Entity Tag)。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。有强弱之分，弱 Etag 以 'w/' 开头。</span>
                | Location           <span class="token comment" spellcheck="true">// 将响应接收方引导至某个与请求 URI 位置不同的资源。该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</span>
                | Proxy-Authenticate <span class="token comment" spellcheck="true">// 由代理服务器所要求的认证信息发送给客户端。</span>
                | Retry-After        <span class="token comment" spellcheck="true">// 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数</span>
                | Server             <span class="token comment" spellcheck="true">// 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。例如: `Apache/2.2.6 (Unix) PHP/5.2.5`</span>
                | Vary               <span class="token comment" spellcheck="true">// 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</span>
                | WWW-Authenticate   <span class="token comment" spellcheck="true">// WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">entity-header</span> <span class="token operator">=</span> Allow              </span><span class="token comment" spellcheck="true">// 服务端通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回</span>
                | Content-Encoding <span class="token comment" spellcheck="true">// 告知客户端服务器对实体的主体部分选用的内容编码方式，字段值参见 Accept-Encoding</span>
                | Content-Language <span class="token comment" spellcheck="true">// 会告知客户端，实体主体使用的自然语言，例如: `zh-CN`</span>
                | Content-Length   <span class="token comment" spellcheck="true">// 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段</span>
                | Content-Location <span class="token comment" spellcheck="true">// 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</span>
                | Content-MD5      <span class="token comment" spellcheck="true">// 客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。无法检测出恶意篡改</span>
                | Content-Range    <span class="token comment" spellcheck="true">// 能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。例如: `bytes 5001-10000/10000`</span>
                | Content-Type     <span class="token comment" spellcheck="true">// 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。例如: `text/html; charset=UTF-8`</span>
                | Expires          <span class="token comment" spellcheck="true">// 将资源失效的日期告知客户端。当首部字段 Cache-Control 有指定 max-age 指令时，Cache-Control 优先级大于 Expires</span>
                | Last-Modified    <span class="token comment" spellcheck="true">// 指明资源最终修改的时间</span>
                | extension-header <span class="token comment" spellcheck="true">// 允许定义额外的 entity-header 域而不改变协议，但不能假设接收方认识这些域。接收方应该忽略未识别的头域，但透明代理必须转发它</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h3><h4 id="浏览器在加载资源的时，先根据-http-header-判断它是否命中强缓存"><a href="#浏览器在加载资源的时，先根据-http-header-判断它是否命中强缓存" class="headerlink" title="浏览器在加载资源的时，先根据 http header 判断它是否命中强缓存."></a>浏览器在加载资源的时，先根据 http header 判断它是否命中强缓存.</h4><ul><li>命中强缓存：浏览器直接从自己缓存中读取资源，不发送请求到服务器</li><li>不命中强缓存：浏览器发送一个请求到服务器，服务器根据资源携带的 http header 验证该资源是否命中协商缓存<ul><li>命中协商缓存：将请求返回，但不是返回该资源的数据，而是告诉浏览器可以直接从缓存中加载这个资源。</li><li>不命中协商缓存：服务器返回该资源数据</li></ul></li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/Intermediaries.png" alt="image"></p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>-【Cache-Control、Expires】: Expires 指定一个过期的时间戳 (绝对时间)，Cache-Control 指定缓存行为 (比如 max-age=604800 代表有效期为七天，是相对时间)。一般用其中一个，如果两个同时出现，Cache-Control 优先级大于 Expires。</p><blockquote><p>Cache-Control 是 http/1.1 弥补 Expires 缺陷新加入的，增加了很多行为</p></blockquote><table><thead><tr><th>Cache-Control</th><th>description</th></tr></thead><tbody><tr><td>public</td><td>资源将被客户端和代理服务器缓存</td></tr><tr><td>private</td><td>资源仅被客户端缓存, 代理服务器不缓存</td></tr><tr><td>no-store</td><td>请求和响应都不缓存 (真正地不缓存)</td></tr><tr><td>no-cache</td><td>do-not-serve-from-cache-without-revalidation，响应实际上可以缓存在本地缓存区，只是在与原服务器进行新鲜度验证之前不能返回给客户端</td></tr><tr><td>max-age</td><td>缓存资源, 但是在指定时间 (单位为秒) 后缓存过期</td></tr><tr><td>s-maxage</td><td>同上, 依赖 public 设置, 覆盖 max-age, 且只在代理服务器上有效</td></tr><tr><td>max-stale</td><td>指定时间内, 即使缓存过时, 资源依然有效</td></tr><tr><td>min-fresh</td><td>缓存的资源至少要保持指定时间的新鲜期</td></tr><tr><td>must-revalidation / proxy-revalidation</td><td>如果缓存失效, 强制重新向服务器 (或代理) 发起验证 (使用 must-revalidate 指令会忽略请求的 max-stale 指令)</td></tr><tr><td>only-if-cached</td><td>仅仅返回已经缓存的资源, 不访问源服务器, 若无缓存则返回 504 Gateway Timeout</td></tr><tr><td>no-transform</td><td>强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 Content-Encoding, Content-Range, Content-Type 字段的修改 (因此代理的 gzip 压缩将不被允许)</td></tr><tr><td>cache-extension token</td><td>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令，如果缓存服务器不能理解这个新指令，就会直接忽略</td></tr></tbody></table><p><img src="https://src.wangriyu.wang/images/blog/http/StrongCache.png" alt="image"></p><p>在控制台中可以查看读取的是本地缓存还是向服务器拉取的资源:</p><p><img src="https://src.wangriyu.wang/images/blog/http/hit%20cache.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/no%20cache.png" alt="image"></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>-【Last-Modified、If-Modified-Since】: If-Modified-Since 就是上次请求返回的 Last-Modified，服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果有变化就正常返回资源内容。如果没有变化，就返回 304 Not Modified，不返回资源内容，不更新 Last-Modified。</p><p>-【ETag、If-None-Match】: 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag（服务器根据当前请求的资源生成的一个唯一标识），这个唯一标识是一个字符串，只要资源有变化这个串就不同，服务器再次收到资源请求时，根据资源生成一个新的 ETag 和浏览器传过来 If-None-Match 比较，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化，返回 304 和 ETag 不返回资源；如果有变化，返回资源。ETag 优先级比 Last-Modified 高</p><blockquote><p>⚠️</p><ul><li>在分布式部署的时候，多台机器的 Last-Modified 必须保持一致，否则协商缓存会出问题。</li><li>分布式部署，不同的机器生成的 ETag 都会不一样， 然后协商缓存就会出问题。【如果没有搞定 ETag 一致，就先关闭掉】</li><li>协商缓存需要配合强缓存使用 【不启动强缓存，协商缓存也就不起作用】</li></ul></blockquote><p><img src="https://src.wangriyu.wang/images/blog/http/NegotiateCache.png" alt="image"></p><blockquote><p>另外浏览器的刷新 (F5 / cmd + r) 和强刷 (Ctrl + F5 / shift + cmd +r / option + cmd + r(safari)):<br>普通刷新会使用协商缓存，忽略强缓存；强刷会忽略浏览器所有缓存（并且请求头会携带 Cache-Control:no-cache 和 Pragma:no-cache，用来通知所有中间节点忽略缓存）。<br>只有从地址栏或收藏夹输入网址、点击链接等情况下，浏览器才会使用强缓存。</p></blockquote><h4 id="强校验和弱校验"><a href="#强校验和弱校验" class="headerlink" title="强校验和弱校验"></a>强校验和弱校验</h4><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP_ETag" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP_ETag</a></p><p>ETag 强校验表明资源的两个版本每个字节都是相同，并且请求头（如 Content-Language）也不能有改变。强校验允许缓存，以及字节请求部分响应合并。</p><p>ETag 弱校验表明资源的两个版本只需要语义上保持一致，忽略细微差别比如修改时间等，这意味着，他们是可以互换的，并且缓存的副本也可以被使用。因为不需要资源版本保持字节程度的相同，所以这种 ETag 不适合字节请求。如果 web 服务器要动态的生成响应，这时弱校验 ETag 比较合适。</p><p>比如使用弱验证类型，一个页面与另外一个页面只是在页脚显示的时间上有所不同，或者是展示的广告不相同，那么就会被认为是相同的。但是在使用强验证的情况下，二者是不同的。</p><p>Last-Modified 存在的问题，也是使用 Etag 的原因:</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变 (仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET</li><li>有些文档可能被修改了，但所做的修改并不重要，不需要让所有缓存都重装数据 (比如对拼写和注释的修改)</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改 (比如实时监控器)，If-Modified-Since 能检查到的粒度是秒级的，对于小于秒级的修改无法判断 (或者说 UNIX 记录 MTIME 只能精确到秒)</li><li>某些服务器不能精确的得到文件的最后修改时间；</li></ul><p>例子:</p><ul><li>强校验</li></ul><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Sat, 05 May 2018 11:28:26 GMT
<span class="token header-name keyword">ETag:</span> "aaa"
<span class="token header-name keyword">Server:</span> nginx/1.12.2
<span class="token header-name keyword">Content-Length:</span> 5
<span class="token header-name keyword">Content-Type:</span> text/html<span class="token text/html">

Hello
</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若添加了内容编码 <code>Content-Encoding: gzip</code> 后，ETag 便会改变</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Sat, 05 May 2018 11:28:26 GMT
<span class="token header-name keyword">ETag:</span> "bbb"
<span class="token header-name keyword">Server:</span> nginx/1.12.2
<span class="token header-name keyword">Content-Length:</span> 5
<span class="token header-name keyword">Content-Type:</span> text/html
<span class="token header-name keyword">Content-Encoding:</span> gzip<span class="token text/html">

Hello
</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>弱检验</li></ul><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Sat, 05 May 2018 11:28:26 GMT
<span class="token header-name keyword">ETag:</span> W/"ccc"
<span class="token header-name keyword">Server:</span> nginx/1.12.2
<span class="token header-name keyword">Content-Type:</span> text/css

.absolute-center {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若 CSS 样式做了 minify，ETag 并不会改变，因为内容并没有发生实际变化</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Sat, 05 May 2018 11:28:26 GMT
<span class="token header-name keyword">ETag:</span> W/"ccc"
<span class="token header-name keyword">Server:</span> nginx/1.12.2
<span class="token header-name keyword">Content-Type:</span> text/css

.absolute-center{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%)}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时客户端发起 <code>If-None-Match</code> 请求，服务端还是会响应 304 Not Modified，客户端继续读取之前未 minify 的缓存</p><h4 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h4><ul><li>Age: 告知客户端，源服务器在多久前创建了响应。若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应已过时间</li></ul><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Age:</span>2383321
<span class="token header-name keyword">Date:</span>Wed, 08 Mar 2017 16:12:42 GMT
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代理服务器在 2017 年 3 月 8 日 16:12:42 时向源服务器发起了对该资源的请求, 目前已缓存了该资源 2383321 秒</p><ul><li>Vary: 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，必须要从源服务器重新获取资源。</li></ul><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">Vary:</span>Accept-Encoding,User-Agent
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代理服务器将针对是否压缩和浏览器类型去缓存资源. 对于同一个 url, 就能针对 PC 和 Mobile 返回不同的缓存内容</p><ul><li>Pragma: <code>Pragma: no-cache</code> 是 http/1.1 之前的遗留版本，作用与 <code>Cache-Control: no-cache</code> 一样</li></ul><h3 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h3><p>CDN 的全称是 Content Delivery Network，即内容分发网络。将网站的内容发布到最接近用户的网络 “ 边缘 “ 的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度</p><p>CDN 缓存，也叫网关缓存、反向代理缓存。浏览器先向 CDN 网关发起 WEB 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上<br>当客户端向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向源站发出回源请求（back to the source request），从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><p>CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。</p><p>CDN 缓存时间会对“回源率”产生直接的影响。若 CDN 缓存时间较短，CDN 边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若 CDN 缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p><p>优点:</p><ul><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li><li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。</li></ul><h2 id="chunked-response"><a href="#chunked-response" class="headerlink" title="chunked response"></a>chunked response</h2><p>HTTP 1.1 默认使用的是持久连接 (Persistent Connection)，当服务器返回一个响应时连接不会关闭，如果未申明 <code>Connection: close</code> 关闭长连接，客户端会一直处于 pending 状态。</p><p>要让客户端知道这个响应到哪里结束主要有两种方式:</p><ol><li><p>在响应头上加上 <code>Content-Length</code> 显示申明实体 body 的长度，此时客户端便知道读到哪里结束，但是如果 <code>Content-Length</code> 长度短于实体长度，则内容会被截取；如果超过实体长度，客户端还是会 pending 等待后续缺省的数据。</p></li><li><p>HTTP 1.1 协议在 header 中引入 <code>Transfer-Encoding</code>，当其值为 <code>chunked</code> 时, 表明采用分块编码方式来进行报文体的传输。基本方法是将大块数据分解成多块小数据，每块都可以自定长度。</p></li></ol><p><strong>分块传输的优点:</strong></p><ul><li>HTTP 分块传输编码允许服务器为动态生成的内容以维持 HTTP 持久链接</li><li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过 HTTP 消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</li><li>HTTP 服务器有时使用压缩 （gzip 或 deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</li></ul><p><strong>格式:</strong></p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个 CRLF，然后是数据本身，最后 CRLF 结束。</p><p>最后一块是单行，由块大小（0），一些可选的填充空格，以及 CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。</p><p>消息最后以 CRLF 结尾。</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token variable-declaration"><span class="token variable">Chunked-Body</span>   <span class="token operator">=</span> <span class="token operator">*</span>chunk</span>
                 last-chunk
                 trailer
                 CRLF

<span class="token variable-declaration"><span class="token variable">chunk</span>          <span class="token operator">=</span> chunk-size <span class="token punctuation">[</span> chunk-extension <span class="token punctuation">]</span> CRLF</span>
                 <span class="token property-declaration"><span class="token property">chunk-data</span> CRLF</span>

<span class="token variable-declaration"><span class="token variable">chunk-size</span>     <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">*</span>HEX</span>

<span class="token variable-declaration"><span class="token variable">last-chunk</span>     <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span> <span class="token punctuation">[</span> chunk-extension <span class="token punctuation">]</span> CRLF</span>

<span class="token variable-declaration"><span class="token variable">chunk-extension=</span> <span class="token operator">*</span><span class="token punctuation">(</span> <span class="token string">";"</span> chunk-ext-name <span class="token punctuation">[</span> <span class="token string">"="</span> chunk-ext-val <span class="token punctuation">]</span> <span class="token punctuation">)</span></span>
<span class="token variable-declaration"><span class="token variable">chunk-ext-name</span> <span class="token operator">=</span> token</span>
<span class="token variable-declaration"><span class="token variable">chunk-ext-val</span>  <span class="token operator">=</span> token | quoted-string</span>
<span class="token variable-declaration"><span class="token variable">chunk-data</span>     <span class="token operator">=</span> <span class="token func"><span class="token function">chunk-size</span><span class="token punctuation">(</span>OCTET<span class="token punctuation">)</span></span></span>

<span class="token variable-declaration"><span class="token variable">trailer</span>        <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>entity-header CRLF<span class="token punctuation">)</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子:</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Content-Type:</span> text/plain
<span class="token header-name keyword">Transfer-Encoding:</span> chunked

25

This is the data in the first chunk

1C

and this is the second one

3

con

8

sequence

0


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token string">"This is the data in the first chunk\r\n"</span>      <span class="token punctuation">(</span>37 字符 => 十六进制<span class="token punctuation">:</span> 0x25<span class="token punctuation">)</span>
<span class="token string">"and this is the second one\r\n"</span>               <span class="token punctuation">(</span>28 字符 => 十六进制<span class="token punctuation">:</span> 0x1C<span class="token punctuation">)</span>
<span class="token string">"con"</span>                                          <span class="token punctuation">(</span>3  字符 => 十六进制<span class="token punctuation">:</span> 0x03<span class="token punctuation">)</span>
<span class="token string">"sequence"</span>                                     <span class="token punctuation">(</span>8  字符 => 十六进制<span class="token punctuation">:</span> 0x08<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后以 “0\r\n\r\n” 结束</p><p>解码数据</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token property-declaration"><span class="token property">This</span> <span class="token operator">is</span> the data <span class="token operator">in</span> the first chunk</span>
<span class="token property-declaration"><span class="token property">and</span> this <span class="token operator">is</span> the second one</span>
consequence
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际抓包数据:</p><p><img src="https://src.wangriyu.wang/images/blog/http/chunked.png" alt="image"></p><p>首部字段 <code>Trailer</code> 会事先说明在报文主体后记录了哪些首部字段，比如</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Date:</span> Tue, 03 Jul 2012 04:40:56 GMT
<span class="token header-name keyword">Content-Type:</span> text/html
...
<span class="token header-name keyword">Transfer-Encoding:</span> chunked
<span class="token header-name keyword">Trailer:</span> Expires<span class="token text/html">

...(报文主体)...

0

Expires: Tue, 28 Sep 2004 23:59:59 GMT

</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请求首部字段 <code>TE</code> 告知服务器 客户端能够处理响应的传输编码方式及相对优先级</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="noopener">RFC2616</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener">wikipedia uri</a></li><li>《图解 HTTP》</li><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">Chunked transfer encoding - 分块传输编码 wiki</a></li><li><a href="https://tools.ietf.org/html/rfc2616#section-3.6.1" target="_blank" rel="noopener">RFC 2616 - Chunked Transfer Coding</a></li><li><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">缓存机制</a></li><li><a href="https://notfalse.net/56/http-stale-response" target="_blank" rel="noopener">http cache</a></li><li><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9" target="_blank" rel="noopener">缓存策略</a></li></ul>]]></content>
    
    <summary type="html">
    
      了解 request 和 response 的报文结构，以及常见首部的作用和浏览器的缓存机制
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
      <category term="网络" scheme="https://blog.wangriyu.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>更换博客评论系统</title>
    <link href="https://blog.wangriyu.wang/2018/03-valine.html"/>
    <id>https://blog.wangriyu.wang/2018/03-valine.html</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-06-17T13:13:58.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前使用 Disqus，必须翻墙才能显示，而且 Disqus 会产生大量请求，一直想换个评论系统但是好用的好像都倒了 <em>(:зゝ∠)</em></p><p>最近无意间看到这个 Valine 评论系统，好像很好用，而且简单简洁，试了一下感觉还行，可惜少了嵌套评论。</p><h2 id="Yelee-添加方法"><a href="#Yelee-添加方法" class="headerlink" title="Yelee 添加方法"></a>Yelee 添加方法</h2><p><a href="https://valine.js.org" target="_blank" rel="noopener">Valine 配置官网</a></p><p>使用前还需要注册一个 <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> 账户，然后创建一个应用来存储管理评论内容。</p><ol><li>然后修改 Yelee 主题配置文件 <code>_config.yml</code><br>添加：</li></ol><pre class="line-numbers language-stylus"><code class="language-stylus">valine<span class="token punctuation">:</span>
  <span class="token property-declaration"><span class="token property">appid</span><span class="token punctuation">:</span> <span class="token operator">**</span><span class="token operator">*</span> # LeanCloud 应用 AppID</span>
  <span class="token property-declaration"><span class="token property">appkey</span><span class="token punctuation">:</span> <span class="token operator">**</span><span class="token operator">*</span> # LeanCloud 应用 AppKey</span>
  <span class="token property-declaration"><span class="token property">verify</span><span class="token punctuation">:</span> <span class="token boolean">false</span> # 验证码</span>
  <span class="token property-declaration"><span class="token property">notify</span><span class="token punctuation">:</span> <span class="token boolean">false</span> # 评论回复邮箱提醒</span>
  <span class="token property-declaration"><span class="token property">avatar</span><span class="token punctuation">:</span> identicon # 评论列表头像样式：<span class="token string">''</span><span class="token operator">/</span>mm<span class="token operator">/</span>identicon<span class="token operator">/</span>monsterid<span class="token operator">/</span>wavatar<span class="token operator">/</span>retro<span class="token operator">/</span>hide</span>
  <span class="token property-declaration"><span class="token property">placeholder</span><span class="token punctuation">:</span> Just do it <span class="token operator">!</span> # 评论框占位符</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>修改 <code>yelee/layout/_partial/article.ejs</code></li></ol><pre class="line-numbers language-diff"><code class="language-diff"><span class="token deleted">&lt;% if (!index &amp;&amp; post.comments){ %></span>
    &lt;% if (theme.duoshuo.on) { %>
      &lt;%- partial('comments/duoshuo', {
          key: post.path,
          title: post.title,
          url: config.url+url_for(post.path),
          }) %>
    &lt;% } else if (theme.youyan.on) { %>
        &lt;%- partial('comments/youyan') %>
    &lt;% } else if (theme.disqus.on) { %>
        &lt;%- partial('comments/disqus', {
            shortname: theme.disqus.shortname
          }) %>
    &lt;% } else if (config.disqus_shortname) { %>
        &lt;%- partial('comments/disqus', {
            shortname: config.disqus_shortname
          }) %>
<span class="token inserted">+   &lt;% } else if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %></span>
<span class="token inserted">+       &lt;%- partial('comments/valine', {</span>
<span class="token inserted">+           key: post.slug,</span>
<span class="token inserted">+           title: post.title,</span>
<span class="token inserted">+           url: config.url+url_for(post.path)</span>
<span class="token inserted">+       }) %></span>
    &lt;% } %>
<span class="token deleted">&lt;% } %></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建 <code>layout/_partial/comments/valine.ejs</code> 文件</li></ol><pre class="line-numbers language-markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>comments<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">2</span>em<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">2</span>em<span class="token punctuation">;</span> <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">0.5</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vcomment<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>comment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//cdn1.lncld.net/static/js/3.0.4/av-min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//unpkg.com/valine/dist/Valine.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>
      var notify = '&lt;%= theme.valine.notify %>' == true ? true : false;
      var verify = '&lt;%= theme.valine.verify %>' == true ? true : false;
      new Valine({
        el: '#vcomment',
        notify: notify,
        verify: verify,
        app_id: "&lt;%= theme.valine.appid %>",
        app_key: "&lt;%= theme.valine.appkey %>",
        placeholder: "&lt;%= theme.valine.placeholder %>",
        avatar:"&lt;%= theme.valine.avatar %>"
      });
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>在 <code>yelee/source/css/_partial/mobile.styl</code> 中添加</li></ol><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token id">#comments</span> </span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">10</span>/<span class="token number">16</span><span class="token punctuation">)</span>rem <span class="token number">10</span>px <span class="token important">!important</span><span class="token punctuation">;</span>
    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      将原来的 Disqus 更换为 Valine
    
    </summary>
    
      <category term="Web" scheme="https://blog.wangriyu.wang/categories/Web/"/>
    
    
      <category term="Yelee" scheme="https://blog.wangriyu.wang/tags/Yelee/"/>
    
  </entry>
  
  <entry>
    <title>GithubPages 绑定二级域名并开启 HTTPS</title>
    <link href="https://blog.wangriyu.wang/2018/01-githubpage.html"/>
    <id>https://blog.wangriyu.wang/2018/01-githubpage.html</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-创建-github-仓库"><a href="#1-创建-github-仓库" class="headerlink" title="1. 创建 github 仓库"></a>1. 创建 github 仓库</h2><p>通常使用 GithubPages 创建个人主页需要创建一个与用户名同名的 <code>XXX.github.io</code> 仓库</p><p>以我的博客为例，创建一个新仓库 <code>wangriyu.github.io</code>，上传网页文件，然后在仓库设置里开启 GitHub Pages 功能</p><p>此时应该能够在浏览器中输入 <a href="https://wangriyu.github.io" target="_blank" rel="noopener">https://wangriyu.github.io</a> 访问自己的网页了</p><p>而且 GithubPages 默认开启 HTTPS</p><h2 id="2-绑定自定义域名"><a href="#2-绑定自定义域名" class="headerlink" title="2. 绑定自定义域名"></a>2. 绑定自定义域名</h2><p>到 <a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">万网</a> 上买个喜欢的域名，比如我买了 <code>wangriyu.wang</code>(可惜买不到 <code>riyu.wang</code>)</p><p>到上面的仓库目录下添加 <code>CNAME</code> 文件，里面的内容就是我的域名，比如我的就写了二级域名 <code>blog.wangriyu.wang</code></p><p>此时 Github Pages 看起来是这样的</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/githubpages.png" alt="image"></p><p><code>Enforce HTTPS</code> 选项显示 <code>Unavailable for your site because you have a custom domain configured</code></p><p>自定义域名不提供 HTTPS 服务</p><p>此时还无法访问 <a href="http://blog.wangriyu.wang">http://blog.wangriyu.wang</a>, 需要到 DNS 服务商那配置 DNS 解析，比如阿里云的即可</p><h2 id="3-配置-DNS-解析"><a href="#3-配置-DNS-解析" class="headerlink" title="3. 配置 DNS 解析"></a>3. 配置 DNS 解析</h2><p>打开 <a href="https://home.console.aliyun.com/new#/" target="_blank" rel="noopener">阿里云的域名控制台</a>，点击自己域名的解析按钮进入 DNS 设置页，添加解析:</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/DNS.png" alt="image"></p><ul><li>记录类型中 A 类填的是 IP 地址，CNAME 类填的是域名，我们需要把 wangriyu.github.io 转向 blog.wangriyu.wang, 所以填 CNAME</li><li>主机记录填二级域名即可，‘@’ 值代表一级域名，更多选项见阿里云说明</li><li>解析路线填默认即可，如果分国内国外需要另外选择使其能够根据国内外 IP 解析到不同地址</li><li>记录值就是我们的原域名 wangriyu.github.io，如果记录类型是 A 类这里需要填 IP 地址 (可以 PING 一下得到)</li></ul><p>等待 DNS 生效即可通过 <a href="http://blog.wangriyu.wang">http://blog.wangriyu.wang</a> 访问自己的网页了，而且原本的 <a href="https://wangriyu.github.io" target="_blank" rel="noopener">https://wangriyu.github.io</a><br>也会重定向到自定义域名上</p><p>DNS 解析这里我用了二级域名 blog 访问博客，还可以添加别的二级域名，比如我用了 home 访问我的另一个仓库 <a href="https://github.com/wangriyu/homepage" target="_blank" rel="noopener">https://github.com/wangriyu/homepage</a></p><p>只要在新的仓库根目录下添加 <code>CNAME</code> 文件并写入添加的有效二级域名 (home.wangriyu.wang), 再开启 GithubPages 功能即可访问另一个主页</p><h2 id="4-实现自定义域名-HTTPS"><a href="#4-实现自定义域名-HTTPS" class="headerlink" title="4. 实现自定义域名 HTTPS"></a>4. 实现自定义域名 HTTPS</h2><h3 id="到-CloudFlare-注册一个账号，注册成功后在返回的页面中添加域名-一级域名-wangriyu-wang-，点击扫描-DNS-记录"><a href="#到-CloudFlare-注册一个账号，注册成功后在返回的页面中添加域名-一级域名-wangriyu-wang-，点击扫描-DNS-记录" class="headerlink" title="到 CloudFlare 注册一个账号，注册成功后在返回的页面中添加域名 (一级域名 wangriyu.wang)，点击扫描 DNS 记录"></a>到 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">CloudFlare</a> 注册一个账号，注册成功后在返回的页面中添加域名 (一级域名 wangriyu.wang)，点击扫描 DNS 记录</h3><p><img src="https://zhouhao.me/img/https_20170721_3.png" alt="image"></p><h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>如果 DNS 扫描不到你的解析记录，可以手动添加，与上面的添加方法类似</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/cloundflare.png" alt="image"></p><h3 id="修改域名服务器"><a href="#修改域名服务器" class="headerlink" title="修改域名服务器"></a>修改域名服务器</h3><p>我用的是万网的 DNS，所以现在要在万网的域名控制台将 DNS 服务器修改至 CloudFlare 提供的域名服务器</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/nameserver.png" alt="image"></p><p>进入万网的域名控制台，点击域名的管理按钮，修改域名 DNS 为 CloudFlare 提供的</p><p><img src="https://zhouhao.me/img/https_20170721_6.png" alt="image"></p><h3 id="回到-CloudFlare-页面，设置-SSL-为-Flexible"><a href="#回到-CloudFlare-页面，设置-SSL-为-Flexible" class="headerlink" title="回到 CloudFlare 页面，设置 SSL 为 Flexible"></a>回到 CloudFlare 页面，设置 SSL 为 Flexible</h3><p><img src="https://zhouhao.me/img/https_20170721_7.png" alt="image"></p><h3 id="添加路由重定向规则"><a href="#添加路由重定向规则" class="headerlink" title="添加路由重定向规则"></a>添加路由重定向规则</h3><p>在 <code>Page Rules</code> 里使用通配符将路由重定向到 HTTPS 的链接</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/pagerules.png" alt="image"></p><p>待设置生效后再访问 <a href="http://blog.wangriyu.wang">http://blog.wangriyu.wang</a> 就会变成 https 了</p><p>具体原理如图，cloundflare 访问原网址的服务器获取储存原网页文件，用户再访问 cloundflare 的加密连接<br>如果在控制台中 Ping 一下 CloudFlare 代理前后的网址就会发现博客 ip 变了</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/FlexibleSSL.png" alt="image"></p><p>除此之外，在 CloudFlare 控制台中还提供了很多服务，比如 js、html 等静态文件压缩，设置浏览器缓存过期时间，<br>清空 CloudFlare 服务器缓存 (强制刷新资源，避免原网页更新用户访问的还是旧资源) 等等</p><p>更多技巧见文章: <a href="https://wzfou.com/cloudflare/" target="_blank" rel="noopener">十个你可能不知道的 CloudFlare 免费 CDN 加速技巧 -SSL\DDOS\Cache</a></p><p>cloundflare 的服务很适合博客这样的静态网页，也弥补了 GithubPages 的不足</p>]]></content>
    
    <summary type="html">
    
       本文介绍如何将多个 github 项目绑定到自定义域名下，并借助 cloudflare 的服务实现自定义域名开启 https
    
    </summary>
    
      <category term="Web" scheme="https://blog.wangriyu.wang/categories/Web/"/>
    
    
      <category term="Yelee" scheme="https://blog.wangriyu.wang/tags/Yelee/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 V</title>
    <link href="https://blog.wangriyu.wang/2017/12-Dart%20V.html"/>
    <id>https://blog.wangriyu.wang/2017/12-Dart V.html</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分离-Isolates"><a href="#分离-Isolates" class="headerlink" title="分离 Isolates"></a>分离 Isolates</h2><p>现在的网页浏览器，甚至是移动平台上的，运行在多核 CPU 之上。为了充分利用多核心的优势，开发人员通常对共享内存的线程采取并行策略。然而，在共享状态下使用并发容易出错并且会使代码复杂化。<br>Dart 在代码中使用 isolates 来替代线程。每个 isolate 有自己的内存堆，以确保 isolate 的状态不能被其他任何 isolate 访问。</p><hr><h2 id="类型定义-Typedefs"><a href="#类型定义-Typedefs" class="headerlink" title="类型定义 Typedefs"></a>类型定义 Typedefs</h2><p>在 Dart 中，方法是对象，就像字符串和数字也是对象。typedef , 又被称作函数类型别名，让你可以为函数类型命名，并且该命名可以在声明字段和返回类型的时候使用。当一种函数类型被分配给一个变量的时候，typedef 会记录原本的类型信息。<br>考虑下面的代码，哪一个没有使用 typedef：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">SortedCollection</span> <span class="token punctuation">{</span>
  Function compare<span class="token punctuation">;</span>

  <span class="token function">SortedCollection</span><span class="token punctuation">(</span>int <span class="token function">f</span><span class="token punctuation">(</span>Object a<span class="token punctuation">,</span> Object b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compare <span class="token operator">=</span> f<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

 <span class="token comment" spellcheck="true">// Initial, broken implementation.</span>
 int <span class="token function">sort</span><span class="token punctuation">(</span>Object a<span class="token punctuation">,</span> Object b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  SortedCollection coll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortedCollection</span><span class="token punctuation">(</span>sort<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// All we know is that compare is a function,</span>
  <span class="token comment" spellcheck="true">// but what type of function?</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span>compare <span class="token operator">is</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 f 分配到 compare 的时候类型信息丢失了。f 的类型是 (Object, Object) → int(→ 意味着返回的)，然而 compare 的类型是方法。如果我们使用显式的名字更改代码并保留类型信息，则开发者和工具都可以使用这些信息。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">typedef</span> int <span class="token function">Compare</span><span class="token punctuation">(</span>Object a<span class="token punctuation">,</span> Object b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SortedCollection</span> <span class="token punctuation">{</span>
  Compare compare<span class="token punctuation">;</span>

  <span class="token function">SortedCollection</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>compare<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

 <span class="token comment" spellcheck="true">// Initial, broken implementation.</span>
 int <span class="token function">sort</span><span class="token punctuation">(</span>Object a<span class="token punctuation">,</span> Object b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  SortedCollection coll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortedCollection</span><span class="token punctuation">(</span>sort<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span>compare <span class="token operator">is</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span>compare <span class="token operator">is</span> Compare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>目前 typedefs 仅限于函数类型，以后可能会有所改变。</p></blockquote><p>typedefs 是简单的别名，所以它提供了一种方法来检查任何函数的类型。比如：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">typedef</span> int <span class="token function">Compare</span><span class="token punctuation">(</span>int a<span class="token punctuation">,</span> int b<span class="token punctuation">)</span><span class="token punctuation">;</span>

int <span class="token function">sort</span><span class="token punctuation">(</span>int a<span class="token punctuation">,</span> int b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>sort <span class="token operator">is</span> Compare<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// True</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h2><p>使用元数据来给你的代码提供附加信息。<br>元数据注解以 @ 字符开头，后面跟一个编译时的常量引用（例如 deprecated）或者调用常量构造器的语句。<br>所有的 Dart 代码中支持三个注解：@deprecated，@override 和 @proxy。@override 和 @proxy 的用法示例，请查看 <a href="https://www.dartlang.org/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">类的继承</a>。以下是 @deprecated 用法的示例：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Television</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// Deprecated: Use [turnOn] instead</span>
  <span class="token metadata symbol">@deprecated</span>
  <span class="token keyword">void</span> <span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// Turns the TV's power on.</span>
  <span class="token keyword">void</span> <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'on!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以定义你自己的元数据注解。下面的例子定义了一个有两个参数的 @todo 注解：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">library</span> todo<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">todo</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> String who<span class="token punctuation">;</span>
  <span class="token keyword">final</span> String what<span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function">todo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>who<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是使用 @todo 注解的例子：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'todo.dart'</span><span class="token punctuation">;</span>

<span class="token metadata symbol">@todo</span><span class="token punctuation">(</span><span class="token string">'seth'</span><span class="token punctuation">,</span> <span class="token string">'make this do something'</span><span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'do something'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>元数据可以出现在库、类、typedef、类型参数、构造器、工厂、函数、属性、参数、变量声明、import 或 export 指令之前。你可以在运行时通过反射来取回元数据。</p><hr><h2 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释 Comments"></a>注释 Comments</h2><p>Dart 支持单行注释、多行注释和文档注释。</p><ul><li><p>单行注释由 // 开始</p></li><li><p>多行注释由 /<em> 开始，由 </em>/ 结束，多行注释可以嵌套</p></li><li><p>文档注释是由 /// 或 /** 开始的多行或单行注释<br>在连续的行上使用 /// 的效果等同于多行注释。<br>在一段文档注释中，Dart 编译器忽略所有除括号内的文本。你可以使用括号来引用类、方法、属性、顶级变量、函数和参数。括号中的名字会在被文档化程序元素的词法范围内解析。<br>下面是一个引用了其它类和参数的文档注释的例子：</p></li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">/// A domesticated South American camelid (Lama glama).</span>
<span class="token comment" spellcheck="true">///</span>
<span class="token comment" spellcheck="true">/// Andean cultures have used llamas as meat and pack</span>
<span class="token comment" spellcheck="true">/// animals since pre-Hispanic times.</span>
<span class="token keyword">class</span> <span class="token class-name">Llama</span> <span class="token punctuation">{</span>
  String name<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/// Feeds your llama [Food].</span>
  <span class="token comment" spellcheck="true">///</span>
  <span class="token comment" spellcheck="true">/// The typical llama eats one bale of hay per week.</span>
  <span class="token keyword">void</span> <span class="token function">feed</span><span class="token punctuation">(</span>Food food<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">/// Exercises your llama with an [activity] for</span>
  <span class="token comment" spellcheck="true">/// [timeLimit] minutes.</span>
  <span class="token keyword">void</span> <span class="token function">exercise</span><span class="token punctuation">(</span>Activity activity<span class="token punctuation">,</span> int timeLimit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在生成的文档中， [food] 变成了指向 Food 类的 API 文档连接。</p><hr><p><strong>更多内容</strong></p><ul><li><a href="https://www.dartlang.org/articles" target="_blank" rel="noopener">文章</a></li><li><a href="https://www.dartlang.org/dart-vm/dart-by-example" target="_blank" rel="noopener">代码用法示例</a></li><li><a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart 核心库</a></li><li><a href="https://www.dartlang.org/guides/language/effective-dart" target="_blank" rel="noopener">Effective Dart</a></li><li><a href="https://www.dartlang.org/tutorials/language/futures" target="_blank" rel="noopener">Futures 教程</a></li><li><a href="https://www.dartlang.org/docs/tutorials/streams" target="_blank" rel="noopener">Streams 教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>极具性价比的 Mac 存储扩展方案</title>
    <link href="https://blog.wangriyu.wang/2017/12-MacStorageExpansion.html"/>
    <id>https://blog.wangriyu.wang/2017/12-MacStorageExpansion.html</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见-Mac-扩容方案"><a href="#常见-Mac-扩容方案" class="headerlink" title="常见 Mac 扩容方案"></a>常见 Mac 扩容方案</h2><ul><li>直接更换大容量 SSD：效果最好，速度最快，成本最高，需要专业人士操刀</li><li>外接移动硬盘：容量大速度也挺快，还算便捷但是不方便，而且占用一个 usb</li><li>外接小尺寸 U 盘：像三星这个 <a href="https://item.jd.com/2154209.html" target="_blank" rel="noopener">https://item.jd.com/2154209.html</a> ，占用空间小，速度也还行，但会占用一个 usb</li><li>利用 SD 卡槽扩展：比如创见的 <a href="https://item.jd.com/1212838.html" target="_blank" rel="noopener">JetDrive Lite</a> 扩展卡，专为 Mac 设计，速度也还可以，但是性价比一般</li><li>本文同样利用 SD 卡槽扩展但性价比远超 JetDrive Lite</li></ul><h2 id="准备物品"><a href="#准备物品" class="headerlink" title="准备物品"></a>准备物品</h2><ul><li>三星 Evo Plus UHS 高速 MicroSD 卡 - 128G，某东上活动价 249，速度和稳定性比较好，选择其他类似的 tf 卡也可以</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/SamsungEvoPlus.png" width="50%"></p><ul><li>适配 Mac SD 卡槽的卡套，某宝上几块钱一个，这东西只是转接作用，不影响速度，主要是长度问题，普通卡套插上 Mac 会突出一部分影响体验，而且需要注意不同 Mac 版本 SD 卡槽深度不一，买前请留意</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_214833.jpg" width="50%"><br><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_214954.jpg" width="50%"></p><ul><li>四合一读卡器，这个可有可无，我只是推荐一下，配合这个读卡器可以在需要转储文件时很方便的连接安卓、苹果、电脑等</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_214714.jpg" width="50%"></p><h2 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h2><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171231_210739.jpg" width="50%"></p><p>全套工具<br><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_224139.jpg" width="50%"></p><p>速度测试，读写基本稳定几十 M 每秒，普通使用足矣<br><img src="https://src.wangriyu.wang/images/blog/MacStorage/SpeedTest.png" width="50%"></p><h2 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h2><ul><li>SD 卡在速度上可靠性上不如前面那些方案，适合存储一些图片视频音乐的文件，但像系统或者比较细碎的文件经常反复读写的文件不建议存 SD 卡里</li><li>SD 卡的常见格式有 exFat、Fat32、NTFS，像我这样会在多设备间转储的，包括 Mac、Windows、Android、ios 等，SD 卡格式最好的选择是 exFat，基本都支持此格式而且支持 4g 以上的单文件，而 Fat32 兼容性最好但不支持 4g 以上的单文件</li><li>exFat 格式的 SD 卡在部分安卓设备上无法识别，我的手机就识别不了，以下方法 (没有 root 的情况) 可以通过第三方软件实现读取<br>详细步骤见视频：<br><a href="https://www.youtube.com/watch?v=Daaydbsc5_c" target="_blank" rel="noopener">How to Mount NTFS/EXFat in your Android device without root</a><br>相关软件：<ul><li>Total Commender <a href="https://play.google.com/store/apps/details?id=com.ghisler.android.TotalCommander&amp;hl=en" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.ghisler.android.TotalCommander&amp;hl=en</a></li><li>USB-Stick Plugin <a href="https://play.google.com/store/apps/details?id=de.hechler.tcplugins.usbstick&amp;hl=en" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=de.hechler.tcplugins.usbstick&amp;hl=en</a></li><li>exFat/NTFS for USB <a href="https://play.google.com/store/apps/details?id=com.paragon.tcplugins_ntfs_ro&amp;hl=en" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.paragon.tcplugins_ntfs_ro&amp;hl=en</a></li></ul></li><li>最好在 Finder 中添加一个外接 SD 设备的替身，避免点击到弹出按钮</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/finder.gif" width="50%"></p>]]></content>
    
    <summary type="html">
    
      本文通过 Mac 的 SD 卡槽扩展存储空间，方便美观而且花销相对其他方式会小很多
    
    </summary>
    
      <category term="Mac" scheme="https://blog.wangriyu.wang/categories/Mac/"/>
    
    
      <category term="Mac 存储扩展" scheme="https://blog.wangriyu.wang/tags/Mac-%E5%AD%98%E5%82%A8%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>UEFI + GPT + Win10 + Ubuntu + rEFInd</title>
    <link href="https://blog.wangriyu.wang/2017/12-Win+Ubuntu.html"/>
    <id>https://blog.wangriyu.wang/2017/12-Win+Ubuntu.html</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2018-06-17T13:17:41.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚好赶上 win10 更新 1709 和 Ubuntu 更新 17.10，心血来潮给我的 Windows 笔记本重装一下系统并加上 Ubuntu，这里记录一下过程，以留备用。我的配置是 256G SSD+1T HHD，两个系统都装在固态盘，如果需要把 Ubuntu 装在机械硬盘里，可能还需要额外做一下引导：<a href="https://www.zhihu.com/question/33461827" target="_blank" rel="noopener">https://www.zhihu.com/question/33461827</a></p><hr><h2 id="安装-win10"><a href="#安装-win10" class="headerlink" title="安装 win10"></a>安装 win10</h2><h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><ul><li>4G 以上 U 盘</li><li>win10 镜像: <a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a> MSDN-&gt; 操作系统 -&gt;Windows10,Version1709</li><li>启动盘制作工具 Rufus:<a href="http://rufus.akeo.ie/?locale=zh_CN" target="_blank" rel="noopener">http://rufus.akeo.ie/?locale=zh_CN</a></li></ul><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><ol><li>打开 rufus，选择 U 盘</li><li><code>分区方案和目标系统类型</code> 选择 <code>用于 UEFI 计算机的 GPT 分区方案</code></li><li>文件系统默认 fat32(这个不能改，uefi 只识别这个格式)</li><li>下面的 <code>创建一个启动盘使用</code> 默认选中的即是 <code>ISO 镜像</code>，然后点击右侧的磁盘图标在电脑中找到下载好的 Win10 正式版 ISO 镜像</li><li>最后点击 “开始” 按钮即可开始制作支持 UEFI 启动的 Win10 系统安装 U 盘</li></ol><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><ol><li>插上 U 盘重启电脑，进入 BIOS 选择开机启动项为自己做好的的 <code>uefi U 盘</code>，保存重启</li><li>能进入 win10 安装界面则成功了一半，如果进不去需要检查一下之前 U 盘是否写入成功，还有 bios 的 uefi 是否打开</li><li>进入 win10 安装界面，选择安装，提示输入密钥，可以先跳过</li><li>接受许可条款后，提示选择 <code>安装类型</code>，点击自定义安装进入分区界面</li></ol><p><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/partition.png" alt="iamge"></p><p>这里网上找的图，实际情况按自身需求处理，我的是驱动器 0 代表固态，1 代表机械，然后我把固态的分区全删除，在未分配的空间上新建分区，给 win10 系统盘 C 盘分配 80GB(uefi 会在系统盘的基础上自动多创建几个分区用于 uefi 引导)，再划分 100GB 做 D 盘，留 50GB 未分配的空间 (之后安装 Ubuntu)，分完区 <code>注意选中你要安装系统的盘即第一个分的 C 盘</code>，再点下一步进入正式安装</p><p>⚠️如果这里点新建，如果新建不了可能是硬盘格式不对，mbr 格式的磁盘需要先全部删除才能转成 GPT 格式，然后再新建</p><ol start="5"><li>安装完正常会自动进入系统，如果没有进去，可能得进 BIOS 把开机启动项改回系统，并退出 U 盘</li><li>进入系统，刚开始没有桌面图标可以到主题设置里找，我的电脑没有硬盘可以右键 <code>系统菜单</code> 或者 <code>我的电脑</code> 选择并进入磁盘管理给分区分配盘符，联网后系统更新会自动下载安装电脑驱动，分享一些我常年收藏的工具：<a href="https://mega.nz/#F!AOwwyaZY!iR2HEt15jl2chNbEfs6_Nw" target="_blank" rel="noopener">https://mega.nz/#F!AOwwyaZY!iR2HEt15jl2chNbEfs6_Nw</a></li></ol><hr><h2 id="安装-Ubuntu"><a href="#安装-Ubuntu" class="headerlink" title="安装 Ubuntu"></a>安装 Ubuntu</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>2G 以上的 U 盘</li><li>Ubuntu 镜像：<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">https://www.ubuntu.com/download/desktop</a></li><li>启动盘制作工具 Rufus</li><li>同样打开 Rufus，步骤同上，制作好启动盘</li></ul><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><ol><li>还是插上 U 盘改启动项进入 Ubuntu 安装界面，一样的套路</li><li>刚开始会选择 <code>try Ubuntu</code> 或者 <code>install Ubuntu</code>，那个都可以，try 就是先尝试一下然后再安装</li><li>正式进入安装程序后，出现 <code>为图形或无线硬件安装第三方软件</code> 不勾选，直接继续，避免安装过程下载东西</li><li>出现 <code>已安装 Windows10，准备如何安装 Ubuntu</code>，选择 <code>其他选项</code></li><li>出现选择分区时，选中之前留下来的 50GB 未分配的空闲空间，千万别选错了。选中后点 + 号新建分区，分区可以按下图示例 (盗的图) 进行分，/ 是 linux 根目录的空间大小、交换空间 swap 是虚拟内存大小 (按个人需求调整大小)、/boot 是启动引导的分区 (一般 200MB 足够)、/home 是给 home 目录分配独立分区并分配一定大小，也可以不分把所有空间放到根目录下<br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/2.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/3.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/4.png" alt="image"><br>⚠️分好区后 <code>安装启动引导器的设备</code> 时要选中 / boot 分区所在的设备</li><li>点安装下一步确认改动，等待安装完成</li><li>安装完退出 U 盘重启，可以选择启动项，点 Ubuntu 进 linux，点 Windows boot manager 进 win10，但这个 grub 引导界面太丑，下面会使用 rEFInd 引导</li><li>进入 Ubuntu 后一些基础设置可以参考这篇文章：<a href="http://www.jianshu.com/p/62d947731401" target="_blank" rel="noopener">http://www.jianshu.com/p/62d947731401</a></li></ol><hr><h2 id="rEFInd-引导"><a href="#rEFInd-引导" class="headerlink" title="rEFInd 引导"></a><a href="http://www.rodsbooks.com/refind/" title=" 点击访问官网 " target="_blank" rel="noopener">rEFInd</a> 引导</h2><h3 id="安装-rEFInd"><a href="#安装-rEFInd" class="headerlink" title="安装 rEFInd"></a>安装 rEFInd</h3><p>这是官网的安装简介：<br><strong>Ubuntu—Two Ubuntu-specific methods of installing rEFInd in this distribution exist:</strong></p><ul><li>Ubuntu 17.04 (“Zesty Zapus”) includes rEFInd 0.10.4. Note that, like the Debian package, this one is not signed for use with Secure Boot, but if your system includes the sbsigntool package, the installer will generate a local key for this purpose. If you want a more recent version, you can use my PPA or install my Debian package.</li><li>I’ve created a rEFInd PPA for Ubuntu. To use it, open a Terminal window and type the following commands:<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> apt-add-repository ppa:rodsmith/refind
$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update
$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> refind
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>You’ll be asked whether to install rEFInd to the ESP when you first install it. Thereafter, the rEFInd version will update along with your other software. This package is built with GNU-EFI and is not signed with a Secure Boot key; however, the install script should sign the binary with a locally-generated key if it detects that your system uses Secure Boot. Thus, if you’ve previously installed one of my binaries on a Secure Boot system and added its key as a MOK, you’ll have to add your local key when you reboot.</li></ul><p>对于 Ubuntu 而言就是关掉 BIOS 里的 <code>Secure Boot</code> 选项（最好关掉），运行上述三条命令即可安装。</p><p>安装好后，文件目录默认是 <code>/boot/efi/efi/refind</code>，我的是这样，安装方式不同可能目录也不一样。之后要修改这里面的配置文件</p><h3 id="更换引导主题"><a href="#更换引导主题" class="headerlink" title="更换引导主题"></a>更换引导主题</h3><p>找到自己想要的主题：<a href="http://www.rodsbooks.com/refind/themes.html" target="_blank" rel="noopener">http://www.rodsbooks.com/refind/themes.html</a><br>比如我用的就是 <a href="https://github.com/EvanPurkhiser/rEFInd-minimal" target="_blank" rel="noopener">Minimal theme</a></p><ol><li>找到 refind 安装目录，比如 [/boot/efi/efi/refind]</li><li>如果不存在 <code>themes</code> 则创建一个 <code>themes</code> 文件夹</li><li>在 themes 目录下创建 <code>minimal</code> 文件夹，把克隆或下载下来的主题文件拷进来</li><li>修改 refind 目录下的 refind.conf 文件，修改配置。注释里有介绍，也可以找官网的介绍，或者其他例子：<a href="https://tieba.baidu.com/p/4459857693" target="_blank" rel="noopener">https://tieba.baidu.com/p/4459857693</a></li></ol><p>我的配置是这样的，可供参考：</p><pre class="line-numbers language-stylus"><code class="language-stylus"># Minimal refind theme

# Hide user interface elements for personal preference or to increase
# security<span class="token punctuation">:</span>
#  banner      - the rEFInd title banner <span class="token punctuation">(</span>built-in or loaded via <span class="token string">"banner"</span><span class="token punctuation">)</span>
#  label       - boot option text label in the menu
#  singleuser  - remove the submenu options to boot Mac OS X in single-user
#                or verbose modes<span class="token punctuation">;</span> affects ONLY MacOS X
#  safemode    - remove the submenu option to boot Mac OS X in <span class="token string">"safe mode"</span>
#  hwtest      - the submenu option to run Apple's hardware test
#  arrows      - scroll arrows on the OS selection tag line
#  hints       - brief command summary in the menu
#  editor      - the options editor <span class="token punctuation">(</span>+, F2, or Insert on boot options menu<span class="token punctuation">)</span>
#  all         - all of the above
# Default is none of these <span class="token punctuation">(</span>all elements active<span class="token punctuation">)</span>
#
<span class="token property-declaration"><span class="token property">hideui</span> singleuser<span class="token punctuation">,</span>hints<span class="token punctuation">,</span>arrows<span class="token punctuation">,</span>badges</span>

# Set the name of a subdirectory in which icons are stored<span class="token punctuation">.</span> Icons must
# have the same names they have in the standard directory<span class="token punctuation">.</span> The directory
# name is specified relative to the main rEFInd binary's directory<span class="token punctuation">.</span> If
# an icon can't be found in the specified directory, an attempt is made
# to load it from the default directory<span class="token punctuation">;</span> thus, you can replace just some
# icons in your own directory and rely on the default for others<span class="token punctuation">.</span>
# Default is <span class="token string">"icons"</span><span class="token punctuation">.</span>
#
<span class="token property-declaration"><span class="token property">icons_dir</span> themes<span class="token operator">/</span>minimal<span class="token operator">/</span>icons</span>

# Use a custom title banner instead of the rEFInd icon and name<span class="token punctuation">.</span> The file
# path is relative to the directory where refind<span class="token punctuation">.</span>efi is located<span class="token punctuation">.</span> The color
# in the top left corner of the image is used as the background color
# for the menu screens<span class="token punctuation">.</span> Currently uncompressed BMP images with color
# depths of 24, 8, 4 or 1 bits are supported, as well as PNG images<span class="token punctuation">.</span>
#
<span class="token property-declaration"><span class="token property">banner</span> themes<span class="token operator">/</span>minimal<span class="token operator">/</span>background<span class="token operator">.</span>png</span>

# Tells rEFInd whether to display banner images pixel-for-pixel <span class="token punctuation">(</span>noscale<span class="token punctuation">)</span>
# or to scale banner images to fill the screen <span class="token punctuation">(</span>fillscreen<span class="token punctuation">)</span><span class="token punctuation">.</span> The former is
# the default<span class="token punctuation">.</span>
#
<span class="token property-declaration"><span class="token property">banner_scale</span> fillscreen</span>

# Custom images for the selection background<span class="token punctuation">.</span> There is a big one <span class="token punctuation">(</span>144 x 144<span class="token punctuation">)</span>
# for the OS icons, and a small one <span class="token punctuation">(</span>64 x 64<span class="token punctuation">)</span> for the function icons in the
<span class="token selector"># second row. If only a small image is given<span class="token punctuation">,</span> that one is also used for
# the big icons by stretching it in the middle. If only a big one is given<span class="token punctuation">,</span>
# the built-in default will be used for the small icons.
#
# Like the banner option above<span class="token punctuation">,</span> these options take a filename of an
# uncompressed BMP image file with a color depth of 24<span class="token punctuation">,</span> 8<span class="token punctuation">,</span> 4<span class="token punctuation">,</span> or 1 bits<span class="token punctuation">,</span></span>
# or a PNG image<span class="token punctuation">.</span> The PNG format is required if you need transparency
# support <span class="token punctuation">(</span>to let you <span class="token string">"see through"</span> to a full-screen banner<span class="token punctuation">)</span><span class="token punctuation">.</span>
#
<span class="token property-declaration"><span class="token property">selection_big</span>   themes<span class="token operator">/</span>rEFInd-minimal<span class="token operator">/</span>selection_big<span class="token operator">.</span>png</span>
<span class="token property-declaration"><span class="token property">selection_small</span> themes<span class="token operator">/</span>rEFInd-minimal<span class="token operator">/</span>selection_small<span class="token operator">.</span>png</span>

# Which non-bootloader tools to show on the tools line, and in what
# order to display them<span class="token punctuation">:</span>
#  shell           - the EFI shell <span class="token punctuation">(</span>requires external program<span class="token punctuation">;</span> see rEFInd
#                    documentation for details<span class="token punctuation">)</span>
#  gptsync         - the <span class="token punctuation">(</span>dangerous<span class="token punctuation">)</span> gptsync<span class="token punctuation">.</span>efi utility <span class="token punctuation">(</span>requires external
#                    program<span class="token punctuation">;</span> see rEFInd documentation for details<span class="token punctuation">)</span>
#  apple_recovery  - boots the Apple Recovery HD partition, if present
#  mok_tool        - makes available the Machine Owner Key <span class="token punctuation">(</span>MOK<span class="token punctuation">)</span> maintenance
#                    tool, MokManager<span class="token punctuation">.</span>efi, used on Secure Boot systems
#  about           - an <span class="token string">"about this program"</span> option
#  exit            - a tag to exit from rEFInd
#  shutdown        - shuts down the computer <span class="token punctuation">(</span>a bug causes this to reboot
#                    EFI systems<span class="token punctuation">)</span>
#  reboot          - a tag to reboot the computer
#  firmware        - a tag to reboot the computer into the firmware's
#                    user interface <span class="token punctuation">(</span>ignored on older computers<span class="token punctuation">)</span>
# Default is shell,apple_recovery,mok_tool,about,shutdown,reboot,firmware
#
<span class="token property-declaration"><span class="token property">showtools</span> shutdown<span class="token punctuation">,</span>reboot</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终效果：<br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/refind.jpg" alt="image"></p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p>Ubuntu 16.04 与 Win10 双系统双硬盘安装图解 <a href="http://blog.csdn.net/fesdgasdgasdg/article/details/54183577" target="_blank" rel="noopener">http://blog.csdn.net/fesdgasdgasdg/article/details/54183577</a></p></li><li><p>最新版 Ubuntu 17.10 与 Windows 双系统安装、配置与美化教程 <a href="http://www.jianshu.com/p/62d947731401" target="_blank" rel="noopener">http://www.jianshu.com/p/62d947731401</a></p></li><li><p>rEFInd 引导教程 - refind 吧 <a href="https://tieba.baidu.com/p/4383185951?red_tag=2713770601" target="_blank" rel="noopener">https://tieba.baidu.com/p/4383185951?red_tag=2713770601</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      win10、Ubuntu 双系统安装教程，外加 rEFInd 引导美化 
    
    </summary>
    
      <category term="Computer" scheme="https://blog.wangriyu.wang/categories/Computer/"/>
    
    
      <category term="UEFI&amp;GPT" scheme="https://blog.wangriyu.wang/tags/UEFI-GPT/"/>
    
      <category term="win10&amp;Ubuntu 双系统" scheme="https://blog.wangriyu.wang/tags/win10-Ubuntu-%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="rEFInd 引导美化" scheme="https://blog.wangriyu.wang/tags/rEFInd-%E5%BC%95%E5%AF%BC%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 IV</title>
    <link href="https://blog.wangriyu.wang/2017/12-Dart%20IV.html"/>
    <id>https://blog.wangriyu.wang/2017/12-Dart IV.html</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h2><p>如果你在 API 文档寻找基本数组类型或者 List 类型，你将会看到该类型实际上为 List<e>, 其中&lt;…&gt;标记表示此表为一个泛型类型（或为参数化结构）—— 一种含有正规类型参数的类型。按照惯例，类型变量通常为单字符名称，例如 E, T, S, K 以及 V。</e></p><h3 id="为何要使用泛型？"><a href="#为何要使用泛型？" class="headerlink" title="为何要使用泛型？"></a>为何要使用泛型？</h3><p>因为在 Dart 中类型是可选的，你不一定要使用泛型。或许你想用，可是，因为一些相同的原因你会想在代码中使用其他的类型：这些类型（泛型或者其他类型）可以记录并注释你的代码，使你的意图更加清晰。</p><p>比如，如果你打算使用一个仅仅包含字符串的 List，你可以声明它为 List<string>（可理解为“字符串类型组成的 List”），通过这种方式，你的程序员同事，以及你的工具（比如 Dart 编辑器和调试模式下的 Dart 虚拟机）能检测到将一个非字符串的变量分配到 List 中很可能是错误的，这里给出一个样例：</string></p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
names<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Seth'</span><span class="token punctuation">,</span> <span class="token string">'Kathy'</span><span class="token punctuation">,</span> <span class="token string">'Lars'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ...</span>
names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在调试模式中失败 (在生产模式中成功)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外一个使用泛型的原因是为了减少代码的重复。泛型可以让你能共享多个类型的一个接口和实现方式，它在调试模式以及静态分析的错误预警中仍然很有优势。举个例子，当你在创建一个接口来缓存一个对象时：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ObjectCache</span><span class="token punctuation">{</span>
  object <span class="token function">getByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span>Object value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你发现你想要一个字符串专用的接口，所以你创建了另外一个接口：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">StringCache</span><span class="token punctuation">{</span>
  string <span class="token function">getByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span>String value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当你想要一个这种接口的数字专用的接口，又要创建不同类型的接口。<br>泛型类型可以减少你创建这些接口的麻烦。取而代之的是，你只需要创建一个带有一个类型参数的接口即可：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Cache</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>
  T <span class="token function">getByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span>T value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这个代码中，T 是一个替代类型，即占位符，你可以将他视为后续被开发者定义的类型。</p><h3 id="使用集合常量"><a href="#使用集合常量" class="headerlink" title="使用集合常量"></a>使用集合常量</h3><p>Lis 常量以及 map 常量都能被参数化，参数常量就像你已经见过的常量那样，除非你在左 方括号之前添加<type>(对于 List）或者&lt;keyType,valuetype&gt;(对于 map）。当你需要避免调试模式下的类型警告，你或许可以使用参数常量。这里有一个使用常量类型的例子：</type></p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token string">'Seth'</span><span class="token punctuation">,</span> <span class="token string">'Kathy'</span><span class="token punctuation">,</span> <span class="token string">'Lars'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> pages <span class="token operator">=</span> <span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">{</span>
  <span class="token string">'index.html'</span><span class="token punctuation">:</span> <span class="token string">'Homepage'</span><span class="token punctuation">,</span>
  <span class="token string">'robots.txt'</span><span class="token punctuation">:</span> <span class="token string">'Hints for web robots'</span><span class="token punctuation">,</span>
  <span class="token string">'humans.txt'</span><span class="token punctuation">:</span> <span class="token string">'We are people, not machines'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用带构造器的参数化类型"><a href="#使用带构造器的参数化类型" class="headerlink" title="使用带构造器的参数化类型"></a>使用带构造器的参数化类型</h3><p>为了在使用构造器时详细说明一个或多个类型，将类型放入类名后的三角括号（&lt;…&gt;）中，举个例子：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
names<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span>‘Seth’<span class="token punctuation">,</span> ‘Kathy’ <span class="token punctuation">,</span> ‘Lars’<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> nameSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下列代码创建了一个含有整型的键以及值为 View 的 map：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> views <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>int<span class="token punctuation">,</span>view<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="泛型集合及其包含的类型"><a href="#泛型集合及其包含的类型" class="headerlink" title="泛型集合及其包含的类型"></a>泛型集合及其包含的类型</h3><p>Dart 泛型类型是被具体化的，意思就是它们在整个运行时间中都携带着类型信息。举个例子，你可以测试一个集合中的类型甚至是在生产模式中：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
names<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Seth'</span><span class="token punctuation">,</span> <span class="token string">'Kathy'</span><span class="token punctuation">,</span> <span class="token string">'Lars'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span>names <span class="token operator">is</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然而，is 表达式检查的仅仅是集合中的类型并不是其中的对象。在生产模式下，一个 List<string>中可能含有一些非字符项，解决方法可以是逐项检查其类型或者在异常处理程序中加入数据项操作代码 (参见 <a href="">异常</a>)。</string></p><blockquote><p>相比之下，Java 中的泛型使用擦除，这意味着通用类型参数在运行时被删除。在 Java 中，您可以测试对象是否为 List，但是不能测试它是否为 List<string></string></p></blockquote><h3 id="限制参数化类型"><a href="#限制参数化类型" class="headerlink" title="限制参数化类型"></a>限制参数化类型</h3><p>实现通用类型时，可能需要限制其参数的类型。你可以使用 extends 来做到这一点</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">// T 必须是某个类或者类的后代</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">SomeBaseClass</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Extender</span> <span class="token keyword">extends</span> <span class="token class-name">SomeBaseClass</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 在&lt;>中使用某个类或者其子类都可以</span>
  <span class="token keyword">var</span> someBaseClassFoo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span>SomeBaseClass<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> extenderFoo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token operator">&lt;</span>Extender<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 不使用&lt;>也可以</span>
  <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 指定任何非 SomeBaseClass 类型会导致警告（检查模式中是运行时错误 runtime error）</span>
  <span class="token comment" spellcheck="true">// var objectFoo = new Foo&lt;Object>();</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h3><p>最初，Dart 的泛型支持仅限于类。一种较新的语法（称为泛型方法，SDK1.21 之后）允许在方法和函数上使用类型参数：</p><pre class="line-numbers language-dart"><code class="language-dart">T first<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ... 一些初始化工作或者错误检查...</span>
  T tmp <span class="token operator">=</span> ts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// ... 做一些额外的检查或处理...</span>
  <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型参数（<t>）允许你在多个位置使用类型参数 T：</t></p><ul><li>函数的返回类型 (T)</li><li>参数类型 (List<t>)</t></li><li>局部变量类型 (T tmp)<br>更多关于泛型函数，详见 <a href="https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md" target="_blank" rel="noopener">泛型方法</a></li></ul><hr><h2 id="库和可见性-Libraries-and-visibility"><a href="#库和可见性-Libraries-and-visibility" class="headerlink" title="库和可见性 Libraries and visibility"></a>库和可见性 Libraries and visibility</h2><p>import，library 指令可以帮助创建一个模块化的，可共享的代码库。库不仅提供了 API，还提供隐私单元：以下划线 ( _ ) 开头的标识符只对内部库可见。每个 Dartapp 就是一个库，即使它不使用库指令。</p><p>库可以分布式使用包。见 <a href="https://www.dartlang.org/tools/pub" target="_blank" rel="noopener">Pub Package and Asset Manager</a> 中有关 pub(SDK 中的一个包管理器）。</p><h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>使用 import 来指定如何从一个库命名空间用于其他库的范围。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'dart:html'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Dart Web 应用一般采用这个库 dart:html</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>唯一需要 import 的参数是一个指向库的 URI。对于内置库，URI 中具有特殊 dart: scheme。对于其他库，你可以使用文件系统路径或 package: scheme。包 package：scheme 指定由程序包管理器（如 pub 工具）提供的库。例如:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'dart:io'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'package:mylib/mylib.dart'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'package:utils/utils.dart'</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注：URI 代表统一资源标识符。网址（统一资源定位器）是一种常见的 URI 的。</p></blockquote><h3 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h3><p>如果导入两个库是有冲突的标识符，那么你可以指定一个或两个库的前缀。例如，如果 library1 和 library2 都有一个元素类，那么你可能有这样的代码：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'package:lib1/lib1.dart'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'package:lib2/lib2.dart'</span> <span class="token operator">as</span> lib2<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">var</span> element1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用 lib1 里的元素</span>
<span class="token keyword">var</span> element2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">lib2<span class="token punctuation">.</span>Element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 使用 lib2 里的元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="导入部分库"><a href="#导入部分库" class="headerlink" title="导入部分库"></a>导入部分库</h3><p>如果想使用的库一部分，你可以选择性导入库。例如：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">// 只导入 foo 库</span>
<span class="token keyword">import</span> <span class="token string">'package:lib1/lib1.dart'</span> show foo<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 导入所有除了 foo</span>
<span class="token keyword">import</span> <span class="token string">'package:lib2/lib2.dart'</span> hide foo<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h3><p>延迟 (deferred) 加载（也称为懒 (lazy) 加载）允许应用程序按需加载库。下面是当你可能会使用延迟加载某些情况：</p><ul><li>为了减少应用程序的初始启动时间</li><li>例如，要执行 A / B 测试 ( A/B testing) - 尝试算法的替代实现</li><li>加载很少使用的功能，例如可选的屏幕和对话框</li></ul><p>为了延迟加载一个库，你必须使用 deferred as 先导入它:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'package:deferred/hello.dart'</span> <span class="token keyword">deferred</span> <span class="token operator">as</span> hello<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当需要库时，使用该库的调用标识符调用 LoadLibrary（）:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> hello<span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hello<span class="token punctuation">.</span><span class="token function">printGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在上述代码中，await 关键字将暂停执行，直到库被加载。更多关于 async 和 await 详见 <a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p>您可以在库中多次调用 loadLibrary( )。该库仅加载一次。<br>当您使用延迟加载，要注意一下几点：</p><ul><li>延迟库的常量在其作为导入文件时不是常量。记住，这些常量不存在，直到迟库被加载完成。</li><li>你不能在导入文件中使用延迟库常量的类型。相反，考虑将接口类型移到同时由延迟库和导入文件导入的库。</li><li>Dart 隐式地将 loadLibrary（）插入到使用 deferred 作为命名空间定义的命名空间中。调用 LoadLibrary（）函数返回一个 Future 对象（类似于 JS 的 promise 对象）。</li></ul><h3 id="库的实现"><a href="#库的实现" class="headerlink" title="库的实现"></a>库的实现</h3><p>详见 <a href="https://www.dartlang.org/guides/libraries/create-library-packages" target="_blank" rel="noopener">创建库文件包</a></p><hr><h2 id="异步的支持-Asynchrony-support"><a href="#异步的支持-Asynchrony-support" class="headerlink" title="异步的支持 Asynchrony support"></a>异步的支持 Asynchrony support</h2><p>Dart 添加了一些新的语言特性用于支持异步编程。最通常使用的特性是 async 方法和 await 表达式。Dart 库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成。</p><p>当你需要使用 Future 来表示一个值时，你有两个选择：</p><ul><li>使用 async 和 await</li><li>使用 <a href="https://www.dartlang.org/guides/libraries/library-tour#future" target="_blank" rel="noopener">Future API</a></li></ul><p>同样的，当你需要从 Stream 获取值的时候，你有两个选择:</p><ul><li>使用 async 和一个异步的 for 循环 (await for)</li><li>使用 <a href="https://www.dartlang.org/guides/libraries/library-tour#stream" target="_blank" rel="noopener">Stream API</a></li></ul><p>要使用 await，代码必须用 async 标记函数:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">checkVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> version <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">lookUpVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>version <span class="token operator">==</span> expectedVersion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Do something.</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Do something else.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以使用 try, catch, 和 finally 来处理错误并清理使用了 await 的代码:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">try</span> <span class="token punctuation">{</span>
  server <span class="token operator">=</span> <span class="token keyword">await</span> HttpServer<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>InternetAddress<span class="token punctuation">.</span>LOOPBACK_IP_V4<span class="token punctuation">,</span> <span class="token number">4044</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 响应无法绑定到端口...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h3><p>一个异步函数是一个由 async 修饰符标记的函数。虽然一个异步函数可能在操作上比较耗时，但是它可以在任何方法体执行之前立即返回。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">checkVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">lookUpVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token comment" spellcheck="true">/* ... */</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数中添加关键字 async 使得它返回一个 Future 对象。<br>比如，考虑一下这个同步函数，它将返回一个字符串：<br>String lookUpVersionSync() =&gt; ‘1.0.0’;<br>更改它成为异步方法 - 因为在之后的实现中将会非常耗时 - 它的返回值是一个 Future 对象：<br>Future<string>lookUpVersion() async =&gt; ‘1.0.0’;<br>请注意函数体不需要使用 Future API，如果必要的话 Dart 将会自己创建 Future 对象。</string></p><h3 id="使用带-future-的-await-表达式"><a href="#使用带-future-的-await-表达式" class="headerlink" title="使用带 future 的 await 表达式"></a>使用带 future 的 await 表达式</h3><p>在异步方法中你可以使用 await 多次。比如，下列代码为了得到函数的结果一共等待了三次：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> entrypoint <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">findEntrypoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> exitCode <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">runExecutable</span><span class="token punctuation">(</span>entrypoint<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> <span class="token function">flushThenExit</span><span class="token punctuation">(</span>exitCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 await 表达式中， 表达式 的值通常是一个 Future 对象；如果不是，那么这个值会自动转为 Future。这个 Future 对象表明了表达式应该返回一个对象。await 表达式 的值就是返回的一个对象。在对象可用之前，await 表达式将会一直处于暂停状态。</p><p>如果 await 没有起作用，请确认它是一个异步方法。比如，在你的 main() 函数里面使用 await，main() 的函数体必须被 async 标记:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token function">checkVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'In main: version is ${await lookUpVersion()}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结合-streams-使用异步循环"><a href="#结合-streams-使用异步循环" class="headerlink" title="结合 streams 使用异步循环"></a>结合 streams 使用异步循环</h3><p>一个异步循环具有以下形式：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">await</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>variable declaration <span class="token keyword">in</span> expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 每次 stream 发出一个值时执行</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表达式 的值 the value of expression 必须有 Stream 类型（流类型）。执行过程如下：</p><ul><li>在 stream 发出一个值之前等待</li><li>执行 for 循环的主体，把变量设置为发出的值</li><li>重复 1 和 2，直到 Stream 关闭</li></ul><p>如果要停止监听 stream ，你可以使用 break 或者 return 语句，跳出循环并取消来自 stream 的订阅 。<br>如果一个异步 for 循环没有正常运行，请确认它是一个异步方法。 比如，在应用的 main() 方法中使用异步的 for 循环时，main() 的方法体必须被 async 标记：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">await</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> request <span class="token keyword">in</span> requestServer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多关于异步编程的信息，请看 <a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming" target="_blank" rel="noopener">dart:async</a> 库的介绍。<br>也可以看文章 <a href="https://www.dartlang.org/articles/language/await-async" target="_blank" rel="noopener">Dart Language Asynchrony Support: Phase 1</a> 和 <a href="https://www.dartlang.org/articles/language/beyond-async" target="_blank" rel="noopener">Dart Language Asynchrony Support: Phase 2</a> 和 <a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">the Dart language specification</a>。</p><hr><h2 id="可调用类-Callable-classes"><a href="#可调用类-Callable-classes" class="headerlink" title="可调用类 Callable classes"></a>可调用类 Callable classes</h2><p>为了允许你的 Dart 类可以像函数一样被调用，实现了 call（）方法。<br>在下面的例子中，WannabeFunction 类定义了一个 call（）函数，它需要三个字符串并用空格串联它们，并加上感叹号：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">WannabeFunction</span> <span class="token punctuation">{</span>
  <span class="token function">call</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">,</span> String c<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'$a $b $c!'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WannabeFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> out <span class="token operator">=</span> <span class="token function">wf</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">,</span><span class="token string">"there,"</span><span class="token punctuation">,</span><span class="token string">"gang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'$out'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Hi there, gang!</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多关于类函数，详见 <a href="https://www.dartlang.org/articles/language/emulating-functions" target="_blank" rel="noopener">将类用作函数</a>。</p>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>masm for mac</title>
    <link href="https://blog.wangriyu.wang/2017/11-masm.html"/>
    <id>https://blog.wangriyu.wang/2017/11-masm.html</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-06-17T12:44:06.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mac 推荐使用的汇编语法是 nasm，但学校实验用的是 masm，Windows 上有专门的 masm 编辑器，Mac 上想要编写 masm 会麻烦一点，需要用到 DOSBox 和一些编译链接文件，下面就是折腾的过程</p><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="到用户目录克隆文件"><a href="#到用户目录克隆文件" class="headerlink" title="到用户目录克隆文件"></a>到用户目录克隆文件</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~/
$ <span class="token function">git</span> clone https://github.com/wangriyu/masm-for-mac.git
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>~/masm-for-mac</code> 目录下应有以下文件，masm5 是主要的编译链接文件，DOSBox.app 提供沙盒环境，src 中有一些事例代码</p><p><img src="https://src.wangriyu.wang/images/blog/masm/files.png" alt="image"></p><h3 id="打开-DOSBox，输入-mount-指令挂载虚拟磁盘，盘符为-c，目录是克隆下来的-masm5-文件夹路径，挂载成功后输入-c-进入虚拟磁盘，再输入-dir-列出目录文件，输入-HELP-查看帮助，与-Dos-环境的命令一致"><a href="#打开-DOSBox，输入-mount-指令挂载虚拟磁盘，盘符为-c，目录是克隆下来的-masm5-文件夹路径，挂载成功后输入-c-进入虚拟磁盘，再输入-dir-列出目录文件，输入-HELP-查看帮助，与-Dos-环境的命令一致" class="headerlink" title="打开 DOSBox，输入 mount 指令挂载虚拟磁盘，盘符为 c，目录是克隆下来的 masm5 文件夹路径，挂载成功后输入 c: 进入虚拟磁盘，再输入 dir 列出目录文件，输入 HELP 查看帮助，与 Dos 环境的命令一致"></a>打开 DOSBox，输入 mount 指令挂载虚拟磁盘，盘符为 c，目录是克隆下来的 masm5 文件夹路径，挂载成功后输入 c: 进入虚拟磁盘，再输入 dir 列出目录文件，输入 HELP 查看帮助，与 Dos 环境的命令一致</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mount</span> c ~/masm-for-mac/masm5

$ c:

$ <span class="token function">dir</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/masm/mount.png" alt="image"></p><h3 id="用自己常用的文本编辑器，比如-VSCode-打开文件目录，在-masm5-下新建-asm-文件-src-中有一些事例-，用-masm-语法编写汇编代码，然后通过-masm-汇编、link-链接后就可以运行输出"><a href="#用自己常用的文本编辑器，比如-VSCode-打开文件目录，在-masm5-下新建-asm-文件-src-中有一些事例-，用-masm-语法编写汇编代码，然后通过-masm-汇编、link-链接后就可以运行输出" class="headerlink" title="用自己常用的文本编辑器，比如 VSCode 打开文件目录，在 masm5 下新建 asm 文件 (src 中有一些事例)，用 masm 语法编写汇编代码，然后通过 masm 汇编、link 链接后就可以运行输出"></a>用自己常用的文本编辑器，比如 VSCode 打开文件目录，在 masm5 下新建 asm 文件 (src 中有一些事例)，用 masm 语法编写汇编代码，然后通过 masm 汇编、link 链接后就可以运行输出</h3><pre class="line-numbers language-bash"><code class="language-bash">$ masm hello.asm
// 连按三次回车
$ <span class="token function">link</span> hello.obj
// 连按三次回车
$ hello.exe
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://src.wangriyu.wang/images/blog/masm/hello.png" alt="image"></p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><h3 id="平均数计算，连续输入十个-10-以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留-3-位小数"><a href="#平均数计算，连续输入十个-10-以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留-3-位小数" class="headerlink" title="平均数计算，连续输入十个 10 以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留 3 位小数"></a>平均数计算，连续输入十个 10 以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留 3 位小数</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/average.png" alt="average"></p><h3 id="按-15-行-X16-列的表格显示表示-ASCII-码为-10H—100H-的所有字符，即以行为主的顺序及-ASCII-码递增的次序一次显示对应的字符，每-16-个字符为一行，每行中的相邻的字符之间用空白（ASCII-为-0）隔开"><a href="#按-15-行-X16-列的表格显示表示-ASCII-码为-10H—100H-的所有字符，即以行为主的顺序及-ASCII-码递增的次序一次显示对应的字符，每-16-个字符为一行，每行中的相邻的字符之间用空白（ASCII-为-0）隔开" class="headerlink" title="按 15 行 X16 列的表格显示表示 ASCII 码为 10H—100H 的所有字符，即以行为主的顺序及 ASCII 码递增的次序一次显示对应的字符，每 16 个字符为一行，每行中的相邻的字符之间用空白（ASCII 为 0）隔开"></a>按 15 行 X16 列的表格显示表示 ASCII 码为 10H—100H 的所有字符，即以行为主的顺序及 ASCII 码递增的次序一次显示对应的字符，每 16 个字符为一行，每行中的相邻的字符之间用空白（ASCII 为 0）隔开</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test1.png" alt="test1"></p><h3 id="程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示-“No-match-”；如果句子中包含关键字则显示-“match-”，且把该字在句子中的位置用十六进制数显示出来"><a href="#程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示-“No-match-”；如果句子中包含关键字则显示-“match-”，且把该字在句子中的位置用十六进制数显示出来" class="headerlink" title="程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示 “No match!”；如果句子中包含关键字则显示 “match!”，且把该字在句子中的位置用十六进制数显示出来"></a>程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示 “No match!”；如果句子中包含关键字则显示 “match!”，且把该字在句子中的位置用十六进制数显示出来</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test2.png" alt="test2"></p><h3 id="程序接受用户键入一行字符（字符个数不超过-80-个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以-letter、digit-和-other-为名的存储单元中"><a href="#程序接受用户键入一行字符（字符个数不超过-80-个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以-letter、digit-和-other-为名的存储单元中" class="headerlink" title="程序接受用户键入一行字符（字符个数不超过 80 个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以 letter、digit 和 other 为名的存储单元中"></a>程序接受用户键入一行字符（字符个数不超过 80 个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以 letter、digit 和 other 为名的存储单元中</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test3.png" alt="test3"></p><h3 id="添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码"><a href="#添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码" class="headerlink" title="添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码"></a>添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test4.png" alt="test4"></p><h2 id="DOSBox-进阶玩法"><a href="#DOSBox-进阶玩法" class="headerlink" title="DOSBox 进阶玩法"></a>DOSBox 进阶玩法</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>在 DOSBox 输入 <code>intro special</code> 可以查看热键，比如 alt(option) + enter(return) 切换全屏，但有些键在 mac 上好像没用</p><h3 id="运行-Dos-游戏和旧应用"><a href="#运行-Dos-游戏和旧应用" class="headerlink" title="运行 Dos 游戏和旧应用"></a>运行 Dos 游戏和旧应用</h3><p>在 DOSBox 中可以运行 exe 文件，一些很老的 Dos 游戏和旧应用也可以运行，网上有很多经典游戏的资源，可以用 DOSBox 尝试下</p>]]></content>
    
    <summary type="html">
    
      mac 系统如何编写 masm 汇编 
    
    </summary>
    
      <category term="Mac" scheme="https://blog.wangriyu.wang/categories/Mac/"/>
    
    
      <category term="masm" scheme="https://blog.wangriyu.wang/tags/masm/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 III</title>
    <link href="https://blog.wangriyu.wang/2017/11-Dart%20III.html"/>
    <id>https://blog.wangriyu.wang/2017/11-Dart III.html</id>
    <published>2017-11-04T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h2><p>Dart 是一种面向对象语言，包含类和基于 mixin 的继承两部分。每个对象是一个类的实例，并且 Object 是所有类的父类。基于 mixin 的继承指的是每个类（除了 Object ）都只有一个父类，类体还可以在多个类继承中被重用。</p><p>要创建一个对象，你可以使用 new 关键词并在其后跟上一个构造函数。构造函数可以写成&lt;类名&gt;或者&lt;类名. 标识符&gt;形式。例如:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> jsonData <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token string">'{"x":1, "y":2}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 用 Point() 创建一个点。</span>
<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 用 Point().fromJson() 创建一个点。</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point<span class="token punctuation">.</span>fromJson</span><span class="token punctuation">(</span>jsonData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象的成员分为函数和数据两类（各自的方法和实例变量）。当你调用一个方法时，通过一个对象来调用它的：该方法可访问该对象的方法和数据。用 . 指向对象的方法和数据成员:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 给 y 赋值。</span>
p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 获取 y 的值。</span>
<span class="token keyword">assert</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 用 p 对象调用 distanceTo() 。</span>
num distance <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">distanceTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 使用?. 代替. 来避免操作对象为 null 时产生的异常</span>
p<span class="token operator">?</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果 p 不为空则设置 p.y 等于 4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你想对一个对象的成员进行一系列操作时，用级联操作（ cascade ）：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#button'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取一个对象。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'Confirm'</span>   <span class="token comment" spellcheck="true">// 调用他的成员。</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span>classes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'important'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span>onClick<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Confirmed!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一些类提供常量构造函数，要创建一个编译时常量构造函数，使用 const 关键字代替 new ：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token function">ImmutablePoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token function">ImmutablePoint</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token function">identical</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 他们是相同的实例！</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想在运行时获取对象的类型，可以使用 runtimeType 属性：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'The type of a is ${a.runtimeType}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>声明实例变量：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明实例变量 x ，默认值为 null 。</span>
  num y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明实例变量 y ，默认值为 null 。</span>
  num z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明实例变量 z ，初始化为 0 。</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的实例变量会自动生成一个隐式的 getter 方法。 Non-final 实例变量也会自动生成一个隐式的 setter 方法。有关详细信息，参见 <a href="https://www.dartlang.org/guides/language/language-tour#getters-and-setters" target="_blank" rel="noopener">getter&amp;setter</a>。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  point<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 用 setter 方法得到 x 。</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用 getter 方法得到 x 。</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 值为 null 。</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>要声明一个构造函数，只需创建一个与类同名的方法（或者加上一个额外的标识符命名构造函数的描述）。构造函数最常见的形式，就是自动生成的构造函数，下面创建一个类的新实例：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>

  <span class="token function">Point</span><span class="token punctuation">(</span>num x<span class="token punctuation">,</span> num y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 有个更好的方法来实现。用语法糖来设置 x，y: Point(this.x, this.y)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>默认构造函数: 如果你不声明一个构造函数，系统会提供默认构造函数。默认构造函数没有参数，它将调用父类的无参数构造函数。</p></li><li><p>子类不继承父类的构造函数。子类只有默认构造函数。（无参数，没有名字的构造函数）</p></li><li><p>命名构造函数。使用命名构造函数可以为一个类声明多个构造函数，或者说是提供额外的声明</p></li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>

  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 命名构造函数</span>
  Point<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Map json<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>调用非默认的父类的构造函数。默认情况下，在子类的构造函数将会调用父类的无参数默认构造函数。如果父类没有构造函数，则必须手动调用父类的构造函数中的一个。在冒号（：）之后、构造函数之前指定父类的构造函数（如果有的话）。</li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  String firstName<span class="token punctuation">;</span>
  Person<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Map data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'in Person'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// Person 没有默认构造函数，子类必需调用 super.&lt;命名构造函数></span>
  Employee<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Map data<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'in Employee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> emp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee<span class="token punctuation">.</span>fromJson</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 输出:</span>
  <span class="token comment" spellcheck="true">// in Person</span>
  <span class="token comment" spellcheck="true">// in Employee</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>emp <span class="token operator">is</span> Person<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 类型检查</span>
    emp<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">'Bob'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">(</span>emp <span class="token operator">as</span> Person<span class="token punctuation">)</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">'Bob'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用父类构造函数前会检测参数，这个参数可以是一个表达式作为函数调用：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ...</span>
  <span class="token function">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token function">findDefaultData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️警告：父类构造函数的参数不能访问 this 。例如，参数可调用静态方法但是不能调用实例方法。</p><hr><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>除了调用父类构造函数，你也可以在构造函数体运行之前初始化实例变量。用逗号隔开使其分别初始化。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>

  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 初始化列表在构造函数运行前设置实例变量。</span>

  Point<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>Map jsonMap<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> x <span class="token operator">=</span> jsonMap<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        y <span class="token operator">=</span> jsonMap<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'In Point.fromJson(): ($x, $y)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️警告：右手边的初始化程序无法访问 this 关键字</p><p>以下示例在初始化程序列表中初始化三个 final 字段</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'dart:math'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> num x<span class="token punctuation">;</span>
  <span class="token keyword">final</span> num y<span class="token punctuation">;</span>
  <span class="token keyword">final</span> num distanceFromOrigin<span class="token punctuation">;</span>

  <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> x <span class="token operator">=</span> x<span class="token punctuation">,</span>
        y <span class="token operator">=</span> y<span class="token punctuation">,</span>
        distanceFromOrigin <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>distanceFromOrigin<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出 3.605551275463989</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h3><p>有时一个构造函数的目的只是重定向到同一个类中的另一个构造函数。如果一个重定向的构造函数的主体为空，那么调用这个构造函数的时候，直接在冒号后面调用这个构造函数即可。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 主构造函数</span>
  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 主函数的委派</span>
  Point<span class="token punctuation">.</span><span class="token function">alongXAxis</span><span class="token punctuation">(</span>num x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>如果你的类产生的对象永远不会改变，你可以让这些对象成为编译时常量。为此，需要定义一个 const 构造函数并确保所有的实例变量都是 final 的。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">ImmutablePoint</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> num x<span class="token punctuation">;</span>
  <span class="token keyword">final</span> num y<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function">ImmutablePoint</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> ImmutablePoint origin <span class="token operator">=</span>
      <span class="token keyword">const</span> <span class="token function">ImmutablePoint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h3><p>当实现一个使用 factory 关键词修饰的构造函数时，这个构造函数不必创建类的新实例。例如，工厂构造函数可能从缓存返回实例，或者它可能返回子类型的实例。 下面的示例演示一个工厂构造函数从缓存返回的对象：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> String name<span class="token punctuation">;</span>
  bool mute <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Logger<span class="token operator">></span> _cache <span class="token operator">=</span> <span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Logger<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  _cache 是一个私有库，因为名字前有个 _</span>

  <span class="token keyword">factory</span> <span class="token function">Logger</span> <span class="token punctuation">(</span>String name<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> _cache<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">final</span> logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Logger<span class="token punctuation">.</span>_internal</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      _cache<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> logger<span class="token punctuation">;</span>
      <span class="token keyword">return</span> logger<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  Logger<span class="token punctuation">.</span><span class="token function">_internal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">log</span> <span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mute<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️注：工厂构造函数不能用 this。</p><p>调用一个工厂构造函数，你需要使用 new 关键字：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">var</span> logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token string">'UI'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Button clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法就是为对象提供行为的函数。</p><ul><li>实例方法<br>对象的实例方法可以访问实例变量和 this 。以下示例中的 distanceTo() 方法是实例方法的一个例子：</li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'dart:math'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>
  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  num <span class="token function">distanceTo</span> <span class="token punctuation">(</span>Point other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> dx <span class="token operator">=</span> x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">var</span> dy <span class="token operator">=</span> y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>dx <span class="token operator">*</span> dx <span class="token operator">+</span> dy <span class="token operator">*</span> dy<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>setters 和 Getters: 是一种提供对方法属性读和写的特殊方法。每个实例变量都有一个隐式的 getter 方法，如果合适的话可以加上 setter 方法。你可以通过实现 getters 和 setters 来创建附加属性，也就是直接使用 get 和 set 关键词：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
  num left<span class="token punctuation">;</span>
  num top<span class="token punctuation">;</span>
  num width<span class="token punctuation">;</span>
  num height<span class="token punctuation">;</span>

  <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 定义两个计算属性: right and bottom</span>
  num <span class="token keyword">get</span> right             <span class="token operator">=</span><span class="token operator">></span> left <span class="token operator">+</span> width<span class="token punctuation">;</span>
      <span class="token keyword">set</span> <span class="token function">right</span><span class="token punctuation">(</span>num value<span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token operator">></span> left <span class="token operator">=</span> value <span class="token operator">-</span> width<span class="token punctuation">;</span>
  num <span class="token keyword">get</span> bottom            <span class="token operator">=</span><span class="token operator">></span> top <span class="token operator">+</span> height<span class="token punctuation">;</span>
      <span class="token keyword">set</span> <span class="token function">bottom</span><span class="token punctuation">(</span>num value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> top <span class="token operator">=</span> value <span class="token operator">-</span> height<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> rect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>rect<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  rect<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>rect<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借助于 getter 和 setter，你可以直接使用实例变量，并且在不改变客户代码的情况下把他们包装成方法。</p><p>⚠️注：不论是否显式地定义了一个 getter，类似增量（++）的操作符，都能以预期的方式工作。为了避免产生任何向着不期望的方向的影响，操作符一旦调用 getter ，就会把他的值存在临时变量里。</p><ul><li>抽象方法<br>Instance，getter 和 setter 方法可以是抽象的，也就是定义一个接口，但是把实现交给其他的类。要创建一个抽象方法，使用分号 (;) 代替方法体：</li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Doer</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ... 定义实例变量和方法...</span>
  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义一个抽象方法，没有 body</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">EffectiveDoer</span> <span class="token keyword">extends</span> <span class="token class-name">Doer</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ... 提供一个实现，所以这里的方法不是抽象的...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用抽象方法会导致运行时错误。</p><hr><h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>你可以重写在下表中列出的操作符。例如，如果你定义了一个向量类，你可以定义一个 + 方法来加两个向量。</p><table><thead><tr><th style="text-align:center">&lt;</th><th style="text-align:center">+</th><th style="text-align:center">I</th><th style="text-align:center">[ ]</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">/</td><td style="text-align:center">^</td><td style="text-align:center">[ ]=</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">~/</td><td style="text-align:center">&amp;</td><td style="text-align:center">~</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">*</td><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">==</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">%</td><td style="text-align:center">&gt;&gt;</td></tr></tbody></table><p>以下是一个类中重写 + 和 - 操作符的例子：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Vector</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> int x<span class="token punctuation">;</span>
  <span class="token keyword">final</span> int y<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 重写 + (a + b).</span>
  Vector <span class="token keyword">operator</span> <span class="token operator">+</span><span class="token punctuation">(</span>Vector v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 重写 - (a - b).</span>
  Vector <span class="token keyword">operator</span> <span class="token operator">-</span><span class="token punctuation">(</span>Vector v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// v == (2, 3)</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// v + w == (4, 5)</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>v <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// v - w == (0, 1)</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">-</span> w<span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>v <span class="token operator">-</span> w<span class="token punctuation">)</span><span class="token punctuation">.</span>y <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dart 中的每个对象自动提供一个整数哈希码，因此可以用作 map 的一个键。但是，你可以重写 hashCode getter 来生成自定义哈希码。如果你这样做，你可能也想重写 == 运算符。相等的（通过 ==）的对象必须具有相同的哈希码。哈希码不一定是唯一的，但是它具有良好的分布性。<br>重写 == 和 hashCode 例子:</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> String firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">;</span>

  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 使用 Effective Java 中的策略重写 hashCode</span>
  int <span class="token keyword">get</span> hashCode <span class="token punctuation">{</span>
    int result <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token number">37</span> <span class="token operator">*</span> result <span class="token operator">+</span> firstName<span class="token punctuation">.</span>hashCode<span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token number">37</span> <span class="token operator">*</span> result <span class="token operator">+</span> lastName<span class="token punctuation">.</span>hashCode<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 如果重写了 hashCode，一般也要实现‘==''</span>
  bool <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is!</span> Person<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    Person person <span class="token operator">=</span> other<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>person<span class="token punctuation">.</span>firstName <span class="token operator">==</span> firstName <span class="token operator">&amp;&amp;</span> person<span class="token punctuation">.</span>lastName <span class="token operator">==</span> lastName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'smith'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'smith'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token string">'not a person'</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>hashCode <span class="token operator">==</span> p2<span class="token punctuation">.</span>hashCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多关于重载的信息，详见 <a href="https://www.dartlang.org/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">扩展一个类</a></p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用 abstract 修饰符来定义一个抽象类，该类不能被实例化。抽象类在定义接口的时候非常有用，实际上抽象中也包含一些实现。如果你想让你的抽象类被实例化，请定义一个 工厂构造函数。</p><p>抽象类通常包含 抽象方法。下面是声明一个含有抽象方法的抽象类的例子：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">// 这个类是抽象类，因此不能被实例化。</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractContainer</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ... 定义构造函数，域，方法...</span>
  <span class="token keyword">void</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 抽象方法。</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的类不是抽象类，因此它可以被实例化，即使定义了一个抽象方法：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">SpecializedContainer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractContainer</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ... 定义更多构造函数，域，方法...</span>
  <span class="token keyword">void</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ... 实现 updateChildren()...</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 抽象方法造成一个警告，但是不会阻止实例化。</span>
  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类隐式的定义了一个接口，含有类的所有实例和它实现的所有接口。如果你想创建一个支持类 B 的 API 的类 A，但又不想继承类 B ，那么，类 A 应该实现类 B 的接口。<br>一个类实现一个或更多接口通过用 implements 子句声明，然后提供 API 接口要求。例如：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token comment" spellcheck="true">// 一个 person 类 ，包含 greet() 的隐式接口。</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 在这个接口中，只有库中可见。</span>
  <span class="token keyword">final</span> _name<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 不在接口中，因为这是个构造函数。</span>
  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 在这个接口中。</span>
  String <span class="token function">greet</span><span class="token punctuation">(</span>who<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'Hello, $who. I am $_name.'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//  Person 接口的一个实现。</span>
<span class="token keyword">class</span> <span class="token class-name">Imposter</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 我们不得不定义它，但不用它。</span>
  <span class="token keyword">final</span> _name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>

  String <span class="token function">greet</span><span class="token punctuation">(</span>who<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'Hi $who. Do you know who I am?'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">greetBob</span><span class="token punctuation">(</span>Person person<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> person<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">greetBob</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'kathy'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Hello, bob. I am kathy.</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token function">greetBob</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Imposter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Hi bob. Do you know who I am?</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个类实现多个接口的例子：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token punctuation">,</span> Location <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="扩展一个类"><a href="#扩展一个类" class="headerlink" title="扩展一个类"></a>扩展一个类</h3><p>使用 extends 创建一个子类，同时 supper 将指向父类：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Television</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_illuminateDisplay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_activateIrSensor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SmartTelevision</span> <span class="token keyword">extends</span> <span class="token class-name">Television</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_bootNetworkInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_initializeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_upgradeApps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="重写成员"><a href="#重写成员" class="headerlink" title="重写成员"></a>重写成员</h3><p>子类可以重载实例方法，getters 方法，setters 方法。可以使用 @override 注释来显示地表明你要重写的成员：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">SmartTelevision</span> <span class="token keyword">extends</span> <span class="token class-name">Television</span> <span class="token punctuation">{</span>
  <span class="token metadata symbol">@override</span>
  <span class="token keyword">void</span> <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以使用 covariant 关键字来缩小类型安全代码中方法参数或实例变量的类型范围。<br>在一些（很少见到）的编码模式中使用子类型重写一个参数类型来缩小类型范围，这在强模式 Dart 中是非法的。在这种情况下，您可以使用协变关键字 covariant 告诉分析器您正在进行此操作。这将删除静态错误，而在运行时检查无效的参数类型。<br>下面是使用 covariant 的例子：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'package:meta/meta.dart'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">chase</span><span class="token punctuation">(</span>Animal x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Mouse</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">chase</span><span class="token punctuation">(</span>covariant Mouse x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>covariant 关键字可以放置在父类或子类方法中, 通常，父类方法是放置它的最佳方法。covariant 关键字适用于单个参数，并且支持 setters 和 fields。</p><hr><h3 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h3><p>当代码试图用不存在的方法或实例变量时，这个方法会被调用。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果你不重写 noSuchMethod 方法，就用一个不存在的成员，会导致 NoSuchMethodError 错误。</span>
  <span class="token keyword">void</span> <span class="token function">noSuchMethod</span> <span class="token punctuation">(</span>Invocation mirror<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'You tried to use a non-existent member:'</span> <span class="token operator">+</span>
          <span class="token string">'${mirror.memberName}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你用 noSuchMethod() 实现每一个可能的 getter 方法，setter 方法和类的方法，那么你可以使用 @proxy 标注来避免警告。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token metadata symbol">@proxy</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">noSuchMethod</span><span class="token punctuation">(</span>Invocation mirror<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于注释 annotations，详见 <a href="https://www.dartlang.org/guides/language/language-tour#metadata" target="_blank" rel="noopener">元数据 MetaData</a></p><hr><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型，通常被称为 enumerations 或 enums ，是一种用来代表一个固定数量的常量的特殊类。</p><ul><li>使用枚举<br>声明一个枚举类型需要使用关键字 enum ：</li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  red<span class="token punctuation">,</span>
  green<span class="token punctuation">,</span>
  blue
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在枚举中每个值都有一个 index getter 方法，它返回一个在枚举声明中从 0 开始的位置。例如，第一个值索引值为 0，第二个值索引值为 1。</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">assert</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>red<span class="token punctuation">.</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>green<span class="token punctuation">.</span>index <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>blue<span class="token punctuation">.</span>index <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 要得到枚举列表的所有值，可使用枚举的 values 常量</span>
List<span class="token operator">&lt;</span>Color<span class="token operator">></span> colors <span class="token operator">=</span> Color<span class="token punctuation">.</span>values<span class="token punctuation">;</span>
<span class="token keyword">assert</span><span class="token punctuation">(</span>colors<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> Color<span class="token punctuation">.</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在 switch 语句 中使用枚举。如果 e 在 switch (e) 是显式类型的枚举，那么如果你不处理所有的枚举值将会弹出警告：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">enum</span> Color <span class="token punctuation">{</span>
  red<span class="token punctuation">,</span>
  green<span class="token punctuation">,</span>
  blue
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ...</span>
Color aColor <span class="token operator">=</span> Color<span class="token punctuation">.</span>blue<span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>aColor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> Color<span class="token punctuation">.</span>red<span class="token punctuation">:</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'Red as roses!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> Color<span class="token punctuation">.</span>green<span class="token punctuation">:</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'Green as grass!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 如果没有这个分句，将会弹出警告</span>
    <span class="token function">print</span><span class="token punctuation">(</span>aColor<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 'Color.blue'</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>枚举类型有以下限制</p><ol><li>你不能在子类中混合或实现一个枚举</li><li>你不能显式实例化一个枚举</li></ol><hr><h3 id="为类添加特征：mixins"><a href="#为类添加特征：mixins" class="headerlink" title="为类添加特征：mixins"></a>为类添加特征：mixins</h3><p>mixins 是一种多类层次结构的类的代码重用。<br>要使用 mixins ，在 with 关键字后面跟一个或多个 mixin 的名字。下面的例子显示了两个使用 mixins 的类：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Musician</span> <span class="token keyword">extends</span> <span class="token class-name">Performer</span> <span class="token keyword">with</span> Musical <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Maestro</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">with</span> Musical<span class="token punctuation">,</span> Aggressive<span class="token punctuation">,</span> Demented <span class="token punctuation">{</span>
  <span class="token function">Maestro</span><span class="token punctuation">(</span>String maestroName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> maestroName<span class="token punctuation">;</span>
    canConduct <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要实现 mixin ，就创建一个继承 Object 类的子类，不声明任何构造函数，不调用 super。例如：</p><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Musical</span> <span class="token punctuation">{</span>
  bool canPlayPiano <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  bool canCompose <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  bool canConduct <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">entertainMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>canPlayPiano<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'Playing piano'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>canConduct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'Waving hands'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'Humming to self'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从 1.13 起，Dart VM 已经取消了对 mixin 的两个限制：</p><blockquote><ol><li>Mixins 允许继承自类 class，不局限于 Object</li><li>Mixins 可以调用 super（）<br>“super mixins” 在 dart2js 不受支持，并且需要在 dartanalyzer 中使用 –supermixin 标签。更多关于 mixins，详见 <a href="https://www.dartlang.org/articles/language/mixins" target="_blank" rel="noopener">Mixins in Dart</a></li></ol></blockquote></blockquote><h3 id="类的变量和方法"><a href="#类的变量和方法" class="headerlink" title="类的变量和方法"></a>类的变量和方法</h3><p>使用 static 关键字来实现类变量和类方法。</p><ul><li>静态变量<br>静态变量（类变量）对于类状态和常数是有用的：</li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> red <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一个恒定的静态变量</span>
  <span class="token keyword">final</span> String name<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 一个实例变量。</span>
  <span class="token keyword">const</span> <span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一个恒定的构造函数。</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>red<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有当静态变量被调用时才被初始化。</p><ul><li>静态方法<br>静态方法（类方法）不在一个实例上进行操作，因而不必访问 this 。例如：</li></ul><pre class="line-numbers language-dart"><code class="language-dart"><span class="token keyword">import</span> <span class="token string">'dart:math'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  num x<span class="token punctuation">;</span>
  num y<span class="token punctuation">;</span>
  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">static</span> num <span class="token function">distanceBetween</span><span class="token punctuation">(</span>Point a<span class="token punctuation">,</span> Point b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> dx <span class="token operator">=</span> a<span class="token punctuation">.</span>x <span class="token operator">-</span> b<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token keyword">var</span> dy <span class="token operator">=</span> a<span class="token punctuation">.</span>y <span class="token operator">-</span> b<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>dx <span class="token operator">*</span> dx <span class="token operator">+</span> dy <span class="token operator">*</span> dy<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> distance <span class="token operator">=</span> Point<span class="token punctuation">.</span><span class="token function">distanceBetween</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span>distance <span class="token operator">&lt;</span> <span class="token number">2.9</span> <span class="token operator">&amp;&amp;</span> distance <span class="token operator">></span> <span class="token number">2.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以将静态方法作为编译时常量。例如，你可以把静态方法作为一个参数传递给静态构造函数。</p>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
</feed>
