<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wangriyu’s Blog</title>
  <subtitle>子非鱼，安知鱼之乐也！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.wangriyu.wang/"/>
  <updated>2018-06-09T09:04:09.245Z</updated>
  <id>https://blog.wangriyu.wang/</id>
  
  <author>
    <name>鱼乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构 - 树</title>
    <link href="https://blog.wangriyu.wang/2018/06-Tree.html"/>
    <id>https://blog.wangriyu.wang/2018/06-Tree.html</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-06-09T09:04:09.245Z</updated>
    
    <content type="html"><![CDATA[<p>与数据库相关的树结构主要为 B 类树，B 类树通常用于数据库和操作系统的文件系统</p><p>在学习 B 类树之前先复习一下二叉查找树的概念和红黑树</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树 - Binary Tree</a> 是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>完美二叉树 (Perfect Binary Tree): 除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充</li><li>完全二叉树 (Complete Binary Tree): 除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐</li><li>满二叉树 (Full/Strictly Binary Tree): 除了叶子结点之外的每一个结点都有两个孩子结点</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li>前序遍历: 首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树</li><li>中序遍历: 首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，再访问根结点，最后遍历右子树</li><li>后序遍历: 首先遍历左子树，然后遍历右子树，最后访问根结点。在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点</li></ul><ul><li>深度优先搜索: 顾名思义，查找时深度优先，从根结点访问最远的结点直到找到所有节点。前序，中序和后序遍历都是深度优先遍历的特例</li><li>广度优先搜索: 广度优先遍历会先访问离根节点最近的节点，二叉树的广度优先遍历又称按层次遍历。算法借助队列实现</li></ul><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">二叉查找树 - Binary Search Tree</a>: 也称二叉搜索树、有序二叉树。对于根树和所有子树都满足，每个节点都大于左子树元素，而小于右子树元素，<strong>且没有键值相等的结点</strong></p><p>搜索、插入、删除的复杂度等于<strong>树高</strong>，期望 $O(\log_2^n)$，最坏 O(n)（数列有序，树退化成线性表）</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>当数据基本有序时，二叉查找树会退化成线性表，查找效率严重下降</p><p>所以后面出现了很多改进的<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91" target="_blank" rel="noopener">平衡树</a>结构以满足树高最坏也为 $O(\log_2^n)$，<br>如<a href="https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A0%91" target="_blank" rel="noopener">伸展树 (Splay Tree)</a>、平衡二叉树 (SBT)、<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">AVL 树</a>、红黑树等</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树 - Red–black tree</a> 是一种自平衡二叉查找树，除了符合二叉查找树的性质外，它还满足以下五条性质:</p><ol><li>每个结点要么是红的，要么是黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的（叶子结点指树尾端 NIL 指针或 NULL 结点，不包含数据，只充当树在此结束的指示）</li><li>如果一个结点是红的，那么它的两个子节点都是黑的 (从根到每个叶子的所有路径上不能有两个连续的红色节点)</li><li>对于任一结点而言，其到叶结点树尾端 NIL 指针的每一条路径都包含相同数目的黑结点</li></ol><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-0.svg" alt="一棵红黑树"></p><h3 id="平衡优势"><a href="#平衡优势" class="headerlink" title="平衡优势"></a>平衡优势</h3><p>上述约束确保了红黑树的关键特性: <strong>从根到叶子的最长路径不会超过最短路径的两倍</strong></p><p>证明: 主要看性质 4 和 性质 5，假设从根到叶子的最短路径 a 上有黑色节点 n 个，最长路径 b 肯定是交替的红色和黑色节点，而根据性质 5 可知从根到叶子的所有路径都有相同数目的黑色节点，<br>这就表明 b 的黑色节点也为 n 个，但 b 出现的红色节点不可能超过黑色节点个数，否则会破坏性质 4 (抽屉原理)，所以从根到叶子的最长路径不会超过最短路径的两倍</p><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。<br>恢复红黑树的性质需要少量 $O(\log_2^n)$ 的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为 $O(\log_2^n)$ 次。</p><p>红黑树发生变更时需要 [变色] 和 [旋转] 来调整，其中旋转又分 [左旋] 和 [右旋]。</p><ul><li>变色就是更改颜色</li><li>左旋: 以 X 为支点<code>逆时针</code>旋转红黑树的两个节点 X-Y，使得父节点被自己的右孩子取代，而自己下降为左孩子</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/left.svg" alt="左旋"></p><ul><li>右旋: 以 X 为支点<code>顺时针</code>旋转红黑树的两个节点 X-Y，使得父节点被自己的左孩子取代，而自己下降为右孩子</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/right.svg" alt="右旋"></p><p>旋转过程中只需要做三次指针变更就行</p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>插入节点的位置跟二叉查找树的寻找方法基本一致，如果插入结点 z 小于当前遍历到的结点，则到当前结点的左子树中继续查找，如果 z 大于当前结点，则到当前结点的右子树中继续查找，<br>如果 z 依然比此刻遍历到的新的当前结点小，则 z 作为当前结点的左孩子，否则作为当前结点的右孩子。而红黑树插入节点后，为了保持约束还需要进行调整修复(变色加旋转)。</p><p>所以插入步骤如下: 红黑树按二叉查找树的规则找到位置后插入新节点 z，z 的左孩子、右孩子都是叶子结点 nil， z 结点初始都为红色，再根据下述情形进行变色旋转等操作，最后达到平衡。</p><ul><li>情形 1: 如果<strong>当前节点是根结点</strong>，为满足性质 2，所以直接把此结点 z 涂为黑色</li><li>情形 2: 如果<strong>当前结点的父结点是黑色</strong>，由于不违反性质 2 和性质 4，红黑树没有被破坏，所以此时也是什么也不做</li></ul><p>比如上图插入 12 时满足情形 2:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-1.svg" alt="插入 12"></p><p>以下情形需要作出额外调整:</p><ul><li>情形 3: 如果<strong>当前结点的父结点是红色</strong>且<strong>祖父结点的另一个子结点(叔叔结点)是红色</strong></li><li>情形 4: <strong>当前结点的父结点是红色</strong>，<strong>叔叔结点是黑色</strong>或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置<strong>不在同侧</strong></li><li>情形 5: <strong>当前结点的父结点是红色</strong>，<strong>叔叔结点是黑色</strong>或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置<strong>在同侧</strong></li></ul><p>下面着重讲讲后三种情况如何调整</p><h5 id="情形-3"><a href="#情形-3" class="headerlink" title="情形 3"></a>情形 3</h5><p><code>当前结点的父结点是红色且祖父结点的另一个子结点(叔叔结点)是红色</code></p><blockquote><p>因为当前节点的父节点是红色，所以父节点不可能是根节点，当前节点肯定有祖父节点，也就有叔叔节点</p></blockquote><p><strong>解决步骤</strong>: 将当前结点的父结点和叔叔结点涂黑，祖父结点涂红，再把祖父结点当做新节点(即当前节点的指针指向祖父节点)重新检查各种情形进行调整</p><p>由于对称性，不管父结点是祖父结点的左子还是右子，当前结点是其父结点的左子还是右子，处理都是一样的</p><p>我们插入 21 这个元素，当前节点指向 21：</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-2.svg" alt="插入 21"></p><p>此时会发现 21、22 两个红色相连与性质 4 冲突，但 21 节点满足情形 3，修复后:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-3.svg" alt="调整情形 3"></p><p>此时当前节点指向 21 的祖父节点，即 25。而 25 节点同样遇到情形 3 的问题，继续修复:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-4.svg" alt="继续调整情形 3"></p><p>此时当前节点指向根节点，满足情形 1，将 14 节点涂黑即可恢复红黑树平衡</p><h5 id="情形-4"><a href="#情形-4" class="headerlink" title="情形 4"></a>情形 4</h5><p><code>当前结点的父结点是红色，叔叔结点是黑色或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置不在同侧</code></p><p><strong>解决步骤</strong>:</p><ul><li>如果当前节点是父节点的右子，父节点是祖父节点的左子，以当前结点的父结点做为新结点(即当前节点的指针指向父节点)，并作为支点左旋</li><li>如果当前节点是父节点的左子，父节点是祖父节点的右子，以当前结点的父结点做为新结点(即当前节点的指针指向父节点)，并作为支点右旋</li></ul><p>在上图的基础上我们继续插入 5 这个元素:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-5.svg" alt="插入 5"></p><p>可以看出 5 是父节点的左子，而父节点是祖父节点的右子，不同侧则为情形 4，将当前节点指向 5 的父节点 6，并以 6 为支点进行右旋:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-6.svg" alt="插入情形 4"></p><p>此时当前节点是 6，而 6 是父节点 5 的右子，父节点 5 也是祖父节点 1 的右子，同侧则转为情形 5，继续往下看</p><h5 id="情形-5"><a href="#情形-5" class="headerlink" title="情形 5"></a>情形 5</h5><p><code>当前结点的父结点是红色，叔叔结点是黑色或者 nil，当前结点相对其父结点的位置和父节点相对祖父节点的位置在同侧</code></p><p><strong>解决步骤</strong>:</p><ul><li>首先把父结点变为黑色，祖父结点变为红色</li><li>如果当前节点是父节点的左子，父节点是祖父节点的左子，以祖父结点为支点右旋</li><li>如果当前节点是父节点的右子，父节点是祖父节点的右子，以祖父结点为支点左旋</li></ul><p>在上一张图的基础上修改节点 5 为黑色，节点 1 为红色，再以 1 为支点左旋:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-7.svg" alt="插入情形 5"></p><p>此时便恢复平衡</p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除节点 X 时第一步先判断两个孩子是否都是非空的，如果都非空，就先按二叉查找树的规则处理:</p><p>在删除带有两个非空子树的节点 X 的时候，我们可以找到左子树中的最大元素(或者右子树中的最小元素)，并把这个最值<strong>复制</strong>给 X 节点，只代替原来要删除的值，不改变节点颜色。</p><p>然后我们只要删除那个被复制出值的那个节点就行，因为是最值节点所以它的孩子不可能都非空。</p><p>因为只是复制了一个值，不违反任何性质，这就把原问题转化为<strong>如何删除最多有一个非空子树的节点的问题</strong>。它不关心这个节点是最初要删除的节点还是被复制出值的那个节点。</p><p>我们以图为例，图中三角形代表可能为空的子树:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-0.svg" alt="取值复制"></p><p>节点 X 是要删除的节点，发现它的两个子树非空，我们可以找左子树中最大的元素 Max (也可以找右子树中最小的元素 Min)，把 Max 值(或者 Min 值)复制到 X 上覆盖原来的值，不修改其他属性，然后删除 Max 节点(或 Min 节点)即可，可以很清楚的看到最值节点最多只会有一个非空子树</p><hr><p>接下来就是如何处理删除最多有一个非空子树的节点 X 的问题</p><p>简单情形:</p><ol><li>如果 X 的两个儿子都为空，即均为叶子，我们将其中任意一个看作它的儿子</li><li>如果 <strong>X 是一个红色节点</strong>，它的父亲和儿子一定是黑色的，所以简单的<strong>用它的黑色儿子替换它</strong>就行，这并不会破坏性质 3 和性质 4，通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质 5</li><li>如果 <strong>X 是黑色而它的儿子是红色</strong>，如果只是删除这个黑色节点，<strong>用它的红色儿子代替</strong>的话，会破坏性质 5，我们可以<strong>重绘它的儿子为黑色</strong>，则曾经通过 X 的所有路径将通过它的黑色儿子，这样可以继续保持性质 5</li></ol><p>如果 X 和它的儿子都是黑色，这是一种复杂的情况，我们单拎出来讲</p><p>我们首先把要删除的节点 X 替换为它的儿子。出于方便，称呼这个新上位的儿子为 N，称呼它的兄弟为 S，使用 P 称呼 N 的新父亲，SL 称呼 S 的左儿子，SR 称呼 S 的右儿子</p><p>有以下六种情形需要考虑:</p><h5 id="情形-1"><a href="#情形-1" class="headerlink" title="情形 1"></a>情形 1</h5><p>N 是新的根</p><p>我们不需要做什么，因为所有路径都去除了一个黑色节点，而新根也是黑色的，所以性质都保持着</p><blockquote><p>情形 2、5、6 涉及到左右不同的情况，只取一种处理</p></blockquote><h5 id="情形-2"><a href="#情形-2" class="headerlink" title="情形 2"></a>情形 2</h5><p>S 是红色</p><ul><li>交换兄弟 S 和父亲 P 的颜色</li><li>如果 N 是其父亲的左节点，我们在 N 的父亲上做左旋，把红色兄弟转换成 N 的祖父</li><li>如果 N 是其父亲的右节点，我们在 N 的父亲上做右旋，把红色兄弟转换成 N 的祖父</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-2.svg" alt="删除情形 2"></p><p>完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在 N 有了一个黑色的兄弟和一个红色的父亲，所以我们可以接下去按情形 4、情形 5 或情形 6 来处理</p><h5 id="情形-3-1"><a href="#情形-3-1" class="headerlink" title="情形 3"></a>情形 3</h5><p>N 的父亲、S 和 S 的儿子都是黑色的</p><ul><li>重绘 S 为红色</li><li>将 P 作为新的 N，从情形 1 开始，在 P 上做平衡处理</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-3.svg" alt="删除情形 3"></p><p>在这种情形下，我们简单的重绘 S 为红色。结果是通过 S 的所有路径都少了一个黑色节点。这与删除 N 的初始父亲 X 造成通过 N 的所有路径少了一个黑色节点达成平衡。但是，通过 P 的所有路径现在比不通过 P 的路径少了一个黑色节点，所以仍然违反性质 5。要修正这个问题，我们要从情形 1 开始，在 P 上做重新平衡处理</p><h5 id="情形-4-1"><a href="#情形-4-1" class="headerlink" title="情形 4"></a>情形 4</h5><p>S 和 S 的儿子都是黑色，但是 N 的父亲是红色</p><ul><li>交换 N 的兄弟 S 和父亲 P 的颜色</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-4.svg" alt="删除情形 4"></p><p>在这种情形下，我们简单的交换 N 的兄弟和父亲的颜色。这不影响不通过 N 的路径的黑色节点的数目，但是它在通过 N 的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点</p><h5 id="情形-5-1"><a href="#情形-5-1" class="headerlink" title="情形 5"></a>情形 5</h5><p>S 是黑色，S 的其中一个儿子是红色，且红色儿子的位置与 N 相对于父亲的位置处于<strong>同侧</strong></p><ul><li>如果 N 是其父亲的左节点，S 的左儿子是红色，右儿子是黑色，则在 S 上做右旋转</li><li>如果 N 是其父亲的右节点，S 的左儿子是黑色，右儿子是红色，则在 S 上做左旋转</li><li>将 S 和它之前的红色儿子交换颜色</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-5.svg" alt="删除情形 5"></p><p>所有路径仍有同样数目的黑色节点，但是现在 N 有了一个黑色兄弟，且兄弟的一个儿子仍为红色的，其位置与 N 相对于父亲的位置处于不同侧，进入情形 6</p><blockquote><p>情形 5、6 中父节点 P 的颜色可以为黑色也可以是红色</p></blockquote><h5 id="情形-6"><a href="#情形-6" class="headerlink" title="情形 6"></a>情形 6</h5><p>S 是黑色，S 的其中一个儿子是红色，且其位置与 N 相对于父亲的位置处于<strong>不同侧</strong></p><ul><li>交换 N 的父亲 P 和 S 的颜色</li><li>如果 N 是其父亲的右节点，S 的左儿子是红色，右儿子是黑色，则在 N 的父亲上做右旋转，并使 S 的左儿子涂黑</li><li>如果 N 是其父亲的左节点，S 的左儿子是黑色，右儿子是红色，则在 N 的父亲上做左旋转，并使 S 的右儿子涂黑</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-removal-6.svg" alt="删除情形 6"></p><p>交换前 N 的父亲可以是红色也可以是黑色，交换后，N 增加了一个黑色祖先，所以通过 N 的路径都增加了一个黑色节点，S 的右子树黑色节点个数也没有变化，达到平衡</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>还是以之前的图为例</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-tree-7.svg" alt="删除"></p><p>我们自下而上开始尝试删除每一个节点:</p><ul><li><p>假如要删除元素 1，根据简单情形中的第二条，我们直接删除 1，并用一个 nil 节点代替即可，元素 6、12、21 的处理与此相同</p></li><li><p>假如要删除元素 5，因为左右子树均不为空，所以找左子树的最大值 1 (或者右子树的最小值 6)，用找到的值代替 5 (这里只是值替换，其他均不变)，然后去删除 1 节点，这就转到问题 1 上了</p></li><li><p>假如要删除元素 11，根据简单情形的第三条，我们直接删除 11，并用子节点 12 代替，同时把 12 涂黑即可，元素 22 的处理与此相同</p></li><li><p>假如要删除元素 25，因为左右子树均不为空，所以找左子树的最大值 22 (或者右子树的最小值 27)，我们这里用值 22 代替 25，颜色不变。然后去删除 22 节点，这变成上一个问题了</p></li><li><p>假如要删除元素 27，黑色的 nil 叶子节点代替 27 节点，因为兄弟节点 22 有一个红色孩子，且在左边，和 nil 节点相对父亲 25 的位置不同侧，属于情形 6，所以第一步交换 22 和 25 的颜色，再以 25 为支点做右旋转，然后将 21 节点涂黑即可</p></li><li><p>假如要删除元素 8，选择右子树最小值 11 替换 8。然后去删除节点 11，对应问题 3</p></li><li><p>假如要删除元素 17，选择左子树最大值 15 替换 17。然后去删除节点 15，过程看下一个问题</p></li><li><p>假如要删除元素 15，删除的元素和替代的元素都是黑色，这属于复杂情形。检查其类型可以匹配到情形 2，元素 15 是被移除的 X，代替它的是 nil 节点，即为 N，17 为 P，25 为 S，根据上文可知第一步先交换 P 和 S 的颜色，然后以 P 为支点进行左旋，此时 N 多了一个黑色的兄弟 22 和红色的父亲 17:</p></li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-example-0.svg" alt="删除 15"></p><p>此时 N 的兄弟 S 变为 22，P 变为 17，S 的左孩子是红色的 21，属于情形 5。S 做右旋转，并交换 22 和 21 的颜色:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-example-1.svg" alt="删除 15"></p><p>此时 N 的兄弟 S 变为黑色的 21，但 21 的红色孩子节点 22 变为右侧，进入情形 6</p><p><img src="https://src.wangriyu.wang/images/blog/tree/RB-example-2.svg" alt="删除 15"></p><p>P 节点 17 做左旋转，并将 S 的右节点涂黑，此时树恢复平衡</p><ul><li>假如要删除根节点 14，取左子树最大值 12 代替 14。然后去删除节点 12，对应问题 1</li></ul><p>至此，我们已经把节点都删了个遍，相信你对红黑树的删除操作应该了解了</p><h2 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h2><p>红黑树还是典型的二叉搜索树结构，主要应用在一些 map 和 set 类型的实现上，比如 Java 中的 TreeMap 和 C++ 的 set/map/multimap 等。其查找的时间复杂度 $O(\log_2^n)$ 与树的深度相关，降低树的深度可以提高查找效率。</p><p>但是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），<br>这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O 读写过于频繁，进而导致查询效率低下，因此我们该想办法降低树的深度，从而减少磁盘查找存取的次数。</p><p>一个基本的思想就是：采用<code>多叉树结构</code>，所以出现了下述的平衡多路查找树</p><h2 id="B-树-B-Tree"><a href="#B-树-B-Tree" class="headerlink" title="B 树 (B - Tree)"></a>B 树 (B - Tree)</h2><blockquote><p>B-树，即为 B 树，不要读作 B 减树</p></blockquote><p>B 树与红黑树最大的不同在于，B 树的结点可以有许多子女，从几个到几千个。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>B 树的定义有两种，一种以阶数为限制的 B 树(下文所述的)，一种以度数为限制的 B 树(算法导论所描述的)，两者原理类似，这里以阶数来定义</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">B 树</a>属于平衡多路查找树。一棵 m 阶(m 阶即代表树中任一结点最多含有 m 个孩子)的 B 树的特性如下:</p><ol><li>除根节点外所有节点关键字个数范围: [$\lceil\frac m2\rceil$-1, m-1]</li><li>若非叶子节点含 n 个关键字，则子树有 n+1 个，由关键字范围可知子树的个数范围: [$\lceil\frac m2\rceil$, m]</li><li>根节点至少包含一个关键字，至少有两个孩子(除非 B 树只存在一个节点: 根结点)，即根节点关键字个数范围: [1, m-1]，孩子数范围: [2, m]</li><li>所有叶子节点都处在同一层，即高度都一样</li><li>每个节点中的关键字从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域划分</li></ol><p><img src="https://src.wangriyu.wang/images/blog/tree/BTree-0.svg" alt="2-3-4 树"></p><p>如图是一个典型的 <a href="https://zh.wikipedia.org/wiki/2-3-4%E6%A0%91" target="_blank" rel="noopener">2-3-4 树</a>结构，也是阶为 4 的 B 树。从图中查询元素最多只需要 3 次磁盘 I/O 就可以访问到我们需要的数据节点，将节点数据块读入内存后再查找指定元素会很快。如果同样的数据用红黑树表示，树高会增长很多，造成遍历节点的次数增多，访问磁盘的次数增多，查找性能会下降。</p><p>对于一棵包含 n 个元素、高度为 h 、阶数为 m 的 B 树:<br>影响 B 树高度的是每个结点所包含的子树数，如果尽可能使结点孩子数都等于 $\lceil\frac m2\rceil$，则层数最多，为最坏情况；如果尽可能使结点孩子数都等于 m，则层数最少，为最好情况。所以有</p><p>$$ \log _m{(n + 1)} \leq h \leq \log _{\lceil\frac m2\rceil}{(\frac{n + 1}{2})} + 1 $$</p><p>底数 $\lceil\frac m2\rceil$ 可以取很大，比如 m 可以达到几千，从而在关键字数一定的情况下，使得最终的 h 值尽量比较小，树的高度比较低。</p><p>实际运用中 B 树中的每个结点根据实际情况可以包含大量的关键字信息和分支(但不能超过磁盘块的大小，根据磁盘驱动的不同，一般块的大小在 1k~4k 左右)；这样树的深度降低了，意味着查找一个元素只要很少的结点从外存磁盘中读入内存，就可以很快地访问到要查找的数据</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>一个节点的结构可以定义为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type BTNode struct &#123;</span><br><span class="line">  KeyNum   int       // 关键字个数，math.Ceil(m/2)-1 &lt;= KeyNum &lt; 阶数 m</span><br><span class="line">  Parent   *BTNode   // 指向父节点的指针</span><br><span class="line">  IsLeaf   bool      // 是否为叶子，叶子节点 children 为 nil</span><br><span class="line">  Key      []int     // 关键字切片，长度为 KeyNum</span><br><span class="line">  Children []*BTNode // 子节点指针切片，长度为 KeyNum+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面 2-3-4 树的根节点为例：</p><p><img src="https://src.wangriyu.wang/images/blog/tree/BTNode.svg" alt="B 树节点"></p><p> 所有数据以块的方式存储在外磁盘中，我们通过 B 树来查找数据时，每遍历到一个节点，便将其读入内存，比较其中的关键字，若能匹配到我们要找的元素，便返回；若未能找到，通过比较确定在哪两个关键字的值域区间， 即可确定子树的节点指针，继续往下找，把下一个节点的数据读入内存，重复以上步骤</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于一棵 m 阶的 B 树来说，插入一个元素(或者叫关键字)时，首先判断在 B 树中是否已存在，如果存在则不插入；如果不存在，则在对应叶子结点中插入新的元素，需要判断是否会超出关键字个数限制(m-1)</p><p>插入步骤:</p><ol><li>根据元素大小查找插入位置，肯定是最底层的叶子节点，将元素插入到该节点中</li><li>如果叶子节点的关键字个数小于等于 m-1，说明未超出限制，插入结束；否则进入下一步</li><li>如果叶子节点的关键字个数大于 m-1 个，以结点中间的关键字为中心分裂成左右两部分，然后将这个中间的关键字插入到父结点中，这个关键字的左子树指向分裂后的左半部分，这个关键字的右子树指向分裂后的右半部分。</li><li>然后将当前结点指向父结点，如果插入刚才的中间关键字后父节点的关键字个数也超出限制，继续进行第 3 步；否则结束插入</li></ol><p>还是以上面的 2-3-4 树(阶数 m = 4)为例，我们依次插入元素</p><ul><li>首先插入 1、2、3，因为关键字个数均为超过 m-1，所以直接插入即可:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-0.svg" alt="插入 1 2 3"></p><ul><li>当插入 4 时，该节点关键字个数达到 m，需要分裂，这里可以选 3 (也可以选 2) 作为中间字，分裂后:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-1.svg" alt="插入 4"></p><ul><li>继续插入 5、7，对应 4 所在的叶子节点:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-2.svg" alt="插入 5 7"></p><ul><li>当插入 8 时，也需要分裂，将中间字 5 上移至父节点，4 成为 5 的左区间子树，7 8 成为 5 的右区间子树:</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-insert-3.svg" alt="插入 8"></p><p>之后的步骤类似，不再一一叙述</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作是指删除 B 树中的某个节点中的指定关键字</p><p>删除步骤:</p><ol><li>如果当前要删除的关键字位于非叶子结点 N 上，则用后继最小关键字(找前继最大关键字也可以)覆盖要删除的关键字，然后在后继关键字所在的子树中删除该后继关键字。此后继关键字一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个后继关键字后进入第 2 步，如果原本要删除的关键字本身就位于叶子上同样删除关键字后进入第二步</li><li>该结点(假设为 M)关键字个数大于等于 math.Ceil(m/2)-1，结束删除操作，否则进入第 3 步</li><li>此时结点 M 关键字个数小于 math.Ceil(m/2)-1<ul><li>如果相邻兄弟结点(左右都可以)关键字个数大于 math.Ceil(m/2)-1，则父结点中取一个临近的关键字下移到 M，兄弟结点中取一个临近关键字上移至父节点，删除操作结束；</li><li>如果相邻的兄弟节点关键字个数都不大于 math.Ceil(m/2)-1，将父结点中临近的关键字 key 下移至 M，合并 M 和它的兄弟节点形成一个新的结点。原父结点中的 key 的两个孩子指针就变成一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复第 2 步</li></ul></li></ol><p>以上面的 2-3-4 树为例</p><p><img src="https://src.wangriyu.wang/images/blog/tree/BTree-0.svg" alt="2-3-4 树"></p><p>阶数为 4，节点关键字个数范围应该是 [1, 3]，即 math.Ceil(m/2)-1 = 1</p><ul><li>删除关键字 2 或者 8，不影响节点</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-0.svg" alt="删除 2 和 8"></p><ul><li>删除关键字 4，该叶子节点 X 关键字个数变为 0 小于范围下界，同时左右两个相邻兄弟的关键字个数都不大于 1，需要合并节点。<ul><li>第一步，将父节点的 5 下移到 X 上</li><li>第二步，合并 X 和右兄弟节点 7 形成一个包含 5、7 的新节点</li><li>第三步，父节点中原本 5 的左右两个孩子指针变为一个并指向这个新节点</li></ul></li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-1.svg" alt="删除 4"></p><p>这里第一步也可以选择下移 3，然后第二步跟左兄弟合并成 1、3 节点</p><ul><li>继续删除 1，此时与上一个问题不同，该叶子节点的兄弟有富余的关键字，我们只需要把父节点的临近的一个关键字下移到该叶子节点代替删除的元素，然后把兄弟节点的一个临近关键字上移至父节点即可，这个操作有点类似红黑树的左旋操作</li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-2.svg" alt="删除 1"></p><ul><li>现在尝试删除非叶子节点 5，用后继最小关键字 7 代替 5，然后删除 7 所在的叶子节点。<ul><li>此时会引起连锁反应，7 所在的叶子节点现在为空，而兄弟节点关键字又不大于 1，需要合并</li><li>将关键字 7 又从父节点移至原来的叶子上，合并成含 3、7 的新节点，假设新节点为 N，父节点的孩子指针变为一个并指向 N</li><li>而父节点现在关键字是空的，而且其兄弟(N 的叔叔)关键字也不大于 1，也需要合并</li><li>根节点取出关键字 9 下移到 N 的父节点上，合并 N 的父节点和叔叔节点，产生一个包含 9、15 的新节点，根节点的孩子指针减少一个且左子树指向这个新节点</li></ul></li></ul><p><img src="https://src.wangriyu.wang/images/blog/tree/BT-removal-3.svg" alt="删除 5"></p><p>删除操作就演示到这，B 树的内容讲完</p><h2 id="B-树-B-Tree-1"><a href="#B-树-B-Tree-1" class="headerlink" title="B+ 树 (B+ - Tree)"></a>B+ 树 (B+ - Tree)</h2><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+ 树</a> 是基于 B 树的变体，查找性能更好</p><p>同为 m 阶的 B+ 树与 B 树的不同点:</p><ol><li>所有非叶子节点，每个节点最多有 m 个关键字，最少有 $\lceil\frac m2\rceil$ 个关键字(比 B 树的限制多一个)，其中每个关键字对应一棵子树</li><li>所有的非叶子结点可以看成是索引部分，结点中仅含有其子树根结点中最大(或最小)关键字，不包含关键字数据的指针(B 树是包含这个指针的)</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小到大顺序链接.(而 B 树的全部关键字信息分散在各个节点中)</li></ol><p><img src="https://src.wangriyu.wang/images/blog/tree/B+Tree.svg" alt="B+ 树"></p><p>如图所示的是将之前的 2-3-4 树的数据存到 B+ 树结构中的示意图，叶子节点保存了所有关键字信息并且叶子节点之间也用指针连接起来(一个顺序链表)，而所有非叶子节点只包含子树根节点中对应的最大关键字，其作用只是用于索引</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>B+ 树比 B 树更适合实际应用中操作系统的文件索引和数据库索引</p><ol><li>B+ 树索引节点可以存储更多的关键字，磁盘 I/O 可以更少</li></ol><blockquote><p>数据库中关键字可能只是某个数据列的索引信息(比如以 ID 列创建的索引)，而索引指向的数据记录(某个 ID 对应的数据行)我们称作<strong>卫星数据</strong>，推荐看下博文 <a href="http://www.ruanyifeng.com/blog/2014/07/database_implementation.html" target="_blank" rel="noopener">数据库的最简单实现</a> 和 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>B- 树中间节点和叶子节点都会带有关键字和卫星数据的指针，B+ 树中间节点只带有关键字，而卫星数据的指针均放在叶子节点中</p></blockquote><p>因为没有卫星数据的指针，所以 B+ 树内部结点相对 B 树占用空间更小。如果把所有同一结点的关键字存放在同一盘块中，那么对于 B+ 树来说盘块所能容纳的关键字数量也就更多，一次性读入内存中时能查找的关键字也就更多。相对来说 IO 读写次数也就降低了，性能就提升了。</p><p>举个例子，假设磁盘中的一个盘块能容纳 16 bytes，而一个关键字占 2 bytes，一个卫星数据指针占 2bytes。对于一棵 9 阶 B 树来说，一个结点最多含 8 个关键字(8*4 bytes)，即一个内部结点需要 2 个盘块来存储。而对于 B+ 树来说，内部结点不含卫星数据的指针，所以一个内部节点只需要 1 个盘块。当需要把内部结点读入内存中的时候，B 树就比 B+ 树多一次盘块查找时间</p><ol start="2"><li>B+ 树的查询效率更加稳定</li></ol><p>由于非叶子节点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路径。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。而 B 树查找一个文件时查找到的路径长度是不一的。</p><ol start="3"><li>B+ 树对范围查询操作更友好</li></ol><p>如果是查找单一元素，B+ 树的查找过程与 B 树类似，只是每次查找都是从根查到叶</p><p>而进行范围查询的操作时，B+ 树只要遍历叶子节点就可以实现整棵树的遍历，而 B 树的范围查询要通过中序遍历，效率比较低下</p><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>B+ 树的插入与 B 树类似，先寻找关键字对应的位置插入，需要注意的是插入比当前子树的最大关键字还大的数时要修改祖先节点对应的关键字，因为 B+ 树内部结点存的是子树的最大关键字</p><p>比如在上面给出的 B+ 树中插入 105 这个元素，因为 105 大于当前子树最大关键字 101，所以需要修改父节点和祖父节点的边界关键字:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-insert-0.svg" alt="插入 105"></p><ul><li>如果插入元素的节点未超出上界限制，则结束；否则将节点分裂，中间节点上移到父节点中，再判断父节点是否需要调整</li></ul><p>比如刚才插入 105 的叶子节点关键字个数达到 4 个，需要分裂，这里分裂与 B 树略有不同。B 树是把节点按中间节点分成三份，再把中间节点上移；而 B+ 树是分成两份，再把左半节点的最大关键字添加进父节点</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-insert-1.svg" alt="分裂叶子"></p><p>此时父节点也需要分裂</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-insert-2.svg" alt="分裂父节点"></p><p>根节点未超出 4，结束；假如此时根节点也超出上界了，需要把根节点也分裂，生成一个新的根节点，且新的根节点的关键字为左右子树的最大关键字</p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>B+ 树的删除与 B 树也类似，找到要删除的关键字，如果是当前子树的最大关键字，删除该关键字后还要修改祖先节点对应的关键字；如果不是当前子树的最大关键字，直接删除；</p><p>在上一张图的基础上删除 8，这是叶子的最大关键字，所以需要修改父节点和祖父节点的边界关键字:</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-removal-0.svg" alt="删除 8"></p><ul><li>如果删除元素的节点未低于下界限制，则结束；否则分两种情况处理:<ul><li>如果兄弟节点有富余关键字，则从兄弟节点中移动一个关键字到当前节点，修改父节点对应边界关键字即可</li><li>如果兄弟节点关键字个数都处于下界值，不能外借元素，则合并当前节点和兄弟节点，修改父节点的孩子指针以及边界关键字，此时父节点关键字个数也少了一个，将当前节点的指针指向父节点继续判断处理</li></ul></li></ul><p>我们继续删除 7，此时该叶子节点关键字个数少于 1 需要调整，而兄弟节点有富余关键字，可以移动 5 到当前节点，修改父节点和祖父节点的边界关键字</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-removal-1.svg" alt="删除 7"></p><p>继续删除 5，兄弟节点的关键字个数为下界值 1，不能外借，则合并当前节点和兄弟节点，并修改父节点指针及关键字，相应的祖父节点也需要修改边界关键字</p><p><img src="https://src.wangriyu.wang/images/blog/tree/B+T-removal-2.svg" alt="删除 5"></p><h2 id="B-树-B-Tree-2"><a href="#B-树-B-Tree-2" class="headerlink" title="B* 树 (B* - Tree)"></a>B* 树 (B* - Tree)</h2><p>B<em> 树是 B+ 树的变体，在 B+ 树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B</em> 树多了两条性质:</p><ul><li>中间结点也增加了指向兄弟的指针，即每一层节点都可以横向遍历</li><li>B* 树定义了非叶子结点关键字个数至少为 $\lceil\frac {2m}3\rceil$，即块的最低使用率为 2/3，代替 B+ 树的 1/2</li></ul><p>下图的数据与之前 B+ 树的数据一样，但分支结构有所不同(因为中间节点关键字范围变为[3, 4]，不同于之前 B+ 树的 [2, 4])，而且第二层节点之间也用指针连接起来<br><img src="https://src.wangriyu.wang/images/blog/tree/B*-Tree.svg" alt="B* 树"></p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>B+ 树节点满时就会分裂，而 B* 树节点满时会先检查兄弟节点是否满(因为每个节点都有指向兄弟的指针):</p><ul><li>如果兄弟节点未满则向兄弟节点转移关键字，然后修改原节点和兄弟结点的关键字以及会受最大关键字变动影响的祖先的边界关键字</li><li>如果兄弟节点已满，则从当前节点和兄弟节点各拿出 1/3 的数据创建一个新的节点出来，然后在父结点增加新结点的指针</li></ul><p>B* 树存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得 B* 树分解次数变得更少，节点空间使用率更高</p><p>因为没有找到相关的内容，关于 B* 树的插入删除这里不再讲解</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文依次介绍了二叉树 -&gt; 二叉搜索树 -&gt; 平衡二叉搜索树(红黑树) -&gt; 平衡多路查找树(B 类树)，各有特点，其中 B 类树是介绍的重点，因为实际运用中索引结构使用的是 B 类树</p><p>因为树的上面几层会反复查询，所以我们可以把树的前几层存在内存中，而底层的数据存在外部磁盘里，这样效率更高</p><p>当然 B 树也存在弊端:</p><p>因为一旦确定最大阶数，后面的使用过程中就不可以修改关键字个数的范围</p><p>那么除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到 70 字符之内</p><p>后面一篇我们会讲解另一种 Mysql 的索引结构: 哈希索引，可以动态适应任意长度的键值</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">wikipedia - 红黑树</a></li><li><a href="https://mp.weixin.qq.com/s/rDCEFzoKHIjyHfI_bsz5Rw" target="_blank" rel="noopener">什么是 B-树</a></li><li>《编程之法: 面试和算法心得》</li></ul>]]></content>
    
    <summary type="html">
    
      介绍二叉搜索树、红黑树、B 树、B+ 树和 B* 树，如果看完本文你心里还没点 B 树，那我也没办法了
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://blog.wangriyu.wang/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://blog.wangriyu.wang/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://blog.wangriyu.wang/tags/%E6%A0%91/"/>
    
      <category term="数据库" scheme="https://blog.wangriyu.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>搭建 docker 环境并用 docker 部署 nextcloud 网盘</title>
    <link href="https://blog.wangriyu.wang/2018/05-server-nextcloud.html"/>
    <id>https://blog.wangriyu.wang/2018/05-server-nextcloud.html</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-09T13:48:36.307Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统环境为 CentOS 7.4，默认用户为 root</p></blockquote><h2 id="安装-docker-和-docker-compose"><a href="#安装-docker-和-docker-compose" class="headerlink" title="安装 docker 和 docker-compose"></a>安装 docker 和 docker-compose</h2><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install docker-io -y</span><br><span class="line">$ docker -v // 查看版本</span><br><span class="line">$ systemctl start docker // 启动 docker</span><br><span class="line">$ systemctl enable docker // 设置开机自启动</span><br><span class="line">$ docker info // 如果已经启动 docker，会输出全局信息</span><br></pre></td></tr></table></figure><p>设置镜像源，因为我是腾讯云服务器，所以选了腾讯云提供的源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;OPTIONS=&apos;--registry-mirror=https://mirror.ccs.tencentyun.com&apos;&quot; &gt;&gt; /etc/sysconfig/docker</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service docker restart</span><br></pre></td></tr></table></figure><p>现在就可使用 docker 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker search mysql</span><br><span class="line">$ docker pull 镜像</span><br><span class="line">$ docker images // 已安装镜像</span><br><span class="line">$ docker ps -a // 已启动容器</span><br></pre></td></tr></table></figure><h3 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum -y install python-pip</span><br><span class="line">$ pip install --upgrade --force-reinstall pip==9.0.3 // 这里如果升级最新的，比如 10.0 以上的，下面安装 docker-compose 会报错</span><br><span class="line">$ pip install docker-compose</span><br><span class="line">$ docker-compose --version</span><br></pre></td></tr></table></figure><h2 id="部署-nextcloud"><a href="#部署-nextcloud" class="headerlink" title="部署 nextcloud"></a>部署 nextcloud</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>需要镜像: <code>wonderfall/nextcloud</code> 和 <code>mariadb:10</code></li><li>本机需要安装 nginx</li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ docker pull wonderfall/nextcloud</span><br><span class="line">$ docker pull mariadb:10</span><br><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></table></figure><p>粘贴以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">nextcloud:</span><br><span class="line">  image: wonderfall/nextcloud</span><br><span class="line">  container_name: nextcloud_web</span><br><span class="line">  links:</span><br><span class="line">    - nextcloud-db:nextcloud-db</span><br><span class="line">  environment:</span><br><span class="line">    - UID=1000</span><br><span class="line">    - GID=1000</span><br><span class="line">    - UPLOAD_MAX_SIZE=5G</span><br><span class="line">    - APC_SHM_SIZE=128M</span><br><span class="line">    - OPCACHE_MEM_SIZE=128</span><br><span class="line">    - CRON_PERIOD=15m</span><br><span class="line">    - TZ=Aisa/Shanghai</span><br><span class="line">    - ADMIN_USER=登录账号</span><br><span class="line">    - ADMIN_PASSWORD=登录密码</span><br><span class="line">    - DOMAIN=localhost</span><br><span class="line">    - DB_TYPE=mysql</span><br><span class="line">    - DB_NAME=nextcloud</span><br><span class="line">    - DB_USER=nextcloud</span><br><span class="line">    - DB_PASSWORD=数据库 nextcloud 账号密码</span><br><span class="line">    - DB_HOST=nextcloud-db</span><br><span class="line">  volumes:</span><br><span class="line">    # 文件会放在宿主机的 `/docker/nextcloud` 目录，如果不存在会自动创建</span><br><span class="line">    - /docker/nextcloud/data:/data</span><br><span class="line">    - /docker/nextcloud/config:/config</span><br><span class="line">    - /docker/nextcloud/apps:/apps2</span><br><span class="line">    - /docker/nextcloud/themes:/nextcloud/themes</span><br><span class="line">  expose:</span><br><span class="line">    - 8888</span><br><span class="line">  ports:</span><br><span class="line">    # 宿主机端口:镜像端口</span><br><span class="line">    - 8888:8888/tcp</span><br><span class="line">  restart: always</span><br><span class="line"></span><br><span class="line">nextcloud-db:</span><br><span class="line">  image: mariadb:10</span><br><span class="line">  container_name: nextcloud_db</span><br><span class="line">  volumes:</span><br><span class="line">    # 数据库文件会放在宿主机的 `/docker/nextcloud/db` 目录，如果不存在会自动创建</span><br><span class="line">    - /docker/nextcloud/db:/var/lib/mysql</span><br><span class="line">  environment:</span><br><span class="line">    - MYSQL_ROOT_PASSWORD=数据库 root 密码</span><br><span class="line">    - MYSQL_DATABASE=nextcloud</span><br><span class="line">    - MYSQL_USER=nextcloud</span><br><span class="line">    - MYSQL_PASSWORD=数据库 nextcloud 账号密码</span><br><span class="line">  restart: always</span><br></pre></td></tr></table></figure><p>编辑完后保存退出，在 docker-compose.yml 统计目录执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br><span class="line">Creating nextcloud_db ... done</span><br><span class="line">Creating nextcloud_web ... done</span><br></pre></td></tr></table></figure><p>这里要注意一下，相应容器启动后还有一段配置时间，大概几分钟到十几分钟不等。我刚开始弄的时候，起完容器就去看网页能否打开，结果打不开，以为是打开的方式不对，直到后面看了一下日志才发现需要等…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a // 可以看到容器已经起来</span><br><span class="line">$ docker logs nextcloud_db // 查看数据库配置是否完成</span><br><span class="line">$ docker logs nextcloud_web // 查看 nextcloud 是否配置完成</span><br></pre></td></tr></table></figure><p>这里推荐安装 httpie 工具，方便测试 http，如果 nextcloud 服务正常的话，应该会输出一个 login 页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install httpie</span><br><span class="line">$ http localhost:8888</span><br></pre></td></tr></table></figure><p>现在 nextcloud 网盘就搭建好了，通过 ip:8888 就可以访问网盘页面了，下一步添加域名解析</p><h3 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h3><p>到 DNS 解析那添加一条二级域名，比如我用 pan，解析值填服务器 IP</p><p>回到服务器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/nginx/conf.d</span><br><span class="line">$ vi pan.wangriyu.wang.conf</span><br></pre></td></tr></table></figure><p>添加主机设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name  pan.wangriyu.wang;</span><br><span class="line"></span><br><span class="line">    # https 设置，可以不写</span><br><span class="line">    listen 443 ssl http2; # managed by Certbot</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/wangriyu.wang/fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/wangriyu.wang/privkey.pem; # managed by Certbot</span><br><span class="line">    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot; always;</span><br><span class="line"></span><br><span class="line">    # 限制客户端最大上传大小</span><br><span class="line">    client_max_body_size 5G;</span><br><span class="line"></span><br><span class="line">    # 反向代理</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_redirect off;</span><br><span class="line">      proxy_pass http://127.0.0.1:8888;</span><br><span class="line">      proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /.htaccess &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # 非加密连接重定向到 https 上</span><br><span class="line">    if ($host = pan.wangriyu.wang) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    listen   80;</span><br><span class="line">    server_name  pan.wangriyu.wang;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑完保存退出，重载 nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -s reload</span><br></pre></td></tr></table></figure><p>此时我们就可以访问 <a href="https://pan.wangriyu.wang" target="_blank" rel="noopener">https://pan.wangriyu.wang</a> 了，nextcloud 还有客户端，好好享受你的个人网盘吧</p>]]></content>
    
    <summary type="html">
    
      把博客从 github 搬到自己的服务器上，如何搭建 git 服务并用 git 部署
    
    </summary>
    
      <category term="Server" scheme="https://blog.wangriyu.wang/categories/Server/"/>
    
    
      <category term="server" scheme="https://blog.wangriyu.wang/tags/server/"/>
    
      <category term="nextcloud" scheme="https://blog.wangriyu.wang/tags/nextcloud/"/>
    
      <category term="个人网盘" scheme="https://blog.wangriyu.wang/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 搭建 FTP 服务</title>
    <link href="https://blog.wangriyu.wang/2018/05-server-ftp.html"/>
    <id>https://blog.wangriyu.wang/2018/05-server-ftp.html</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2018-06-09T13:55:03.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>系统环境为 CentOS 7.4，默认用户为 root</p></blockquote><h2 id="安装并启动-FTP-服务"><a href="#安装并启动-FTP-服务" class="headerlink" title="安装并启动 FTP 服务"></a>安装并启动 FTP 服务</h2><h3 id="安装-VSFTPD"><a href="#安装-VSFTPD" class="headerlink" title="安装 VSFTPD"></a>安装 VSFTPD</h3><p>官网介绍: <a href="https://security.appspot.com/vsftpd.html#about" target="_blank" rel="noopener">https://security.appspot.com/vsftpd.html#about</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install vsftpd -y</span><br></pre></td></tr></table></figure><h3 id="启动-VSFTPD"><a href="#启动-VSFTPD" class="headerlink" title="启动 VSFTPD"></a>启动 VSFTPD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service vsftpd start</span><br><span class="line">$ systemctl enable vsftpd</span><br></pre></td></tr></table></figure><p>ftp 协议默认使用的是 21 端口，如果服务正常启动了，此命令应该会输出占用对象为 vsftpd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nltp | grep 21</span><br></pre></td></tr></table></figure><p>此时访问 <code>ftp://服务器 IP 地址</code> 就可以浏览服务器上的 /var/ftp 目录了</p><h3 id="配置-FTP-权限"><a href="#配置-FTP-权限" class="headerlink" title="配置 FTP 权限"></a>配置 FTP 权限</h3><p>当前 FTP 服务允许匿名登陆，即直接访问，我们需要配置 FTP 访问权限</p><p>vsftpd 的配置目录为 /etc/vsftpd，其中</p><ul><li>vsftpd.conf 为主要配置文件</li><li>ftpusers 配置禁止访问 FTP 服务器的用户列表，即黑名单</li><li>user_list 配置用户访问控制</li></ul><h3 id="阻止匿名访问和切换根目录"><a href="#阻止匿名访问和切换根目录" class="headerlink" title="阻止匿名访问和切换根目录"></a>阻止匿名访问和切换根目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure><p>找到 <code>anonymous_enable</code> 并设为 NO，找到 <code>chroot_local_user</code> 并去掉注释，并在最后添加 <code>allow_writeable_chroot=YES</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 禁用匿名用户</span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line"># 禁止切换根目录</span><br><span class="line">chroot_local_user=YES</span><br><span class="line"></span><br><span class="line"># 避免 vsftpd：500 OOPS: vsftpd: refusing to run with writable root inside chroot ()</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure><p>其他配置见 <code>Very Secure FTP Daemon 手册</code>: <a href="https://wiki.archlinux.org/index.php/Very_Secure_FTP_Daemon_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Very_Secure_FTP_Daemon_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><p>保存后重启 FTP 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service vsftpd restart</span><br></pre></td></tr></table></figure><h3 id="创建-FTP-用户"><a href="#创建-FTP-用户" class="headerlink" title="创建 FTP 用户"></a>创建 FTP 用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd ftpuser</span><br><span class="line">$ passwd ftpuser</span><br></pre></td></tr></table></figure><p>限制该用户仅能通过 FTP 访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -s /sbin/nologin ftpuser</span><br></pre></td></tr></table></figure><h3 id="为用户分配主目录"><a href="#为用户分配主目录" class="headerlink" title="为用户分配主目录"></a>为用户分配主目录</h3><p>假设 /data/ftp 是 ftp 要访问的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /data</span><br><span class="line">$ chmod -R 755 .</span><br><span class="line">$ chwon -R ftpuser .</span><br><span class="line">$ usermod -d /data/ftp ftpuser</span><br></pre></td></tr></table></figure><h3 id="访问-FTP-服务"><a href="#访问-FTP-服务" class="headerlink" title="访问 FTP 服务"></a>访问 FTP 服务</h3><p>Mac 系统推荐安装 <a href="https://panic.com/transmit/" target="_blank" rel="noopener">Transmit</a> 客户端</p><p>左边为本地文件，右边为 FTP 服务器，支持拖动，可以很方便的进行移动复制删除创建等操作</p><p><img src="https://src.wangriyu.wang/images/blog/ftp/transmit.png" alt="image"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>至此 FTP 服务就搭建完了，我用这个 FTP 服务主要是上传修改博客和一些其他地方用到的静态文件，比如图片音乐等</p><p>我用 nginx 起一个 http 主机，这样我就可以通过 src.wangiyu.wang 这个域名访问 FTP 目录的文件，然后再去腾讯云那里添加 src.wangriyu.wang 到 CDN 上，这样我就可以用 FTP 方便管理博客要用到的图片等比较大的静态文件，然后用 CDN 来访问文件</p>]]></content>
    
    <summary type="html">
    
      如何在服务器上搭建 FTP 服务
    
    </summary>
    
      <category term="Server" scheme="https://blog.wangriyu.wang/categories/Server/"/>
    
    
      <category term="server" scheme="https://blog.wangriyu.wang/tags/server/"/>
    
      <category term="ftp" scheme="https://blog.wangriyu.wang/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2 详解</title>
    <link href="https://blog.wangriyu.wang/2018/05-HTTP2.html"/>
    <id>https://blog.wangriyu.wang/2018/05-HTTP2.html</id>
    <published>2018-05-18T16:00:00.000Z</published>
    <updated>2018-05-24T12:14:49.250Z</updated>
    
    <content type="html"><![CDATA[<p>维基百科关于 HTTP/2 的介绍，可以看下定义和发展历史:</p><p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">Wiki</a></p><p>RFC 7540 定义了 HTTP/2 的协议规范和细节，本文的细节主要来自此文档，建议先看一遍本文，再回过头来照着协议大致过一遍 RFC，如果想深入某些细节再仔细翻看 RFC</p><p><a href="https://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">RFC7540</a></p><h2 id="Why-use-it"><a href="#Why-use-it" class="headerlink" title="Why use it ?"></a>Why use it ?</h2><h3 id="HTTP-1-1-存在的问题"><a href="#HTTP-1-1-存在的问题" class="headerlink" title="HTTP/1.1 存在的问题:"></a>HTTP/1.1 存在的问题:</h3><p>1、<strong>TCP 连接数限制</strong></p><p>对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接 (不同浏览器不一样)。为了解决数量限制，出现了 <code>域名分片</code> 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)，这样就可以针对不同域名创建连接并请求，以一种讨巧的方式突破限制，但是滥用此技术也会造成很多问题，比如每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存，对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等，对于移动端来说问题更明显，可以参考这篇文章: <a href="http://dev.mobify.com/blog/domain-sharding-bad-news-mobile-performance/" target="_blank" rel="noopener">Why Domain Sharding is Bad News for Mobile Performance and Users</a></p><p><img src="https://src.wangriyu.wang/images/blog/http/HOLB-1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/HOLB-2.png" alt="image"></p><p>在图中可以看到新建了六个 TCP 连接，每次新建连接 DNS 解析需要时间(几 ms 到几百 ms 不等)、TCP 慢启动也需要时间、TLS 握手又要时间，而且后续请求都要等待队列调度</p><p>2、<strong><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">线头阻塞 (Head Of Line Blocking)</a> 问题</strong></p><p>每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。为了解决此问题，出现了 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">管线化 - pipelining</a> 技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化</p><p>3、Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</p><p>4、为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</p><p>5、明文传输不安全</p><h3 id="HTTP2-的优势"><a href="#HTTP2-的优势" class="headerlink" title="HTTP2 的优势:"></a>HTTP2 的优势:</h3><h4 id="1、二进制分帧层-Binary-Framing-Layer"><a href="#1、二进制分帧层-Binary-Framing-Layer" class="headerlink" title="1、二进制分帧层 (Binary Framing Layer)"></a>1、二进制分帧层 (Binary Framing Layer)</h4><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧:</p><p><img src="https://src.wangriyu.wang/images/blog/http/http2-frame.png" alt="image"></p><p>h1 和 h2 的报文对比:</p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-message.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/h2-message.png" alt="image"></p><p>图中 h2 的报文是重组解析过后的，可以发现一些头字段发生了变化，而且所有头字段均小写</p><blockquote><p><code>strict-transport-security: max-age=63072000; includeSubdomains</code> 字段是服务器开启 <a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">HSTS 策略</a>，让浏览器强制使用 HTTPS 进行通信，可以减少重定向造成的额外请求和会话劫持的风险</p></blockquote><blockquote><p>服务器开启 HSTS 的方法是: 以 nginx 为例，在相应站点的 server 模块中添加 <code>add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot; always;</code> 即可</p></blockquote><blockquote><p>在 Chrome 中可以打开 <code>chrome://net-internals/#hsts</code> 进入浏览器的 HSTS 管理界面，可以增加 / 删除 / 查询 HSTS 记录，比如下图:</p></blockquote><blockquote><p><img src="https://src.wangriyu.wang/images/blog/http/HSTS.png" alt="image"></p></blockquote><blockquote><p>在 HSTS 有效期内且 TLS 证书仍有效，浏览器访问 blog.wangriyu.wang 会自动加上 https:// ，而不需要做一次查询重定向到 https</p></blockquote><p>关于帧详见: <a href="#帧-Frame">How does it work ？- 帧</a></p><h4 id="2、多路复用-MultiPlexing"><a href="#2、多路复用-MultiPlexing" class="headerlink" title="2、多路复用 (MultiPlexing)"></a>2、多路复用 (MultiPlexing)</h4><p>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。<br>把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。</p><p>流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题</p><p>所以 http2 对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接:</p><p><img src="https://src.wangriyu.wang/images/blog/http/ConnectionView-h1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/ConnectionView-h2.png" alt="image"></p><p>关于流详见: <a href="#流-Stream">How does it work ？- 流</a></p><h4 id="3、服务端推送-Server-Push"><a href="#3、服务端推送-Server-Push" class="headerlink" title="3、服务端推送 (Server Push)"></a>3、服务端推送 (Server Push)</h4><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p><p>Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>关于服务端推送详见: <a href="#Server-Push">How does it work ？- Server-Push</a></p><h4 id="4、Header-压缩-HPACK"><a href="#4、Header-压缩-HPACK" class="headerlink" title="4、Header 压缩 (HPACK)"></a>4、Header 压缩 (HPACK)</h4><p>使用 <a href="https://httpwg.org/specs/rfc7541.html" target="_blank" rel="noopener">HPACK</a> 算法来压缩首部内容</p><p>关于 HPACK 详见: <a href="#HPACK-算法">How does it work ？- HPACK</a></p><h4 id="5、应用层的重置连接"><a href="#5、应用层的重置连接" class="headerlink" title="5、应用层的重置连接"></a>5、应用层的重置连接</h4><p>对于 HTTP/1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p><h4 id="6、请求优先级设置"><a href="#6、请求优先级设置" class="headerlink" title="6、请求优先级设置"></a>6、请求优先级设置</h4><p>HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p><h4 id="7、流量控制"><a href="#7、流量控制" class="headerlink" title="7、流量控制"></a>7、流量控制</h4><p>每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p><p>关于流量控制详见: <a href="#流量控制">How does it work ？- 流量控制</a></p><h4 id="8、HTTP-1-的几种优化可以弃用"><a href="#8、HTTP-1-的几种优化可以弃用" class="headerlink" title="8、HTTP/1 的几种优化可以弃用"></a>8、HTTP/1 的几种优化可以弃用</h4><p>合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多</p><h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work ?"></a>How does it work ?</h2><h3 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧 - Frame"></a>帧 - Frame</h3><h4 id="帧的结构"><a href="#帧的结构" class="headerlink" title="帧的结构"></a>帧的结构</h4><p>所有帧都是一个固定的 9 字节头部 (payload 之前) 跟一个指定长度的负载 (payload):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Length</code> 代表整个 frame 的长度，用一个 24 位无符号整数表示。除非接收者在 SETTINGS_MAX_FRAME_SIZE 设置了更大的值 (大小可以是 2^14(16384) 字节到 2^24-1(16777215) 字节之间的任意值)，否则数据长度不应超过 2^14(16384) 字节。头部的 9 字节不算在这个长度里</li><li><code>Type</code> 定义 frame 的类型，用 8 bits 表示。帧类型决定了帧主体的格式和语义，如果 type 为 unknown 应该忽略或抛弃。</li><li><code>Flags</code> 是为帧类型相关而预留的布尔标识。标识对于不同的帧类型赋予了不同的语义。如果该标识对于某种帧类型没有定义语义，则它必须被忽略且发送的时候应该赋值为 (0x0)</li><li><code>R</code> 是一个保留的比特位。这个比特的语义没有定义，发送时它必须被设置为 (0x0), 接收时需要忽略。</li><li><a href="https://httpwg.org/specs/rfc7540.html#StreamIdentifiers" target="_blank" rel="noopener">Stream Identifier</a> 用作流控制，用 31 位无符号整数表示。客户端建立的 sid 必须为奇数，服务端建立的 sid 必须为偶数，值 (0x0) 保留给与整个连接相关联的帧 (连接控制消息)，而不是单个流</li><li><code>Frame Payload</code> 是主体内容，由帧类型决定</li></ul><p>共分为十种类型的帧:</p><ul><li><code>HEADERS</code>: 报头帧 (type=0x1)，用来打开一个流或者携带一个首部块片段</li><li><code>DATA</code>: 数据帧 (type=0x0)，装填主体信息，可以用一个或多个 DATA 帧来返回一个请求的响应主体</li><li><code>PRIORITY</code>: 优先级帧 (type=0x2)，指定发送者建议的流优先级，可以在任何流状态下发送 PRIORITY 帧，包括空闲 (idle) 和关闭 (closed) 的流</li><li><code>RST_STREAM</code>: 流终止帧 (type=0x3)，用来请求取消一个流，或者表示发生了一个错误，payload 带有一个 32 位无符号整数的错误码 (<a href="https://httpwg.org/specs/rfc7540.html#ErrorCodes" target="_blank" rel="noopener">Error Codes</a>)，不能在处于空闲 (idle) 状态的流上发送 RST_STREAM 帧</li><li><code>SETTINGS</code>: 设置帧 (type=0x4)，设置此 <code>连接</code> 的参数，作用于整个连接</li><li><code>PUSH_PROMISE</code>: 推送帧 (type=0x5)，服务端推送，客户端可以返回一个 RST_STREAM 帧来选择拒绝推送的流</li><li><code>PING</code>: PING 帧 (type=0x6)，判断一个空闲的连接是否仍然可用，也可以测量最小往返时间 (RTT)</li><li><code>GOAWAY</code>: GOWAY 帧 (type=0x7)，用于发起关闭连接的请求，或者警示严重错误。GOAWAY 会停止接收新流，并且关闭连接前会处理完先前建立的流</li><li><code>WINDOW_UPDATE</code>: 窗口更新帧 (type=0x8)，用于执行流量控制功能，可以作用在单独某个流上 (指定具体 Stream Identifier) 也可以作用整个连接 (Stream Identifier 为 0x0)，只有 DATA 帧受流量控制影响。初始化流量窗口后，发送多少负载，流量窗口就减少多少，如果流量窗口不足就无法发送，WINDOW_UPDATE 帧可以增加流量窗口大小</li><li><code>CONTINUATION</code>: 延续帧 (type=0x9)，用于继续传送首部块片段序列，见 <a href="#首部的压缩与解压缩">首部的压缩与解压缩</a></li></ul><h4 id="DATA-帧格式"><a href="#DATA-帧格式" class="headerlink" title="DATA 帧格式"></a>DATA 帧格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+---------------+-----------------------------------------------+</span><br><span class="line">|                            Data (*)                         ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Pad Length</code>: ? 表示此字段的出现时有条件的，需要设置相应标识 (set flag)，指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>Data</code>: 传递的数据，其长度上限等于帧的 payload 长度减去其他出现的字段长度</li><li><code>Padding</code>: 填充字节，没有具体语义，发送时必须设为 0，作用是混淆报文长度，与 TLS 中 CBC 块加密类似，详见 <a href="https://httpwg.org/specs/rfc7540.html#padding" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html#padding</a></li></ul><p>DATA 帧有如下标识 (flags):</p><ul><li>END_STREAM: bit 0 设为 1 代表当前流的最后一帧</li><li>PADDED: bit 3 设为 1 代表存在 Padding</li></ul><p>例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/DATA-Frame1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/DATA-Frame2.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/DATA-Frame3.png" alt="image"></p><h4 id="HEADERS-帧格式"><a href="#HEADERS-帧格式" class="headerlink" title="HEADERS 帧格式"></a>HEADERS 帧格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|E|                 Stream Dependency? (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|  Weight? (8)  |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>E</code>: 一个比特位声明流的依赖性是否是排他的，存在则代表 PRIORITY flag 被设置</li><li><code>Stream Dependency</code>: 指定一个 stream identifier，代表当前流所依赖的流的 id，存在则代表 PRIORITY flag 被设置</li><li><code>Weight</code>: 一个无符号 8 为整数，代表当前流的优先级权重值 (1~256)，存在则代表 PRIORITY flag 被设置</li><li><code>Header Block Fragment</code>: header 块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul><p>HEADERS 帧有以下标识 (flags):</p><ul><li>END_STREAM: bit 0 设为 1 代表当前 header 块是发送的最后一块，但是带有 END_STREAM 标识的 HEADERS 帧后面还可以跟 CONTINUATION 帧 (这里可以把 CONTINUATION 看作 HEADERS 的一部分)</li><li>END_HEADERS: bit 2 设为 1 代表 header 块结束</li><li>PADDED: bit 3 设为 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li><li>PRIORITY: bit 5 设为 1 表示存在 Exclusive Flag (E), Stream Dependency, 和 Weight</li></ul><p>例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/HEADERS-Frame.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/HEADERS-Response.png" alt="image"></p><h4 id="首部的压缩与解压缩"><a href="#首部的压缩与解压缩" class="headerlink" title="首部的压缩与解压缩"></a>首部的压缩与解压缩</h4><p>HTTP/2 里的首部字段也是一个键具有一个或多个值。这些首部字段用于 HTTP 请求和响应消息，也用于服务端推送操作。</p><p>首部列表是零个或多个首部字段的集合。当通过连接传送时，首部列表被 <code>HTTP header compression</code> 序列化成首部块。然后，序列化的首部块又被划分成一个或多个叫做首部块片段 (Header Block Fragment) 的字节序列，并通过 HEADERS、PUSH_PROMISE，或者 CONTINUATION 帧进行有效负载传送。</p><blockquote><p>Cookie 首部字段需要 HTTP 映射特殊对待，见 <a href="https://httpwg.org/specs/rfc7540.html#CompressCookie" target="_blank" rel="noopener">8.1.2.5. Compressing the Cookie Header Field</a></p></blockquote><p>一个完整的 header 块有两种可能，(1) 一个 HEADERS 帧或 PUSH_PROMISE 帧加上设置 END_HEADERS flag，(2) 一个未设置 END_HEADERS flag 的 HEADERS 帧或 PUSH_PROMISE 帧加上多个 CONTINUATION 帧，其中最后一个 CONTINUATION 帧设置 END_HEADERS flag</p><p>必须将首部块作为连续的帧序列传送，不能插入任何其他类型或其他流的帧。尾帧设置 END_HEADERS 标识代表首部块结束，这让首部块在逻辑上等价于一个单独的帧。接收端连接片段重组首部块，然后解压首部块重建首部列表。</p><p><img src="https://src.wangriyu.wang/images/blog/http/End-Stream.png" alt="image"></p><h4 id="SETTINGS-帧格式"><a href="#SETTINGS-帧格式" class="headerlink" title="SETTINGS 帧格式"></a>SETTINGS 帧格式</h4><p><a href="https://httpwg.org/specs/rfc7540.html#SETTINGS" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html#SETTINGS</a></p><p>一个 SETTINGS 帧的 payload 由零个或多个参数组成，每个参数的形式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">|       Identifier (16)         |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">|                        Value (32)                             |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Identifier</code>: 代表参数类型，比如 SETTINGS_HEADER_TABLE_SIZE 是 0x1</li><li><code>Value</code>: 相应参数的值</li></ul><p>在建立连接开始时双方都要发送 SETTINGS 帧以表明自己期许对方应做的配置，对方接收后同意配置参数便返回带有 ACK 标识的空 SETTINGS 帧表示确认，而且连接后任意时刻任意一方也都可能再发送 SETTINGS 帧调整，SETTINGS 帧中的参数会被最新接收到的参数覆盖</p><p>SETTINGS 帧作用于整个连接，而不是某个流，而且 SETTINGS 帧的 stream identifier 必须是 0x0，否则接收方会认为错误 (PROTOCOL_ERROR)。</p><p>SETTINGS 帧包含以下参数:</p><ul><li>SETTINGS_HEADER_TABLE_SIZE (0x1): 用于解析 Header block 的 Header 压缩表的大小，初始值是 4096 字节</li><li>SETTINGS_ENABLE_PUSH (0x2): 可以关闭 Server Push，该值初始为 1，表示允许服务端推送功能</li><li>SETTINGS_MAX_CONCURRENT_STREAMS (0x3): 代表发送端允许接收端创建的最大流数目</li><li>SETTINGS_INITIAL_WINDOW_SIZE (0x4): 指明发送端所有流的流量控制窗口的初始大小，会影响所有流，该初始值是 2^16 - 1(65535) 字节，最大值是 2^31 - 1，如果超出最大值则会返回 FLOW_CONTROL_ERROR</li><li>SETTINGS_MAX_FRAME_SIZE (0x5): 指明发送端允许接收的最大帧负载的字节数，初始值是 2^14(16384) 字节，如果该值不在初始值 (2^14) 和最大值 (2^24 - 1) 之间，返回 PROTOCOL_ERROR</li><li>SETTINGS_MAX_HEADER_LIST_SIZE (0x6): 通知对端，发送端准备接收的首部列表大小的最大字节数。该值是基于未压缩的首部域大小，包括名称和值的字节长度，外加每个首部域的 32 字节的开销</li></ul><p>SETTINGS 帧有以下标识 (flags):</p><ul><li>ACK: bit 0 设为 1 代表已接收到对方的 SETTINGS 请求并同意设置，设置此标志的 SETTINGS 帧 payload 必须为空</li></ul><p>例子:</p><p><img src="https://src.wangriyu.wang/images/blog/http/SETTINGS-Frame.png" alt="image"></p><p>实际抓包会发现 HTTP2 请求创建连接发送 SETTINGS 帧初始化前还有一个 Magic 帧 (建立 HTTP/2 请求的前言)。</p><p>在 HTTP/2 中，要求两端都要发送一个连接前言，作为对所使用协议的最终确认，并确定 HTTP/2 连接的初始设置，客户端和服务端各自发送不同的连接前言。</p><p>客户端的前言内容 (对应上图中编号 23 的帧) 包含一个内容为 <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code> 的序列加上一个可以为空的 SETTINGS 帧，在收到 101(Switching Protocols) 响应 (代表 upgrade 成功) 后发送，或者作为 TLS 连接的第一个传输的应用数据。如果在预先知道服务端支持 HTTP/2 的情况下启用 HTTP/2 连接，客户端连接前言在连接建立时发送。</p><p>服务端的前言 (对应上图中编号 26 的帧) 包含一个可以为空的 SETTINGS 帧，在建立 HTTP/2 连接后作为第一帧发送。详见 <a href="https://httpwg.org/specs/rfc7540.html#ConnectionHeader" target="_blank" rel="noopener">HTTP/2 Connection Preface</a></p><p>发送完前言后双方都得向对方发送带有 ACK 标识的 SETTINGS 帧表示确认，对应上图中编号 29 和 31 的帧。</p><p>请求站点的全部帧序列，帧后面的数字代表所属流的 id，最后以 GOAWAY 帧关闭连接:</p><p><img src="https://src.wangriyu.wang/images/blog/http/All-Frame.png" alt="image"></p><p>GOAWAY 帧带有最大的那个流标识符 (比如图中第 29 帧是最大流)，对于发送方来说会继续处理完不大于此数字的流，然后再真正关闭连接</p><h3 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 - Stream"></a>流 - Stream</h3><p>流只是一个逻辑上的概念，代表 HTTP/2 连接中在客户端和服务器之间交换的独立双向帧序列，每个帧的 Stream Identifier 字段指明了它属于哪个流。</p><p>流有以下特性:</p><ul><li>单个 h2 连接可以包含多个并发的流，两端之间可以交叉发送不同流的帧</li><li>流可以由客户端或服务器来单方面地建立和使用，或者共享</li><li>流可以由任一方关闭</li><li>帧在流上发送的顺序非常重要，最后接收方会把相同 Stream Identifier (同一个流) 的帧重新组装成完整消息报文</li></ul><h4 id="流的状态"><a href="#流的状态" class="headerlink" title="流的状态"></a>流的状态</h4><p><img src="https://src.wangriyu.wang/images/blog/http/stream-state.png" alt="image"></p><blockquote><p>注意图中的 send 和 recv 对象是指端点，不是指当前的流</p></blockquote><h5 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h5><p>所有流以“空闲”状态开始。在这种状态下，没有任何帧的交换</p><p>其状态转换:</p><ul><li>发送或者接收一个 HEADERS 帧会使空闲 <code>idle</code> 流变成打开 <code>open</code> 状态，其中 HEADERS 帧的 Stream Identifier 字段指明了流 id。同样的 HEADERS 帧(带有 END_STREAM )也可以使一个流立即进入 half-closed 状态。</li><li>服务端必须在一个打开 <code>open</code> 或者半关闭 (远端) <code>half-closed(remote)</code> 状态的流 (由客户端发起的) 上发送 PUSH_PROMISE 帧，其中 PUSH_PROMISE 帧的 Promised Stream ID 字段指定了一个预示的新流 (由服务端发起)，<ul><li>在服务端该新流会由空闲 <code>idle</code> 状态进入被保留的 (本地) <code>reserved(local)</code> 状态</li><li>在客户端该新流会由空闲 <code>idle</code> 状态进入被保留的 (远端) <code>reserved(remote)</code> 状态</li></ul></li></ul><blockquote><p>在 <a href="https://httpwg.org/specs/rfc7540.html#discover-http" target="_blank" rel="noopener">3.2 - Starting HTTP/2 for “http” URIs</a> 中介绍了一种特殊情况:</p><blockquote><p>客户端发起一个 HTTP/1.1 请求，请求带有 Upgrade 机制，想创建 h2c 连接，服务端同意升级返回 101 响应。<br>升级之前发送的 HTTP/1.1 请求被分配一个流标识符 0x1，并被赋予默认优先级值。从客户端到服务端这个流 1 隐式地转为 “half-closed” 状态，因为作为 HTTP/1.1 请求它已经完成了。HTTP/2 连接开始后，流 1 用于响应。详细过程可以看下文的 <a href="#HTTP-2-的协议协商机制">HTTP/2 的协议协商机制</a></p></blockquote></blockquote><p>此状态下接收到 HEADERS 和 PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><p>状态图中 <code>send PP</code> 和 <code>recv PP</code> 是指连接的双方端点发送或接收了 PUSH_PROMISE，不是指某个空闲流发送或接收了 PUSH_PROMISE，是 PUSH_PROMISE 的出现促使一个预示的流从 <code>idle</code> 状态转为 <code>reserved</code></p><blockquote><p>在下文 <a href="#Server-Push">Server-Push</a> 中会详细介绍服务端推送的内容和 PUSH_PROMISE 的使用情形</p></blockquote><h5 id="reserved-local-reserved-remote"><a href="#reserved-local-reserved-remote" class="headerlink" title="reserved (local) / reserved (remote)"></a>reserved (local) / reserved (remote)</h5><p>PUSH_PROMISE 预示的流由 <code>idle</code> 状态进入此状态，代表准备进行 Server push</p><p>其状态转换:</p><ul><li>PUSH_PROMISE 帧预示的流的响应以 HEADERS 帧开始，这会立即将该流在服务端置于半关闭 (远端) <code>half-closed(remote)</code> 状态，在客户端置于半关闭 (本地) <code>half-closed(local)</code> 状态，最后以携带 END_STREAM 的帧结束，这会将流置于关闭 <code>closed</code> 状态</li><li>任一端点都可以发送 RST_STREAM 帧来终止这个流，其状态由 <code>reserved</code> 转为 <code>closed</code></li></ul><p><code>reserved(local)</code> 状态下的流不能发送 HEADERS、RST_STREAM、PRIORITY 以外的帧，接收到 RST_STREAM、PRIORITY、WINDOW_UPDATE 以外的帧被视为 PROTOCOL_ERROR</p><p><code>reserved(remote)</code> 状态下的流不能发送 RST_STREAM、WINDOW_UPDATE、PRIORITY 以外的帧，接收到 HEADERS、RST_STREAM、PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>处于 <code>open</code> 状态的流可以被两个对端用来发送任何类型的帧</p><p>其状态转换:</p><ul><li>任一端都可以发送带有 END_STREAM 标识的帧，发送方会转入 <code>half-closed(local)</code> 状态；接收方会转入 <code>half-closed(remote)</code> 状态</li><li>任一端都可以发送 RST_STREAM 帧，这会使流立即进入 <code>closed</code> 状态</li></ul><h5 id="half-closed-local"><a href="#half-closed-local" class="headerlink" title="half-closed (local)"></a>half-closed (local)</h5><p>流是双向的，半关闭表示这个流单向关闭了，local 代表本端到对端的方向关闭了，remote 代表对端到本端的方向关闭了</p><p>此状态下的流不能发送 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧</p><p>当此状态下的流收到带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><p>此状态下的流收到的 PRIORITY 帧用以调整流的依赖关系顺序，可以看下文的流优先级</p><h5 id="half-closed-remote"><a href="#half-closed-remote" class="headerlink" title="half-closed (remote)"></a>half-closed (remote)</h5><p>此状态下的流不会被对端用于发送帧，执行流量控制的端点不再有义务维护接收方的流控制窗口。</p><p>一个端点在此状态的流上接收到 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧，应该响应一个 STREAM_CLOSED 流错误</p><p>此状态下的流可以被端点用于发送任意类型的帧，且此状态下该端点仍会观察流级别的流控制的限制</p><p>当此状态下的流发送带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><h5 id="closed"><a href="#closed" class="headerlink" title="closed"></a>closed</h5><p>代表流已关闭</p><p>此状态下的流不能发送 PRIORITY 以外的帧，发送 PRIORITY 帧是调整那些依赖这个已关闭的流的流优先级，端点都应该处理 PRIORITY 帧，尽管如果该流从依赖关系树中移除了也可以忽略优先级帧</p><p>此状态下在收到带有 END_STREAM 标识的 DATA 或 HEADERS 帧后的一小段时间内 (period) 仍可能接收到 WINDOW_UPDATE 或 RST_STREAM 帧，因为在远程对端接收并处理 RST_STREAM 或带有 END_STREAM 标志的帧之前，它可能会发送这些类型的帧。但是端点必须忽略接收到的 WINDOW_UPDATE 或 RST_STREAM</p><p>如果一个流发送了 RST_STREAM 帧后转入此状态，而对端接收到 RST_STREAM 帧时可能已经发送了或者处在发送队列中，这些帧是不可撤销的，发送 RST_STREAM 帧的端点必须忽略这些帧。</p><p>一个端点可以限制 period 的长短，在 period 内接受的帧会忽略，超出 period 的帧被视为错误。</p><p>一个端点发送了 RST_STREAM 帧后接收到流控制帧(比如 DATA)，仍会计入流量窗口，即使这些帧会被忽略，因为对端肯定是在接收到 RST_STREAM 帧前发送的流控制帧，对端会认为流控制已生效</p><p>一个端点可能会在发送了 RST_STREAM 帧后收到 PUSH_PROMISE 帧，即便预示的流已经被重置 (reset)，PUSH_PROMISE 帧也能使预示流变成 <code>reserved</code> 状态。因此，需要 RST_STREAM 来关闭一个不想要的预示流。</p><blockquote><p>PRIORITY 帧可以被任意状态的流发送和接收，未知类型的帧会被忽略</p></blockquote><h5 id="流状态的转换"><a href="#流状态的转换" class="headerlink" title="流状态的转换"></a>流状态的转换</h5><p>下面看两个例子来理解流状态:</p><p><img src="https://src.wangriyu.wang/images/blog/http/ServerPushStreamState.png" alt="image"></p><p>(1)、Server 在 Client 发起的一个流上发送 PUSH_PROMISE 帧，其 Promised Stream ID 指定一个预示流用于后续推送，send PP 后这个预示流在服务端从 idle 状态转为 reserve(local) 状态，客户端 recv PP 后这个流从 idle 状态转为 reserve(remote) 状态</p><p>(2)(3)、此时预示流处于保留状态，客户端如果选择拒绝接受推送，可以发送 RST 帧关闭这个流；服务端如果此时出问题了也可以发送 RST 帧取消推送。不管哪一方发送或接收到 RST，此状态都转为 closed</p><p>(4)、没有出现重置说明推送仍有效，则服务端开始推送，首先发送的肯定是响应的 HEADERS 首部块，此时流状态转为半关闭 half-closed(remote)；客户端接收到 HEADERS 后流状态转为半关闭 half-closed(local)</p><p>(5)(6)、半关闭状态下的流应该还会继续推送诸如 DATA 帧、CONTINUATION 帧这样的数据帧，如果这个过程碰到任一方发起重置，则流会关闭进入 closed 状态</p><p>(7)、如果一切顺利，资源随着数据帧响应完毕，最后一帧会带上 END_STREAM 标识代表这个流结束了，此时流转为 closed 状态</p><p><img src="https://src.wangriyu.wang/images/blog/http/RequestStreamState.png" alt="image"></p><p>(1)、客户端发起请求，首先发送一个 HEADERS 帧，其 Stream Identifier 创建一个新流，此流从 idle 状态转为 open 状态</p><p>(2)(3)、如果客户端取消请求可以发送 RST 帧，服务端出错也可以发送 RST 帧，不管哪一方接收或发送 RST，流关闭进入 closed 状态；</p><p>(4)、如果请求结束(END_STREAM)，流转为半关闭状态。假如是 GET 请求，一般 HEADERS 帧就是最后一帧，send H 后流会立即进入半关闭状态。假如是 POST 请求，待数据传完，最后一帧带上 END_STREAM 标识，流转为半关闭</p><p>(5)(6)、客户端半关闭后服务端开始返回响应，此时任一方接收或发送 RST，流关闭；</p><p>(7)、如果一切顺利，等待响应结束(END_STREAM)，流关闭</p><h4 id="流的标识符"><a href="#流的标识符" class="headerlink" title="流的标识符"></a>流的标识符</h4><p>流 ID 是 31 位无符号整数，客户端发起的流必须是奇数，服务端发起的流必须是偶数，0x0 保留为连接控制消息不能用于建立新流。</p><p>HTTP/1.1 Upgrade to HTTP/2 时响应的流 ID 是 0x1，在升级完成之后，流 0x1 在客户端会转为 <code>half-closed (local)</code> 状态，因此这种情况下客户端不能用 0x1 初始化一个流</p><p>新建立的流的 ID 必须大于所有已使用过的数字，接收到一个错误大小的 ID 应该返回 PROTOCOL_ERROR 响应</p><p>使用一个新流时隐式地关闭了对端发起的 ID 小于当前流的且处于 <code>idle</code> 状态的流，比如一个流发送一个 HEADERS 帧打开了 ID 为 7 的流，但还从未向 ID 为 5 的流发送过帧，则流 0x5 会在 0x7 发送完或接收完第一帧后转为 <code>closed</code> 状态</p><p>一个连接内的流 ID 不能重用</p><h4 id="流的优先级"><a href="#流的优先级" class="headerlink" title="流的优先级"></a>流的优先级</h4><p>客户端可以通过 HEADERS 帧的 PRIORITY 信息指定一个新建立流的优先级，其他期间也可以发送 PRIORITY 帧调整流优先级</p><p>设置优先级的目的是为了让端点表达它所期望对端在并发的多个流之间如何分配资源的行为。更重要的是，当发送容量有限时，可以使用优先级来选择用于发送帧的流。</p><p>流可以被标记为依赖其他流，所依赖的流完成后再处理当前流。每个依赖 (dependency) 后都跟着一个权重 (weight)，这一数字是用来确定依赖于相同的流的可分配可用资源的相对比例</p><h5 id="流依赖-Stream-Dependencies"><a href="#流依赖-Stream-Dependencies" class="headerlink" title="流依赖(Stream Dependencies)"></a>流依赖(Stream Dependencies)</h5><p>每个流都可以显示地依赖另一个流，包含依赖关系表示优先将资源分配给指定的流(上层节点)而不是依赖流</p><p>一个不依赖于其他流的流会指定 stream dependency 为 0x0 值，因为不存在的 0x0 流代表依赖树的根</p><p>一个依赖于其他流的流叫做<strong>依赖流</strong>，被依赖的流是当前流的父级。如果被依赖的流不在当前依赖树中(比如状态为 <code>idle</code> 的流)，被依赖的流会使用一个默认优先级</p><p>当依赖一个流时，该流会添加进父级的依赖关系中，共享相同父级的依赖流不会相对于彼此进行排序，比如 B 和 C 依赖 A，新添加一个依赖流 D，BCD 的顺序是不固定的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  A                 A</span><br><span class="line"> / \      ==&gt;      /|\</span><br><span class="line">B   C             B D C</span><br></pre></td></tr></table></figure><p>独占标识 (exclusive) 允许插入一个新层级(新的依赖关系)，独占标识导致该流成为父级的唯一依赖流，而其他依赖流变为其子级，比如同样插入一个新依赖流 E (带有 exclusive):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                    A</span><br><span class="line">  A                 |</span><br><span class="line"> /|\      ==&gt;       E</span><br><span class="line">B D C              /|\</span><br><span class="line">                  B D C</span><br></pre></td></tr></table></figure><p>在依赖关系树中，只有当一个依赖流所依赖的所有流(父级最高为 0x0 的链)被关闭或者无法继续在上面执行，这个依赖流才应该被分配资源</p><h5 id="依赖权重"><a href="#依赖权重" class="headerlink" title="依赖权重"></a>依赖权重</h5><p>所有依赖流都会分配一个 1~256 权重值</p><p>相同父级的依赖流按权重比例分配资源，比如流 B 依赖于 A 且权重值为 4，流 C 依赖于 A 且权重值为 12，当 A 不再执行时，B 理论上能分配的资源只有 C 的三分之一</p><h5 id="优先级调整-Reprioritization"><a href="#优先级调整-Reprioritization" class="headerlink" title="优先级调整 (Reprioritization)"></a>优先级调整 (Reprioritization)</h5><p>使用 PRIORITY 帧可以调整流优先级</p><p>PRIORITY 帧内容与 HEADERS 帧的优先级模块相同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|E|                  Stream Dependency (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|   Weight (8)  |</span><br><span class="line">+-+-------------+</span><br></pre></td></tr></table></figure><ul><li><p>如果父级重新设置了优先级，则依赖流会随其父级流一起移动。若调整优先级的流带有独占标识，会导致新的父流的所有子级依赖于这个流</p></li><li><p>如果一个流调整为依赖自己的一个子级，则这个将被依赖的子级首先移至调整流的父级之下(即同一层)，再移动那个调整流的整棵子树，移动的依赖关系保持其权重</p></li></ul><p>看下面这个例子: 第一个图是初始关系树，现在 A 要调整为依赖 D，根据第二点，现将 D 移至 x 之下，再把 A 调整为 D 的子树(图 3)，如果 A 调整时带有独占标识根据第一点 F 也归为 A 子级(图 4)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  x                x                x                 x</span><br><span class="line">  |               / \               |                 |</span><br><span class="line">  A              D   A              D                 D</span><br><span class="line"> / \            /   / \            / \                |</span><br><span class="line">B   C     ==&gt;  F   B   C   ==&gt;    F   A       OR      A</span><br><span class="line">   / \                 |             / \             /|\</span><br><span class="line">  D   E                E            B   C           B C F</span><br><span class="line">  |                                     |             |</span><br><span class="line">  F                                     E             E</span><br><span class="line">             (intermediate)   (non-exclusive)    (exclusive)</span><br></pre></td></tr></table></figure><h5 id="流优先级的状态管理"><a href="#流优先级的状态管理" class="headerlink" title="流优先级的状态管理"></a>流优先级的状态管理</h5><p>当一个流从依赖树中移除，它的子级可以调整为依赖被关闭流的父级(应该就是连接上一层节点)，新的依赖权重将根据关闭流的权重以及流自身的权重重新计算。</p><p>从依赖树中移除流会导致某些优先级信息丢失。资源在具有相同父级的流之间共享，这意味着如果这个集合中的某个流关闭或者阻塞，任何空闲容量将分配给最近的相邻流。然而，如果此集合的共有依赖(即父级节点)从树中移除，这些子流将与更上一层的流共享资源</p><p>一个例子: 流 A 和流 B 依赖相同父级节点，而流 C 和流 D 都依赖 A，在移除流 A 之前的一段时间内，A 和 D 都无法执行(可能任务阻塞了)，则 C 会分配到 A 的所有资源；<br>如果 A 被移除出树了，A 的权重按比重新计算分配给 C 和 D，此时 D 仍旧阻塞，C 分配的资源相较之前变少了。对于同等的初始权重，C 获取到的可用资源是三分之一而不是二分之一(为什么是三分之一?文档中没有说明细节，权重如何重新分配也不太清楚，下面是按我的理解解释的)</p><p>X 的资源为 1，ABCD 初始权重均为 16，*号代表节点当前不可用，图一中 C 和 B 各占一半资源，而 A 移除后 CD 的权重重新分配变为 8，所以图二中 C 和 B 占比变为 1:2，R(C) 变为 1/3<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">         X(v:1.0)               X(v:1.0)</span><br><span class="line">        / \                    /|\</span><br><span class="line">       /   \                  / | \</span><br><span class="line">     *A     B       ==&gt;      /  |  \</span><br><span class="line">   (w:16) (w:16)            /   |   \</span><br><span class="line">     / \                   C   *D    B</span><br><span class="line">    /   \                (w:8)(w:8)(w:16)</span><br><span class="line">   C    *D</span><br><span class="line">(w:16) (w:16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R(C)=16/(16+16)=1/2 ==&gt;  R(C)=8/(8+16)=1/3</span><br></pre></td></tr></table></figure><p></p><p>可能向一个流创建依赖关系的优先级信息还在传输中，那个流就已经关闭了。如果一个依赖流的依赖指向没有相关优先级信息(即父节点无效)，则这个依赖流会分配默认优先级，这可能会造成不理想的优先级，因为给流分配了不在预期的优先级。</p><p>为了避免上述问题，一个端点应该在流关闭后的一段时间内保留流的优先级调整状态信息，此状态保留时间越长，流被分配错误的或者默认的优先级可能性越低。</p><p>类似地，处于“空闲”状态的流可以被分配优先级或成为其他流的父节点。这允许在依赖关系树中创建分组节点，从而实现更灵活的优先级表达式。空闲流以默认优先级开始</p><p>流优先级状态信息的保留可能增加终端的负担，因此这种状态可以被限制。终端可能根据负荷来决定保留的额外的状态的数目；在高负荷下，可以丢弃额外的优先级状态来限制资源的任务。在极端情况下，终端甚至可以丢弃激活或者保留状态流的优先级信息。如果使用了固定的限制，终端应当至少保留跟 SETTINGS_MAX_CONCURRENT_STREAMS 设置一样大小的流状态</p><h5 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h5><p>所有流都是初始为非独占地依赖于流 0x0。</p><p>Pushed 流初始依赖于相关的流(见 Server-Push)。</p><p>以上两种情况，流的权重都指定为 16。</p><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server-Push"></a>Server-Push</h3><h4 id="PUSH-PROMISE-帧格式"><a href="#PUSH-PROMISE-帧格式" class="headerlink" title="PUSH_PROMISE 帧格式"></a>PUSH_PROMISE 帧格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|R|                  Promised Stream ID (31)                    |</span><br><span class="line">+-+-----------------------------+-------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>R</code>: 保留的1bit位</li><li><code>Promised Stream ID</code>: 31 位的无符号整数，代表 PUSH_PROMISE 帧保留的流，对于发送者来说该流标识符必须是可用于下一个流的有效值</li><li><code>Header Block Fragment</code>: 包含请求首部域的首部块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul><p>PUSH_PROMISE 帧有以下标识 (flags):</p><ul><li>END_HEADERS: bit 2 置 1 代表 header 块结束</li><li>PADDED: bit 3 置 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li></ul><h4 id="Push-的过程"><a href="#Push-的过程" class="headerlink" title="Push 的过程"></a>Push 的过程</h4><p>结合上文关于 Server-Push 的流状态转换</p><p>PUSH_PROMISE 帧只能在对端(客户端)发起的且流状态为 open 或者 half-closed (remote) 的流上发送</p><p>PUSH_PROMISE 帧准备推送的响应总是和来自于客户端的请求相关联。服务端在该请求所在的流上发送 PUSH_PROMISE 帧。PUSH_PROMISE 帧包含一个 Promised Stream ID，该流标识符是从服务端可用的流标识符里选出来的。</p><p>如果服务端收到了一个对文档的请求，该文档包含内嵌的指向多个图片文件的链接，且服务端选择向客户端推送那些额外的图片，那么在发送包含图片链接的 DATA 帧之前发送 PUSH_PROMISE 帧可以确保客户端在发现内嵌的链接之前，能够知道有一个资源将要被推送过来。同样地，如果服务端准备推送被首部块引用的响应 (比如，在 <a href="https://www.w3.org/wiki/LinkHeader" target="_blank" rel="noopener">Link 首部字段</a> 里的)，在发送首部块之前发送一个 PUSH_PROMISE 帧，可以确保客户端不再请求那些资源</p><p>一旦客户端收到了 PUSH_PROMISE 帧，并选择接收被推送的响应，客户端就不应该为准备推送的响应发起任何请求，直到预示的流被关闭以后。</p><p><img src="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_2.png" alt="image"></p><blockquote><p>注意图中推送的四个资源各预示了一个流 (Promised Stream ID)，而发送 PUSH_PROMISE 帧的还是在客户端发起的请求流 (Stream Identifier = 1) 上，客户端收到 PUSH_PROMISE 帧并选择接收便不会对这四个资源发起请求，之后服务端会发起预示的流然后推送资源相关的响应</p></blockquote><p>不管出于什么原因，如果客户端决定不再从服务端接收准备推送的响应，或者如果服务端花费了太长时间准备发送被预示的响应，客户端可以发送一个 RST_STREAM 帧，该帧可以使用 CANCEL 或者 REFUSED_STEAM 码，并引用被推送的流标识符。</p><h4 id="nginx-配置-Server-Push"><a href="#nginx-配置-Server-Push" class="headerlink" title="nginx 配置 Server-Push"></a>nginx 配置 Server-Push</h4><blockquote><p>server-push 需要服务端设置，并不是说浏览器发起请求，与此请求相关的资源服务端就会自动推送</p></blockquote><p>以 nginx 为例，从版本 1.13.9 开始正式支持 hppt2 serverpush 功能，</p><p>在相应 server 或 location 模块中加入 <code>http2_push</code> 字段加上相对路径的文件即可在请求该资源时推送相关资源，比如我的博客设置如下，访问首页时有四个文件会由服务器主动推送过去而不需要客户端请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server_name  blog.wangriyu.wang;</span><br><span class="line">root /blog;</span><br><span class="line">index index.html index.htm;</span><br><span class="line"></span><br><span class="line">location = /index.html &#123;</span><br><span class="line">  http2_push /css/style.css;</span><br><span class="line">  http2_push /js/main.js;</span><br><span class="line">  http2_push /img/yule.jpg;</span><br><span class="line">  http2_push /img/avatar.jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过浏览器控制台可以查看 <code>Push</code> 响应:</p><p><img src="https://src.wangriyu.wang/images/blog/http/server-push.png" alt="image"></p><p>也可以用 <code>nghttp</code> 测试 push 响应 (* 号代表是服务端推送的):</p><p><img src="https://src.wangriyu.wang/images/blog/http/nghttp-serverpush.png" alt="image"></p><p>上面 <code>http2_push</code> 的设置适合静态资源，服务端事先知道哪些文件是客户端需要的，然后选择性推送</p><p>假如是后台应用动态生成的文件(比如 json 文件)，服务器事先不知道要推送什么，可以用 <code>Link</code> 响应头来做自动推送</p><p>在 server 模块中添加 <code>http2_push_preload on;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server_name  blog.wangriyu.wang;</span><br><span class="line">root /blog;</span><br><span class="line">index index.html index.htm;</span><br><span class="line"></span><br><span class="line">http2_push_preload on;</span><br></pre></td></tr></table></figure><p>然后设置响应头 (add_header) 或者后台程序生成数据文件返回时带上响应头 Link 标签，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Link: &lt;/style.css&gt;; as=style; rel=preload, &lt;/main.js&gt;; as=script; rel=preload, &lt;/image.jpg&gt;; as=image; rel=preload</span><br></pre></td></tr></table></figure><p>nginx 会根据 Link 响应头主动推送这些资源</p><p>更多nginx 官方介绍见 <a href="https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/" target="_blank" rel="noopener">Introducing HTTP/2 Server Push with NGINX 1.13.9</a></p><h4 id="Server-Push-潜在的问题"><a href="#Server-Push-潜在的问题" class="headerlink" title="Server-Push 潜在的问题"></a>Server-Push 潜在的问题</h4><p>看了这篇文章 <a href="https://imququ.com/post/server-push-in-http2.html" target="_blank" rel="noopener">HTTP/2 中的 Server Push 讨论</a>，发现 Server-Push 有个潜在的问题</p><p>Server-Push 满足条件时便会发起推送，可是客户端已经有缓存了想发送 RST 拒收，而服务器在收到 RST 之前已经推送资源了，虽然这部分推送无效但是肯定会占用带宽</p><p>比如我上面博客关于 http2_push 的配置，我每次打开首页服务器都会推送那四个文件，而实际上浏览器知道自己有缓存使用的也是本地缓存，也就是说本地缓存未失效的期间内，服务器的 Server-Push 只是起到了占用带宽的作用</p><p>当然实际上对我的小站点来说影响并不大，但是如果网站需要大量推送的话，需要考虑并测试 Server-Push 是否会影响用户的后续访问</p><p>另外服务端可以设置 Cookie 或者 Session 记录访问时间，然后之后的访问判断是否需要 Push；还有就是客户端可以限制 PUSH 流的数目，也可以设置一个很低的流量窗口来限制 PUSH 发送的数据大小</p><p>至于哪些资源需要推送，在《web 性能权威指南》中就提到几种策略，比如 Apache 的 mod_spdy 能够识别 X-Associated-Content 首部，当中列出了希望服务器推送的资源；另外网上有人已经做了基于 Referer 首部的中间件来处理 Server-Push；或者服务端能更智能的识别文档，根据当前流量决定是否推送或者推送那些资源。相信以后会有更多关于 Server-Push 的实现和应用</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>多路复用的流会竞争 TCP 资源，进而导致流被阻塞。流控制机制确保同一连接上的流不会相互干扰。流量控制作用于单个流或整个连接。HTTP/2 通过使用 WINDOW_UPDATE 帧来提供流量控制。</p><p>流控制具有以下特征:</p><ul><li>流量控制是特定于连接的。两种级别的流量控制都位于单跳的端点之间，而不是整个端到端的路径。比如 server 前面有一个 front-end proxy 如 Nginx，这时就会有两个 connection，browser-Nginx, Nginx—server，flow control 分别作用于两个 connection。详情见: <a href="https://stackoverflow.com/questions/40747040/how-is-http-2-hop-by-hop-flow-control-accomplished" target="_blank" rel="noopener">How is HTTP/2 hop-by-hop flow control accomplished? - stackoverflow</a></li><li>流量控制是基于 WINDOW_UPDATE 帧的。接收方公布自己打算在每个流以及整个连接上分别接收多少字节。这是一个以信用为基础的方案。</li><li>流量控制是有方向的，由接收者全面控制。接收方可以为每个流和整个连接设置任意的窗口大小。发送方必须尊重接收方设置的流量控制限制。客户方、服务端和中间代理作为接收方时都独立地公布各自的流量控制窗口，作为发送方时都遵守对端的流量控制设置。</li><li>无论是新流还是整个连接，流量控制窗口的初始值是 65535 字节。</li><li>帧的类型决定了流量控制是否适用于帧。目前，只有 DATA 帧会受流量控制影响，所有其它类型的帧并不消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞。</li><li>流量控制不能被禁用。</li><li>HTTP/2 只定义了 WINDOW_UPDATE 帧的格式和语义，并没有规定接收方如何决定何时发送帧、发送什么样的值，也没有规定发送方如何选择发送包。具体实现可以选择任何满足需求的算法。</li></ul><h4 id="WINDOW-UPDATE-帧格式"><a href="#WINDOW-UPDATE-帧格式" class="headerlink" title="WINDOW_UPDATE 帧格式"></a>WINDOW_UPDATE 帧格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|R|                Window Size Increment (31)                   |</span><br><span class="line">+-+-------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>Window Size Increment 表示除了现有的流量控制窗口之外，发送端还可以传送的字节数。取值范围是 1 到 2^31 - 1 字节。</p><p>WINDOW_UPDATE 帧可以是针对一个流或者是针对整个连接的。如果是前者，WINDOW_UPDATE 帧的流标识符指明了受影响的流；如果是后者，流标识符为 0 表示作用于整个连接。</p><p>流量控制功能只适用于被标识的、受流量控制影响的帧。文档定义的帧类型中，只有 DATA 帧受流量控制影响。除非接收端不能再分配资源去处理这些帧，否则不受流量控制影响的帧必须被接收并处理。如果接收端不能再接收帧了，可以响应一个 FLOW_CONTROL_ERROR 类型的流错误或者连接错误。</p><p>WINDOW_UPDATE 可以由发送过带有 END_STREAM 标志的帧的对端发送。这意味着接收端可能会在 half-closed (remote) 或者 closed 状态的流上收到 WINDOW_UPDATE 帧，接收端不能将其当做错误。</p><h4 id="流量控制窗口"><a href="#流量控制窗口" class="headerlink" title="流量控制窗口"></a>流量控制窗口</h4><p>流量控制窗口是一个简单的整数值，指出了准许发送端传送的数据的字节数。窗口值衡量了接收端的缓存能力。</p><p>除非将其当做连接错误，否则当接收端收到 DATA 帧时，必须总是从流量控制窗口中减掉其长度(不包括帧头的长度，而且两个级别的控制窗口都要减)。即使帧有错误，这也是有必要的，因为发送端已经将该帧计入流量控制窗口，如果接收端没有这样做，发送端和接收端的流量控制窗口就会不一致。</p><p>发送端不能发送受流量控制影响的、其长度超出接收端告知的两种级别的流量控制窗口可用空间的帧。即使这两种级别的流量控制窗口都没有可用空间了，也可以发送长度为 0、设置了 END_STREAM 标志的帧(即空的 DATA 帧)。</p><p>当帧的接收端消耗了数据并释放了流量控制窗口的空间时，可以发送一个 WINDOW_UPDATE 帧。对于流级别和连接级别的流量控制窗口，需要分别发送 WINDOW_UPDATE 帧。</p><p>新建连接时，流和连接的初始窗口大小都是 2^16 - 1(65535) 字节。可以通过设置连接前言中 SETTINGS 帧的 SETTINGS_INITIAL_WINDOW_SIZE 参数改变流的初始窗口大小，这会作用于所有流。而<code>连接的初始窗口大小不能改，但可以用 WINDOW_UPDATE 帧来改变流量控制窗口</code>，这是为什么连接前言往往带有一个 WINDOW_UPDATE 帧的原因。</p><p>除了改变还未激活的流的流量控制窗口外，SETTIGNS 帧还可以改变已活跃的流 (处于 open 或 half-closed (remote) 状态的流)的初始流量控制窗口的大小。也就是说，当 SETTINGS_INITIAL_WINDOW_SIZE 的值变化时，接收端必须调整它所维护的所有流的流量控制窗口的值，不管是之前就打开的流还是尚未打开的流。</p><p>改变 SETTINGS_INITIAL_WINDOW_SIZE 可能引发流量控制窗口的可用空间变成负值。发送端必须追踪负的流量控制窗口，并且直到它收到了使流量控制窗口变成正值的 WINDOW_UPDATE 帧，才能发送新的 DATA 帧。</p><p>例如，如果连接一建立客户端就立即发送 60KB 的数据，而服务端却将初始窗口大小设置为 16KB，那么客户端一收到 SETTINGS 帧，就会将可用的流量控制窗口重新计算为 -44KB。客户端保持负的流量控制窗口，直到 WINDOW_UPDATE 帧将窗口值恢复为正值，客户端才可以继续发送数据。</p><p>如果改变 SETTINGS_INITIAL_WINDOW_SIZE 导致流量控制窗口超出了最大值，一端必须 将其当做类型为 FLOW_CONTROL_ERROR 的连接错误</p><p>如果接收端希望使用比当前值小的流量控制窗口，可以发送一个新的 SETTINGS 帧。但是，接收端必须准备好接收超出该窗口值的数据，因为可能在收到 SETTIGNS 帧之前，发送端已经发送了超出该较小窗口值的数据。</p><h4 id="合理使用流控制"><a href="#合理使用流控制" class="headerlink" title="合理使用流控制"></a>合理使用流控制</h4><p>流量控制的定义是用来保护端点在资源约束条件下的操作。例如，一个代理需要在很多连接之间共享内存，也有可能有缓慢的上游连接和快速的下游连接。流量控制解决了接收方无法在一个流上处理数据，但仍希望继续处理同一连接中的其他流的情况。</p><p>不需要此功能的部署可以通告最大大小 (2^31 - 1) 的流量控制窗口，并且可以通过在收到任何数据时发送 WINDOW_UPDATE 帧来维护此窗口大小保持不变。这可以有效禁用接受方的流控制。相反地，发送方总是受控于接收方通告的流控制窗口的限制。</p><p>资源约束下(例如内存)的调度可以使用流量来限制一个对端可以消耗的内存量。需要注意的是如果在不知道带宽延迟积的时候启用流量控制可能导致无法最优的利用可用的网络资源 (RFC1323)。</p><p>即便是对当前的网络延迟乘积有充分的认识，流量控制的实现也可能很复杂。当使用流量控制时，接收端必须及时地从 TCP 接收缓冲区读取数据。这样做可能导致在一些例如 WINDOW_UPDATE 的关键帧在 HTTP/2 不可用时导致死锁。但是流量控制可以保证约束资源能在不需要减少连接利用的情况下得到保护。</p><h3 id="HTTP-2-的协议协商机制"><a href="#HTTP-2-的协议协商机制" class="headerlink" title="HTTP/2 的协议协商机制"></a>HTTP/2 的协议协商机制</h3><h4 id="非加密下的协商-h2c"><a href="#非加密下的协商-h2c" class="headerlink" title="非加密下的协商 - h2c"></a>非加密下的协商 - h2c</h4><p>客户端使用 HTTP Upgrade 机制请求升级，HTTP2-Settings 首部字段是一个专用于连接的首部字段，它包含管理 HTTP/2 连接的参数(使用 Base64 编码)，其前提是假设服务端会接受升级请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Connection: Upgrade, HTTP2-Settings</span><br><span class="line">Upgrade: h2c</span><br><span class="line">HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</span><br></pre></td></tr></table></figure><p>服务器如果支持 http/2 并同意升级，则转换协议，否则忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: h2c</span><br></pre></td></tr></table></figure><p>此时潜在的存在一个流 0x1，客户端上这个流在完成 h1 请求后便转为 <code>half-closed</code> 状态，服务端会用这个流返回响应</p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-1.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-2.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-3.png" alt="image"></p><p>注意图中第一个响应所在的流是 0x1，与上文所说的一致</p><p>目前浏览器只支持 TLS 加密下的 HTTP/2 通信，所以上述情况在浏览器中目前是不可能碰到的，图中显示的是 nghttp 客户端发起的请求</p><h4 id="加密的协商机制-h2"><a href="#加密的协商机制-h2" class="headerlink" title="加密的协商机制 - h2"></a>加密的协商机制 - h2</h4><p>TLS 加密中在 Client-Hello 和 Server-Hello 的过程中通过 <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">ALPN</a> 进行协议协商</p><p><img src="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_1.png" alt="image"></p><p>应用层协议协商在 TLS 握手第一步的扩展中，Client Hello 中客户端指定 ALPN Next Protocol 为 h2 或者 http/1.1 说明客户端支持的协议</p><p><img src="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_2.png" alt="image"></p><p>服务端如果在 Server Hello 中选择 h2 扩展，说明协商协议为 h2，后续请求响应跟着变化；如果服务端未设置 http/2 或者不支持 h2，则继续用 http/1.1 通信</p><h3 id="分析实例"><a href="#分析实例" class="headerlink" title="分析实例"></a>分析实例</h3><p><img src="https://src.wangriyu.wang/images/blog/http/all-frames.png" alt="image"></p><p>196: TLS 握手第一步 Client Hello，开始协议协商，且此处带上了 Session Ticket</p><p>200: Server Hello 同意使用 h2，而且客户端的会话票证有效，恢复会话，握手成功</p><p>202: 客户端也恢复会话，开始加密后续消息</p><p>205: 服务端发起一个连接前言 (SETTINGS)，SETTINGS 帧中设置了最大并行流数量、初始窗口大小、最大帧长度，然后 (WINDOW_UPDATE) 扩大窗口大小</p><p>310: 客户端也发送一个连接前言 Magic，并初始化设置 (SETTINGS)，SETTINGS 帧中设置了 HEADER TABLE 大小、初始窗口大小、最大并行流数量，然后 (WINDOW_UPDATE) 扩大窗口大小</p><p>311: 客户端发送完连接前言后可以立即跟上一个请求，GET / (HEADERS[1])，而且这个 HEADERS 帧还带有 END_STREAM，这会使流 1 从 idle 状态立即转为 half-closed(local) 状态 (open 是中间态)</p><p><img src="https://src.wangriyu.wang/images/blog/http/all-frames-1.png" alt="image"></p><p>311: 此消息中还包含一个客户端发送给服务端的带 ACK 的 SETTINGS 帧</p><p>312: 服务端也响应带 ACK 的 SETTINGS 帧</p><p>321: 服务端在流 1 (此时状态为 half-closed(remote)) 上发送了四个 PUSH_PROMISE 帧，它们分别保留了流 2、4、6、8 用于后续推送，</p><p><img src="https://src.wangriyu.wang/images/blog/http/all-frames-2.png" alt="image"></p><p>321: 此消息中还返回了上面请求的响应 (HEADERS - DATA)，最后 DATA 带上 END_STREAM，流 1 从 half-closed 转为 closed</p><p>329: 调整流优先级，依赖关系: 8 -&gt; 6 -&gt; 4 -&gt; 2 -&gt; 1 (都带有独占标志，而且权重均为 110)</p><p><img src="https://src.wangriyu.wang/images/blog/http/priority-1.png" alt="image"></p><p>342: 流 1 关闭后，流 2 得到分配资源，服务器开始推送，数据由两个 DATA 帧返回</p><p>344: 流 2 结束，开始推送流 4</p><p>356: 调整依赖关系</p><p><img src="https://src.wangriyu.wang/images/blog/http/priority-2.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1         1         1         1(w: 110)</span><br><span class="line">|         |         |         |</span><br><span class="line">2         2         2         2(w: 110)</span><br><span class="line">|         |         |         |</span><br><span class="line">4   ==&gt;   4   ==&gt;   6   ==&gt;   6(w: 147)</span><br><span class="line">|         |         |         |</span><br><span class="line">6         8         4         8(w: 147)</span><br><span class="line">|         |         |         |</span><br><span class="line">8         6         8         4(w: 110)</span><br></pre></td></tr></table></figure><p>367、369、372: 推送 6 和 8 的流数据</p><p>377: 发起一个请求，打开流 3，其中客户端发起的请求都是依赖流 0x0</p><p>之后都是同样的套路完成请求 - 响应，最后以 GOAWAY 帧关闭连接结束</p><h3 id="HPACK-算法"><a href="#HPACK-算法" class="headerlink" title="HPACK 算法"></a>HPACK 算法</h3><p><img src="https://src.wangriyu.wang/images/blog/http/hpack.png" alt="image"></p><h2 id="What-then"><a href="#What-then" class="headerlink" title="What then ?"></a>What then ?</h2><h3 id="HTTP-2-演示"><a href="#HTTP-2-演示" class="headerlink" title="HTTP/2 演示"></a>HTTP/2 演示</h3><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a></p><p><a href="https://http2.golang.org/" target="_blank" rel="noopener">https://http2.golang.org/</a></p><p>网站启用 h2 的前后对比，使用 <a href="http://www.webpagetest.org/" target="_blank" rel="noopener">WebPageTest</a> 做的测试，第一张是 h1，第二张是 h2:</p><p><img src="https://src.wangriyu.wang/images/blog/http/webtest-h1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/webtest-h2.png" alt="image"></p><h3 id="使用-HTTP-2-建议"><a href="#使用-HTTP-2-建议" class="headerlink" title="使用 HTTP/2 建议"></a>使用 HTTP/2 建议</h3><p>nginx 开启 HTTP2 只需在相应的 HTTPS 设置后加上 <code>http2</code> 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen [::]:443 ssl http2 ipv6only=on;</span><br><span class="line">listen 443 ssl http2;</span><br></pre></td></tr></table></figure><h4 id="以下几点是-HTTP-1-和-HTTP-2-都同样适用的"><a href="#以下几点是-HTTP-1-和-HTTP-2-都同样适用的" class="headerlink" title="以下几点是 HTTP/1 和 HTTP/2 都同样适用的"></a>以下几点是 HTTP/1 和 HTTP/2 都同样适用的</h4><p>1、开启压缩</p><p>配置 gzip 等可以使传输内容更小，传输速度更快</p><p>例如 nginx 可以再 http 模块中加入以下字段，其他字段和详细解释可以谷歌</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gzip  on; // 开启</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">gzip_comp_level 1; // 压缩级别</span><br><span class="line">gzip_types text/plain application/javascript application/x-javascript application/octet-stream application/json text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml; // 需要压缩的文件类型</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br></pre></td></tr></table></figure><p>2、使用缓存</p><p>给静态资源设置一个缓存期是非常有必要的，关于缓存见另一篇博文 <code>HTTP Message</code></p><p>例如 nginx 在 server 模块中添加以下字段可以设置缓存时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~* ^.+\.(ico|gif|jpg|jpeg|png|moc|mtn|mp3|mp4|mov)$ &#123;</span><br><span class="line">  access_log   off;</span><br><span class="line">  expires      30d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(css|js|txt|xml|swf|wav|json)$ &#123;</span><br><span class="line">  access_log   off;</span><br><span class="line">  expires      5d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line">  expires      24h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class="line">  access_log   off;</span><br><span class="line">  expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、CDN 加速</p><p>CDN 的好处是就近访问，延迟低，访问快</p><p>4、减少 DNS 查询</p><p>每个域名都需要 DNS 查询，一般需要几毫秒到几百毫秒，移动环境下会更慢。DNS 解析完成之前，请求会被阻塞。减少 DNS 查询也是优化项之一</p><p>浏览器的 <a href="https://en.wikipedia.org/wiki/Link_prefetching" target="_blank" rel="noopener">DNS Prefetching</a> 技术也是一种优化手段</p><p>5、减少重定向</p><p>重定向可能引入新的 DNS 查询、新的 TCP 连接以及新的 HTTP 请求，所以减少重定向也很重要。</p><p>浏览器基本都会缓存通过 301 Moved Permanently 指定的跳转，所以对于永久性跳转，可以考虑使用状态码 301。对于启用了 HTTPS 的网站，配置 HSTS 策略，也可以减少从 HTTP 到 HTTPS 的重定向</p><h4 id="但以下几点就不推荐在-HTTP-2-中用了"><a href="#但以下几点就不推荐在-HTTP-2-中用了" class="headerlink" title="但以下几点就不推荐在 HTTP/2 中用了"></a>但以下几点就不推荐在 HTTP/2 中用了</h4><p>1、域名分片</p><p>HTTP/2 对于同一域名使用一个 TCP 连接足矣，过多 TCP 连接浪费资源而且效果不见得一定好</p><p>而且资源分域会破坏 HTTP/2 的优先级特性，还会降低头部压缩效果</p><p>2、资源合并</p><p>资源合并会不利于缓存机制，而且单文件过大对于 HTTP/2 的传输不好，尽量做到细粒化更有利于 HTTP/2 传输</p><p>3、资源内联</p><p>HTTP/2 支持 Server-Push，相比较内联优势更大效果更好</p><p>而且内联的资源不能有效缓存</p><p>如果有共用，多页面内联也会造成浪费</p><h4 id="HTTP-2-最佳实践"><a href="#HTTP-2-最佳实践" class="headerlink" title="HTTP/2 最佳实践"></a>HTTP/2 最佳实践</h4><p>使用 HTTP/2 尽可能用最少的连接，因为同一个连接上产生的请求和响应越多，动态字典积累得越全，头部压缩效果也就越好，而且多路复用效率高，不会像多连接那样造成资源浪费</p><p>为此需要注意以下两点:</p><ul><li>同一域名下的资源使用同一个连接，这是 HTTP/2 的特性</li><li>不同域名下的资源，如果满足能解析到同一 IP 或者使用的是同一个证书(比如泛域名证书)，HTTP/2 可以合并多个连接</li></ul><p>所以使用相同的 IP 和证书部署 Web 服务是目前最好的选择，因为这让支持 HTTP/2 的终端可以复用同一个连接，实现 HTTP/2 协议带来的好处；而只支持 HTTP/1.1 的终端则会不同域名建立不同连接，达到同时更多并发请求的目的</p><p>比如 Google 一系列网站都是用的同一个证书:</p><p><img src="https://src.wangriyu.wang/images/blog/http/google-dns.png" alt="image"></p><p>但是这好像也会造成一个问题，我使用 nginx 搭建的 webserver，有三个虚拟主机，它们共用一套证书，其中两个我显示地配置了 http2，而剩下一个我并没有配置 http2，结果我访问未配置 http2 的站点时也变成了 http2。</p><p>我猜测应该是共用证书的原因，如果不想启用某个站点的 http2，那就不能共用证书</p><h3 id="大图片传输碰到的问题"><a href="#大图片传输碰到的问题" class="headerlink" title="大图片传输碰到的问题"></a>大图片传输碰到的问题</h3><p>先比较一下 h1 和 h2 的页面加载时间，图中绿色代表发起请求收到响应等待负载的时间，蓝色代表下载负载的时间:</p><p><img src="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h2.png" alt="image"></p><p>可以发现 h2 加载时间还比 h1 慢一点，特别是碰到大图片时差别更明显</p><p>这篇文章对不同场景下 h1 和 h2 加载图片做了测试: <a href="https://99designs.com/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/" target="_blank" rel="noopener">Real–world HTTP/2: 400gb of images per day</a></p><p>其结果是:</p><ul><li><p>对一个典型的富图像，延迟限制 (latency–bound) 的界面来说。使用一个高速，低延迟的连接，视觉完成度 (visual completion) 平均会快 5%。</p></li><li><p>对一个图像极其多，带宽限制 (bandwidth–bound) 的页面来说。使用同样的连接，视觉完成度平均将会慢 5–10%，但页面的整体加载时间实际是减少了，因为得益于连接延迟少。</p></li><li><p>一个高延迟，低速度的连接(比如移动端的慢速 3G) 会对页面的视觉完成造成极大的延迟，但 h2 的视觉完成度明显更高更好。</p></li></ul><p>在所有的测试中，都可以看到: h2 使整体页面的加载速度提高了，并且在初次绘制 (initial render) 上做的更好，虽然第二种情况中视觉完成度略微下降，但总体效果还是好的</p><p>视觉完成度下降的原因是因为没有 HTTP/1.x 同时连接数量的限制，h2 可以同时发起多张图片的请求，服务器可以同时响应图片的负载，可以从下面的动图中看到</p><p><img src="https://src.wangriyu.wang/images/blog/http/safari-h2.gif" alt="image"></p><p>一旦图片下载完成，浏览器就会绘制出它们，然而，小图片下载后会渲染地更快，但是如果一个大图片恰好是初始的视图，那就会花费较长的时间加载，延迟视觉上的完成度。</p><h4 id="chrome-bug"><a href="#chrome-bug" class="headerlink" title="chrome bug"></a>chrome bug</h4><p>上面的动图是在 Safari 上的测试结果，图片最后都下载成功了，而我在 Chrome 上测试时后面的部分图片直接挂了，都报 <code>ERR_SPDY_PROTOCOL_ERROR</code> 错误，而且是百分百复现</p><p><img src="https://src.wangriyu.wang/images/blog/http/chrome-h2.gif" alt="image"></p><p>去看了下 <code>ERR_SPDY_PROTOCOL_ERROR</code> 出在哪，发现是 Server reset stream，应该是哪出错了导致流提前终止</p><p><img src="https://src.wangriyu.wang/images/blog/http/spdyerror-0.png" alt="image"></p><p>然后再研究了一下 HTTP/2 的帧序列，发出的请求都在 629 号消息中响应成功了，但是返回的数据帧只有流 15 上的，实际收到的图片又不止流 15 对应的图片，这是为什么?</p><p><img src="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-0.png" alt="image"></p><p>后面我继续测试发现连续请求几张大图片，虽然 HEADERS 帧都打开的是不同的流，返回的响应的 HEADERS 帧也还是对应前面的流 ID，但是响应的 DATA 帧都是从第一个打开的流上返回的。</p><p>如果是小图片的话，一个请求响应过后这个流就关闭了，下一张小图是在其自己对应的流上返回的。只有连续几张大图会出现上述情形，这个机制很奇怪，我暂时还没有找到解释的文档。</p><p>至于 chrome 为什么出错呢，看一下 TCP 报文就会发现所有数据在一个连接上发送，到后面 TCP 包会出现各种问题，丢包、重传、失序、重包等等，不清楚 Safari 是否也是这样，因为 wireshark 只能解 chrome 的包解不了 Safari 的包</p><p><img src="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-1.png" alt="image"></p><blockquote><p>《web 性能权威指南》中提及 HTTP/2 中一个 TCP 可能会造成的问题:<br>虽然消除了 HTTP 队首阻塞现象，但 TCP 层次上仍存在队首阻塞问题；如果 TCP 窗口缩放被禁用，那带<a href="https://zh.wikipedia.org/wiki/%E5%B8%A6%E5%AE%BD%E6%97%B6%E5%BB%B6%E4%B9%98%E7%A7%AF" target="_blank" rel="noopener">宽延迟积效应</a>可能会限制连接的吞吐量；丢包时 TCP 拥塞窗口会缩小；</p></blockquote><p>TCP 是一方面原因，还有另一方面应该是浏览器策略问题，估计也是 chrome bug，对比两张动图你会发现，safari 接收负载是轮流接收，我们几个接收一点然后换几个人接收，直到所有都接受完；而 chrome 则是按顺序接收，这个接收完才轮到下一个接收，结果后面的图片可能长时间未响应就挂了。</p><h4 id="使用渐进式图片"><a href="#使用渐进式图片" class="headerlink" title="使用渐进式图片"></a>使用渐进式图片</h4><p>渐进式 jpg 代替普通 jpg 有利于提高视觉完成度，而且文件更小:</p><p>输入 <code>convert --version</code> 看看是否已安装 <a href="http://www.imagemagick.org/" target="_blank" rel="noopener">ImageMagic</a>，如果没有先安装: Mac 可以用 <code>brew install imagemagick</code>，Centos 可以用 <code>yum install imagemagick</code></p><p>检测是否为 progressive jpeg，如果输出 None 说明不是 progressive jpeg；如果输出 JPEG 说明是 progressive jpeg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ identify -verbose filename.jpg | grep Interlace</span><br></pre></td></tr></table></figure><p>将 basic jpeg 转换成 progressive jpeg，<a href="https://www.imagemagick.org/script/command-line-options.php#interlace" target="_blank" rel="noopener">interlace 参数</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ convert -strip -interlace Plane source.jpg destination.jpg // 还可以指定质量 -quality 90</span><br><span class="line"></span><br><span class="line">// 批量处理</span><br><span class="line">$ for i in ./*.jpg; do convert -strip -interlace Plane $i $i; done</span><br></pre></td></tr></table></figure><p>也可以转换 PNG 和 GIF，但是我试过 <code>convert -strip -interlace Plane source.png destination.png</code> 但转换后的图片往往会更大，不推荐这么用，可以 convert source.png destination.jpg</p><p>ImageMagic 还有很多强大的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 图片缩放</span><br><span class="line">$ convert -resize 50%x50% source.jpg destination.jpg</span><br><span class="line">// 图片格式转换</span><br><span class="line">$ convert source.jpg destination.png</span><br><span class="line">// 配合 find 命令，将当前目录下大于 100kb 的图片按 75% 质量进行压缩</span><br><span class="line">$ find -E . -iregex &apos;.*\.(jpg|png|bmp)&apos; -size +100k -exec convert -strip +profile “*” -quality 75 &#123;&#125; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>png 压缩推荐使用 <a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a></p><p>另外 photoshop 保存图片时也可以设置渐进或交错:</p><p>渐进式图片：选择图片格式为 JPEG =&gt; 选中“连续”</p><p>交错式图片：选择图片格式为 PNG/GIF =&gt; 选中“交错”</p><h3 id="SPDY-与-HTTP2-的关系"><a href="#SPDY-与-HTTP2-的关系" class="headerlink" title="SPDY 与 HTTP2 的关系"></a>SPDY 与 HTTP2 的关系</h3><p><a href="https://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a> 是 HTTP2 的前身，大部分特性与 HTTP2 保持一致，包括服务器端推送，多路复用和帧作为传输的最小单位。但 SPDY 与 HTTP2 也有一些实现上的不同，比如 SPDY 的头部压缩使用的是 DEFLATE 算法，而 HTTP2 使用的是 HPACK 算法，压缩率更高。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>Google 的 <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">QUIC(Quick UDP Internet Connections)</a> 协议，继承了 SPDY 的特点。QUIC 是一个 UDP 版的 TCP + TLS + HTTP/2 替代实现。</p><p>QUIC 可以创建更低延迟的连接，并且也像 HTTP/2 一样，通过仅仅阻塞部分流解决了包裹丢失这个问题，让连接在不同网络上建立变得更简单 － 这其实正是 <a href="https://en.wikipedia.org/wiki/Multipath_TCP" target="_blank" rel="noopener">MPTCP</a> 想去解决的问题。</p><p>QUIC 现在还只有 Google 的 Chrome 和它后台服务器上的实现，虽然有第三方库 libquic，但这些代码仍然很难在其他地方被复用。该协议也被 IETF 通信工作组引入了草案。</p><p><a href="https://github.com/mholt/caddy" target="_blank" rel="noopener">Caddy</a>: 基于 Go 语言开发的 Web Server， 对 HTTP/2 和 HTTPS 有着良好的支持，也开始支持 QUIC 协议 (试验性)</p><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><ul><li>Chrome 插件: <a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">HTTP/2 and SPDY indicator</a></li></ul><p>如果你访问的站点开启了 HTTP/2，图标会亮起，而且点击会进入 chrome 内置的 HTTP/2 监视工具</p><ul><li>命令行工具: <a href="https://github.com/nghttp2/nghttp2" target="_blank" rel="noopener">nghttp2</a></li></ul><p>C 语言实现的 HTTP/2，可以用它调试 HTTP/2 请求</p><p>直接 <code>brew install nghttp2</code> 就可以安装，安装好后输入 <code>nghttp -nv https://nghttp2.org</code> 就可以查看 h2 请求</p><p><img src="https://src.wangriyu.wang/images/blog/http/nghttp2.png" alt="image"></p><ul><li>还可以用 wireshark 解 h2 的包，不过得设置浏览器提供的对称协商密钥或者服务器提供的私钥，具体方法看此文: <a href="https://imququ.com/post/http2-traffic-in-wireshark.html" target="_blank" rel="noopener">使用 Wireshark 调试 HTTP/2 流量</a></li></ul><p>如果无法解包看一下 sslkeylog.log 文件有没有写入数据，如果没有数据说明浏览器打开方式不对，得用命令行打开浏览器，这样才能让浏览器读取环境变量然后向 sslkeylog 写入密钥，另外此方法好像支持谷歌浏览器和火狐，对 Safari 无效</p><p>如果 sslkeylog.log 有数据，wireshark 还是无法解包，打开设置的 SSL 选项重新选择一下文件试试，如果还是不行也用命令行打开 Wireshark</p><p>一次不行多试几次</p><ul><li><a href="https://github.com/h2o/h2o" target="_blank" rel="noopener">h2o</a>: 优化的 HTTP Server，对 HTTP/2 的支持性做的比较好</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.slideshare.net/qgy18/http2-55366951" target="_blank" rel="noopener">HTTP/2: 新的机遇与挑战</a></li><li><a href="https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.p19" target="_blank" rel="noopener">HTTP2 is here, let’s optimize!</a></li><li><a href="https://imququ.com/post/series.html" target="_blank" rel="noopener">JerryQu’s Blog</a></li><li><a href="https://daniel.haxx.se/http2/" target="_blank" rel="noopener">http2 explained</a></li><li><a href="https://cdn-1.wp.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf" target="_blank" rel="noopener">NGINX HTTP2 White Paper</a></li><li><a href="https://calendar.perfplanet.com/2016/http2-push-the-details/" target="_blank" rel="noopener">HTTP/2 Push: The details</a></li><li>《web 性能权威指南》</li></ul>]]></content>
    
    <summary type="html">
    
      秉着 WTF(What the hell is That, Find the answers!) 原则探究 HTTP2，结合理论与实践，广度与深度并存
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家</title>
    <link href="https://blog.wangriyu.wang/2018/05-server-git.html"/>
    <id>https://blog.wangriyu.wang/2018/05-server-git.html</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-06-09T09:31:17.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>3 月份腾讯云搞了一波活动，我也跟了一波车，花了 360 换了五年的服务器，美滋滋！虽然后来四月份阿里云也出了活动，我是更喜欢阿里云的，但是这波也不算亏。有了服务器之后做的第一件事就是把博客搬到服务器上，其实两个月前就弄好了，后来又折腾服务器去了，本来想等各种东西都折腾一遍后再写这篇博客，但是一拖拖到现在，罪过罪过！</p><blockquote><p>系统环境为 CentOS 7.4，默认用户为 root</p></blockquote><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>新系统需要安装更新和一些常用工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y update</span><br><span class="line">// 安装 node 和 npm</span><br><span class="line">$ yum install epel-release</span><br><span class="line">$ yum install nodejs</span><br><span class="line">$ node --version</span><br><span class="line">$ npm --version</span><br><span class="line">// 设置 npm 源</span><br><span class="line">$ npm config get registry</span><br><span class="line">$ npm config set registry https://registry.npm.taobao.org</span><br><span class="line">// 可以安装 node 版本管理工具 n</span><br><span class="line">$ npm install -g n</span><br><span class="line">$ n stable</span><br><span class="line">// 安装 git</span><br><span class="line">$ yum install git</span><br><span class="line">$ git --version</span><br></pre></td></tr></table></figure><h2 id="修改域名解析"><a href="#修改域名解析" class="headerlink" title="修改域名解析"></a>修改域名解析</h2><p>原本域名是解析到 wangriyu.github.io 上，现在改为 A 类 ip 地址，填服务器的公有 ip</p><h2 id="设置-webserver"><a href="#设置-webserver" class="headerlink" title="设置 webserver"></a>设置 webserver</h2><h3 id="安装最新版-nginx"><a href="#安装最新版-nginx" class="headerlink" title="安装最新版 nginx"></a>安装最新版 nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>写入以下内容，baseurl 根据系统修改如果是 centos 6 的话把当中的 7 改成 6，输入 <code>cat /etc/centos-release</code> 或者 <code>hostnamectl</code> 可以查看系统版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=0</span><br></pre></td></tr></table></figure><p>清空缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean all</span><br><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure><p>输入 list 可以查看是否包含最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list | grep nginx</span><br></pre></td></tr></table></figure><p>然后安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nginx</span><br><span class="line">$ nginx -V # 查看版本</span><br><span class="line">$ rpm -ql nginx # 列出nginx的安装文件</span><br></pre></td></tr></table></figure><p>启动服务并设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start nginx</span><br><span class="line">$ systemctl enable nginx</span><br></pre></td></tr></table></figure><p>此时访问服务器 ip 应该可以看到 nginx 的默认欢迎页了</p><h3 id="添加-Let’-Encrypt-通配符证书"><a href="#添加-Let’-Encrypt-通配符证书" class="headerlink" title="添加 Let’ Encrypt 通配符证书"></a>添加 Let’ Encrypt 通配符证书</h3><blockquote><p>国内的域名需要先备案，不然最后生成证书的时候可能会失败</p></blockquote><p>使用 CertBot 来生成证书，不同系统的方法可以到官网看: <a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/centosrhel7-nginx</a></p><p>安装 Certbot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install yum-utils</span><br><span class="line">$ yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional</span><br><span class="line">$ yum install certbot-nginx</span><br></pre></td></tr></table></figure><p>生成证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ certbot certonly --manual -d *.wangriyu.wang -d wangriyu.wang --agree-tos --manual-public-ip-logging-ok --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure><p>第一步会要求你去添加一条 TXT DNS 解析记录，添加完后最好多等几分钟，等 DNS 生效再进入下一步，<br>如果验证失败了需要重新解析</p><p><img src="https://src.wangriyu.wang/images/blog/server/certbot.png" alt="image"></p><p>证书创建好后会输出证书位置，可以到 nginx 里设置虚拟机的 ssl_certificate 和 ssl_certificate_key 为生成的证书位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ certbot certificates // 查看本地证书信息</span><br><span class="line"></span><br><span class="line">$ certbot delete // 删除证书</span><br></pre></td></tr></table></figure><p>Let’s Encrypt 证书只有 90 天有效期，快到期时可以用 <code>certbot renew</code> 更新证书，更简单的做法是添加一个 cron 任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line">写入 30 0 1 * * root /usr/bin/certbot renew --renew-hook &quot;/usr/sbin/nginx -s reload&quot;</span><br><span class="line">$ crontab -l # 查看所有任务</span><br><span class="line">$ service crond restart</span><br></pre></td></tr></table></figure><p>每个月 1 号 0 点 30 分会自动执行该任务并重载 nginx</p><blockquote><p>如果之后使用 certbot 出现 ImportError: ‘pyOpenSSL’ module missing required functionality. Try upgrading to v0.14 or newer. 错误<br>依次输入以下命令修复</p><blockquote><p>$ pip uninstall requests<br>$ pip uninstall urllib3<br>$ yum remove python-urllib3<br>$ yum remove python-requests<br>$ yum remove certbot<br>$ yum install python-urllib3<br>$ yum install python-requests<br>$ yum install certbot</p></blockquote></blockquote><h3 id="配置服务器和虚拟机"><a href="#配置服务器和虚拟机" class="headerlink" title="配置服务器和虚拟机"></a>配置服务器和虚拟机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/nginx</span><br><span class="line">$ tree .</span><br><span class="line">├── conf.d # 虚拟机文件，最好一个域名一个文件</span><br><span class="line">│   ├── default.conf</span><br><span class="line">│   ├── blog.wangriyu.wang.conf</span><br><span class="line">│   └── wangriyu.wang.conf</span><br><span class="line">├── default.d</span><br><span class="line">├── nginx.conf # 服务器配置文件</span><br><span class="line">├── ssl</span><br><span class="line">│   └── dhparam.pem</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>详细的设置我这不多说，上网搜一下 nginx 配置大把教程，我这里贴一下我的配置，仅作参考</p><ul><li>nginx.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    # access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line">    tcp_nodelay    on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  60;</span><br><span class="line"></span><br><span class="line">    server_tokens off;</span><br><span class="line"></span><br><span class="line">    # 设置 gzip 压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 3;</span><br><span class="line">    gzip_buffers    16 8k;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript application/octet-stream application/json text/css application/xml text/javascript application/x-httpd-php image/jpeg image/jpg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_proxied       any;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line">    fastcgi_intercept_errors on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>blog.wangriyu.wang.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     server_name  blog.wangriyu.wang;</span><br><span class="line"></span><br><span class="line">     # Load configuration files for the default server block.</span><br><span class="line">     include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">     # 开启 tls 和 http2</span><br><span class="line">     listen [::]:443 ssl http2 ipv6only=on; # managed by Certbot</span><br><span class="line">     listen 443 ssl http2; # managed by Certbot</span><br><span class="line">     ssl_certificate /path/to/fullchain.pem; # managed by Certbot</span><br><span class="line">     ssl_certificate_key /path/to/privkey.pem; # managed by Certbot</span><br><span class="line">     include /path/to/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">     ssl_dhparam /path/to/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">     # 优化 OCSP 查询</span><br><span class="line">     ssl_stapling on;</span><br><span class="line">     ssl_stapling_verify on;</span><br><span class="line">     ssl_trusted_certificate /path/to/letsencrypt/live/wangriyu.wang/chain.pem;</span><br><span class="line"></span><br><span class="line">     resolver                 8.8.4.4 8.8.8.8  valid=300s;</span><br><span class="line">     resolver_timeout         10s;</span><br><span class="line"></span><br><span class="line">     # HSTS 策略</span><br><span class="line">     add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot; always;</span><br><span class="line"></span><br><span class="line">     # 静态文件目录</span><br><span class="line">     root /www/website;</span><br><span class="line">     index index.html index.htm;</span><br><span class="line"></span><br><span class="line">     # 设置 http2 的 ServerPush 文件，需要 nginx/1.13.9 以上才支持此功能</span><br><span class="line">     location = /index.html &#123;</span><br><span class="line">       http2_push /css/style.css;</span><br><span class="line">       http2_push /js/main.js;</span><br><span class="line">       http2_push /img/yule.jpg;</span><br><span class="line">       http2_push /img/avatar.jpg;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     # 设置静态文件缓存时间</span><br><span class="line">     location ~* ^.+\.(ico|gif|jpg|jpeg|png|moc|mtn|mp3|mp4|mov)$ &#123;</span><br><span class="line">       access_log   off;</span><br><span class="line">       etag         on;</span><br><span class="line">       expires      30d;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     location ~* ^.+\.(css|js|txt|xml|swf|wav|json)$ &#123;</span><br><span class="line">       access_log   off;</span><br><span class="line">       etag         on;</span><br><span class="line">       expires      5d;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line">       etag         on;</span><br><span class="line">       expires      24h;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     location ~* ^.+\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class="line">       access_log   off;</span><br><span class="line">       etag         on;</span><br><span class="line">       expires      30d;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     # 设置 404 错误页</span><br><span class="line">     error_page 404 403 /404.html;</span><br><span class="line">     location = /404.html &#123;</span><br><span class="line">       root /www/website;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     error_page 500 502 503 504 /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 重定向非加密连接的访问</span><br><span class="line">server &#123;</span><br><span class="line">    if ($host = blog.wangriyu.wang) &#123;</span><br><span class="line">      return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    listen       80 default_server;</span><br><span class="line">    listen       [::]:80 default_server;</span><br><span class="line">    server_name  blog.wangriyu.wang;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>wangriyu.wang.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name wangriyu.wang;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line"></span><br><span class="line">    return 301 https://blog.wangriyu.wang$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 nginx 的配置推荐看下屈大大的博客: <a href="https://imququ.com/post/my-nginx-conf-for-wpo.html" target="_blank" rel="noopener">Nginx 配置之性能篇</a> 和 <a href="https://imququ.com/post/my-nginx-conf-for-security.html" target="_blank" rel="noopener">Nginx 配置之安全篇</a></p><p>通过优化 SEO 分数比 githubpage 要高得多</p><p><img src="https://src.wangriyu.wang/images/blog/server/blog.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/server/home.png" alt="image"></p><p>nginx 访问的目录要存放博客生成的静态文件，接下来会介绍如何使用 git 部署</p><h2 id="搭建-Git-服务"><a href="#搭建-Git-服务" class="headerlink" title="搭建 Git 服务"></a>搭建 Git 服务</h2><p>之前博客是托管在 github 上的，我是在本地编辑完后再 push 到远端。现在放到服务器上，若用 git 部署，需要在服务器上搭建 Git 服务。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建一个 git 专用的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -m git</span><br><span class="line">$ passwd git # 设置密码，之后部署时登录用</span><br></pre></td></tr></table></figure><p>禁用 git 用户的 shell 登录权限</p><p>出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd 来实现，在 /etc/passwd 中找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001::/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>将 bash 改为 git-shell，可以通过 <code>which git-shell</code> 获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>新建一个 git 仓库地址比如 <code>/data/git-repo</code>。然后在这个文件夹里创建 blog.git 这个仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /data/git-repo</span><br><span class="line">$ cd /data/git-repo</span><br><span class="line">$ git init --bare blog.git</span><br></pre></td></tr></table></figure><p>然后进入 blog.git 可以看到 hooks 文件夹，可以再这里面写 Git Hook 脚本，不了解钩子的可以看下 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Git 钩子</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog.git/hooks</span><br><span class="line">$ vi post-update</span><br><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/www/website --git-dir=/data/git-repo/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>worktree 就是我们要放置静态文件的目录，每次这个裸库收到 git 更新时会把文件更新到 worktree，这样 nginx 就可以访问新部署的文件了</p><p>如果 post-update 不是可执行权限，输入 <code>chmod +x post-update</code> 设置为可执行</p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>这里要注意的一点是除了要设置仓库的所有者和可读写权限外，还要设置工作目录，即静态文件存放的地方，要不然钩子函数可能更新不了工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R git:git /data/git-repo/blog.git</span><br><span class="line">$ chmod 755 /data/git-repo/blog.git</span><br><span class="line"></span><br><span class="line">$ chown -R git:git /www/website</span><br><span class="line">$ chmod 755 /www/website</span><br></pre></td></tr></table></figure><p>到本地使用 git 克隆服务器上的仓库测试一下是否可用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@&lt;CVM IP&gt;:/data/git-repo/blog.git</span><br></pre></td></tr></table></figure><p>到此服务器的配置应该已经结束</p><h2 id="测试本地编辑部署"><a href="#测试本地编辑部署" class="headerlink" title="测试本地编辑部署"></a>测试本地编辑部署</h2><p>到 hexo 博客目录，编辑站点配置文件 <code>_config.yml</code> 的 deploy 选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      github: git@github.com:wangriyu/wangriyu.github.io.git</span><br><span class="line">      server: git@&lt;CVM IP&gt;:/data/git-repo/blog.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>之后同样使用 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 即可部署到服务器上了</p><h2 id="升级-vim"><a href="#升级-vim" class="headerlink" title="升级 vim"></a>升级 vim</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/yum.repos.d/</span><br><span class="line">$ wget https://copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo</span><br><span class="line">$ rpm --import https://copr-be.cloud.fedoraproject.org/results/mcepl/vim8/pubkey.gpg</span><br><span class="line">$ yum update vim</span><br></pre></td></tr></table></figure><p>如果 update vim 报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction check error:</span><br><span class="line">  file /usr/share/man/man1/vim.1.gz from install of vim-common-2:8.0.1735-1.0.96.el7.centos.x86_64 conflicts with file from package vim-minimal-2:7.4.160-2.el7.x86_64</span><br><span class="line"></span><br><span class="line">Error Summary</span><br></pre></td></tr></table></figure><p>先执行一下 <code>yum erase vim-minimal</code> 再 <code>yum update vim</code></p><p>如果升级后发现只能用 <code>vim</code> 命令不能用 <code>vi</code>，设置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /usr/bin | grep vi</span><br><span class="line">$ cp /usr/bin/vim /usr/bin/vi</span><br></pre></td></tr></table></figure><p>推荐安装 oh-my-zsh，配合 <a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a> 插件和合适的主题，可以大大改善 shell 使用体验</p><p>接下来会写几篇折腾服务器的博客，比如搭建 FTP、nextcloud、docker 等等</p>]]></content>
    
    <summary type="html">
    
      把博客从 github 搬到自己的服务器上，如何搭建 git 服务并用 git 部署
    
    </summary>
    
      <category term="Server" scheme="https://blog.wangriyu.wang/categories/Server/"/>
    
    
      <category term="server" scheme="https://blog.wangriyu.wang/tags/server/"/>
    
      <category term="git" scheme="https://blog.wangriyu.wang/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Golang http/server</title>
    <link href="https://blog.wangriyu.wang/2018/04-go-http.html"/>
    <id>https://blog.wangriyu.wang/2018/04-go-http.html</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p><img src="https://src.wangriyu.wang/images/blog/go/server.png" alt="image"></p><h3 id="server-与-conn-等接口"><a href="#server-与-conn-等接口" class="headerlink" title="server 与 conn 等接口"></a>server 与 conn 等接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr              <span class="keyword">string</span>        <span class="comment">// 要监听的 TCP 地址</span></span><br><span class="line">    Handler           Handler       <span class="comment">// 调用的 handler, 如果为空则用 http.DefaultServeMux</span></span><br><span class="line">    TLSConfig         *tls.Config   <span class="comment">// 用于 ServeTLS 和 ListenAndServeTLS</span></span><br><span class="line">    ReadTimeout       time.Duration <span class="comment">// 读取完整 request (包括 body) 的最大时长，可以和 ReadHeaderTimeout 同时使用</span></span><br><span class="line">    ReadHeaderTimeout time.Duration <span class="comment">// 读取 request headers 的最大时长</span></span><br><span class="line">    WriteTimeout      time.Duration <span class="comment">// 写 response 的最大时长</span></span><br><span class="line">    IdleTimeout       time.Duration <span class="comment">// 当 keepalive 开启时等待下个 request 的最大时长，此值为空时使用 ReadTimeout 值代替，ReadTimeout 也为空使用 ReadHeaderTimeout 代替</span></span><br><span class="line">    MaxHeaderBytes    <span class="keyword">int</span>           <span class="comment">// 解析 request headers 里键值对的最大字节数 (包含请求行)，不限制 body. 如果为 0, 使用 DefaultMaxHeaderBytes 代替</span></span><br><span class="line">    TLSNextProto      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span> // 当 '应用层协议协商 <span class="params">(NPN/ALPN)</span>' 时发生协议升级时，<span class="title">TLSNextProto</span> 需要指定可选的 <span class="title">function</span> 去接管 <span class="title">TLS</span> 连接</span></span><br><span class="line"><span class="function">    <span class="title">ConnState</span>         <span class="title">func</span><span class="params">(net.Conn, ConnState)</span> // 指定一个可选的钩子函数，由 <span class="title">client</span> 连接状态改变触发</span></span><br><span class="line"><span class="function">    <span class="title">ErrorLog</span>          *<span class="title">log</span>.<span class="title">Logger</span>   // 指定一个可选的 <span class="title">logger</span> 接收错误日志. 如果为空则由 <span class="title">log</span> 包接管</span></span><br><span class="line"><span class="function">    <span class="title">disableKeepAlives</span> <span class="title">int32</span>         // 在 <span class="title">SetKeepAlivesEnabled</span> 中设置，为 1 表示取消长连接，为 0 保持长连接 <span class="params">(默认)</span></span></span><br><span class="line"><span class="function">    <span class="title">inShutdown</span>        <span class="title">int32</span>         // 非零代表 <span class="title">in</span> <span class="title">Shutdown</span></span></span><br><span class="line"><span class="function">    <span class="title">nextProtoOnce</span>     <span class="title">sync</span>.<span class="title">Once</span>     // 设置 <span class="title">HTTP</span>/2</span></span><br><span class="line"><span class="function">    <span class="title">nextProtoErr</span>      <span class="title">error</span>         // <span class="title">http2</span>.<span class="title">ConfigureServer</span> 的结果</span></span><br><span class="line"><span class="function">    <span class="title">mu</span>                <span class="title">sync</span>.<span class="title">Mutex</span></span></span><br><span class="line"><span class="function">    <span class="title">listeners</span>         <span class="title">map</span>[<span class="title">net</span>.<span class="title">Listener</span>]<span class="title">struct</span></span>&#123;&#125;</span><br><span class="line">    activeConn        <span class="keyword">map</span>[*conn]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    doneChan          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// doneChan 代表任务结束</span></span><br><span class="line">    onShutdown        []<span class="function"><span class="keyword">func</span><span class="params">()</span>      // 通过 <span class="title">RegisterOnShutdown</span> 注册，在 <span class="title">Shutdown</span> 时调用当中的钩子函数</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 此接口由 <span class="title">ResponseWriters</span> 执行去检测连接是否已断开，此机制允许客户端断开后服务端取消一个长连接</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">CloseNotifier</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">    CloseNotify() &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// conn 代表服务端的 HTTP 连接</span></span><br><span class="line"><span class="keyword">type</span> conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    server     *Server</span><br><span class="line">    cancelCtx  context.CancelFunc   <span class="comment">// 撤销连接层的 context，读写出错时会调用</span></span><br><span class="line">    rwc        net.Conn             <span class="comment">//</span></span><br><span class="line">    remoteAddr <span class="keyword">string</span>               <span class="comment">// rwc.RemoteAddr().String()</span></span><br><span class="line">    tlsState   *tls.ConnectionState <span class="comment">// TLS 连接状态，nil 代表非 TSL</span></span><br><span class="line">    werr       error                <span class="comment">// rwc 写入时的首个错误 (bufw 写入时)</span></span><br><span class="line">    r          *connReader          <span class="comment">// 一个 *conn 使用的 io.reader 封装，存有 bufr 的读取内容</span></span><br><span class="line">    bufr       *bufio.Reader        <span class="comment">// 从 r 读取</span></span><br><span class="line">    bufw       *bufio.Writer        <span class="comment">// 要写入 checkConnErrorWriter&#123;c&#125; 的缓冲</span></span><br><span class="line">    lastMethod <span class="keyword">string</span></span><br><span class="line">    curReq     atomic.Value <span class="comment">// 存入 *response (response 中包含 request)</span></span><br><span class="line">    curState   atomic.Value <span class="comment">// 存入 ConnState</span></span><br><span class="line">    mu         sync.Mutex   <span class="comment">// 保护 hijackedv</span></span><br><span class="line">    hijackedv  <span class="keyword">bool</span>         <span class="comment">// 代表连接是否已经被 hijacke</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 ctx 带有一个截止期限，一个取消信号，或者其他绑定值</span></span><br><span class="line"><span class="comment">// 其函数可以被多个 goroutines 同时使用</span></span><br><span class="line"><span class="comment">// 一个请求过来时可能会涉及到多个 goroutines，Ctx 可以控制关闭与之相关联和派生出的子 ctx 相关联的 goroutines</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Deadline 方法是获取设置的截止时间，第一个返回值是截止时间，到了这个时间点，Context 会自动发起取消请求；</span></span><br><span class="line">	<span class="comment">// 第二个返回值 ok==false 时表示没有设置截止时间，如果需要取消的话，需要调用 cancel 函数进行取消，取消操作包括派生出去的子 Ctx</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 在 goroutine 中，如果该方法返回的 chan 可以读取，则意味着 parent context 已经发起了取消请求，</span></span><br><span class="line">	<span class="comment">// 我们通过 Done 方法收到这个信号后，就应该做清理操作，然后退出 goroutine，释放资源</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 如果 Done 还没关闭，Err 返回 nil</span></span><br><span class="line">    <span class="comment">// 如果 Done 已经关闭，返回非空 err，告知 Ctx 因何取消</span></span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 键值对形式，与 Ctx 绑定，可以为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve 接收 listener 上过来的连接，并为每个连接创建 service 线程</span></span><br><span class="line"><span class="comment">// 在 service 线程中会读取 request 并调用 srv.Handler 进行服务</span></span><br><span class="line"><span class="comment">// handler 参数一般传 nil 就行，代表使用的是 DefaultServeMux</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span> <span class="title">error</span></span> &#123; <span class="comment">// HTTPS: ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error</span></span><br><span class="line">	srv := &amp;Server&#123;Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(l) <span class="comment">// HTTPS: srv.ServeTLS(l, certFile, keyFile)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func HelloServer(w http.ResponseWriter, req *http.Request) &#123;</span></span><br><span class="line"><span class="comment">//     io.WriteString(w, "hello, world!\n")</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func main() &#123;</span></span><br><span class="line"><span class="comment">//     http.HandleFunc("/hello", HelloServer)</span></span><br><span class="line"><span class="comment">//     log.Fatal(http.ListenAndServe(":12345", nil))</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)</span></span><br><span class="line"><span class="comment">// HTTPS 方式，可以使用 crypto/tls 中的 generate_cert.go 生成 cert.pem 和 key.pem</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr, certFile, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServeTLS(certFile, keyFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe 监听 srv.Addr 地址上的 tcp 网络，然后调用 Serve 服务连接，连接会设置 keep-alives</span></span><br><span class="line"><span class="comment">// 如果 srv.Addr 为空则用 ":http" 代替</span></span><br><span class="line"><span class="comment">// ListenAndServe 总是返回非空 err</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	addr := srv.Addr</span><br><span class="line">	<span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">		addr = <span class="string">":http"</span></span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// HTTP:</span></span><br><span class="line">	<span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HTTPS 方式调用 ListenAndServeTLS(certFile, keyFile string) error</span></span><br><span class="line">	<span class="comment">// 与 ListenAndServe 类似，只是最后要关闭 ln 并返回 srv.ServeTLS</span></span><br><span class="line">	<span class="comment">// defer ln.Close()</span></span><br><span class="line">	<span class="comment">// return srv.ServeTLS(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;, certFile, keyFile)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-的服务函数"><a href="#server-的服务函数" class="headerlink" title="server 的服务函数"></a>server 的服务函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ServeTLS</span><span class="params">(l net.Listener, certFile, keyFile <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在 srv.Serve 之前尝试设置 HTTP/2</span></span><br><span class="line">	<span class="comment">// setupHTTP2_ServeTLS 中调用 onceSetNextProtoDefaults_Serve，只有 srv.TLSNextProto 为 nil 时才可以设置 HTTP/2</span></span><br><span class="line">	<span class="keyword">if</span> err := srv.setupHTTP2_ServeTLS(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	config := cloneTLSConfig(srv.TLSConfig)</span><br><span class="line">	<span class="keyword">if</span> !strSliceContains(config.NextProtos, <span class="string">"http/1.1"</span>) &#123; <span class="comment">// strSliceContains 判断是否包含字符串</span></span><br><span class="line">		config.NextProtos = <span class="built_in">append</span>(config.NextProtos, <span class="string">"http/1.1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	configHasCert := <span class="built_in">len</span>(config.Certificates) &gt; <span class="number">0</span> || config.GetCertificate != <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> !configHasCert || certFile != <span class="string">""</span> || keyFile != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		config.Certificates = <span class="built_in">make</span>([]tls.Certificate, <span class="number">1</span>)</span><br><span class="line">		config.Certificates[<span class="number">0</span>], err = tls.LoadX509KeyPair(certFile, keyFile) <span class="comment">// LoadX509KeyPair 解析证书，文件中必须含有 PEM 编码数据</span></span><br><span class="line">		<span class="comment">// PEM (Privacy Enhancement Message)，定义见 RFC1421，是一种基于 base64 的编码格式</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tlsListener := tls.NewListener(l, config)</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(tlsListener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若启用 HTTP/2，在调用 Serve 前需要根据 listener's TLS Config 初始化 srv.TLSConfig</span></span><br><span class="line"><span class="comment">// Serve 总是返回非空的 err，在 Shutdown 或 Close 后返回 ErrServerClosed</span></span><br><span class="line"><span class="comment">// Close 是立即关闭 Server 和与之相关的 listeners 和 connections，而 shutdown 是逐步关闭 listeners 和闲置的 connections，两者不会管已被 hijack 的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line">	<span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123; <span class="comment">// 如果钩子函数 testHookServerServe 非空则调用</span></span><br><span class="line">		fn(srv, l)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration <span class="comment">// accept 失败时 sleep 多长时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setupHTTP2_Serve 和 setupHTTP2_ServeTLS 两者都是调用 onceSetNextProtoDefaults() 去尝试设置 HTTP/2</span></span><br><span class="line">    <span class="comment">// 只是考虑到多并发情况下的 Serve 请求，setupHTTP2_Serve 采用了更保守的政策去设置 HTTP/2</span></span><br><span class="line">    <span class="comment">// setupHTTP2_Serve 先调用 shouldConfigureHTTP2ForServe 判断是否应该为 Server.Serve 设置 HTTP/2</span></span><br><span class="line">    <span class="comment">// shouldConfigureHTTP2ForServe 中如果 srv.TLSConfig 为 nil 或者 srv.TLSConfig.NextProtos 包含 "h2" 字样返回真，否则返回假，</span></span><br><span class="line">	<span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	srv.trackListener(l, <span class="literal">true</span>) <span class="comment">// 将 l 添加进 server.listeners</span></span><br><span class="line">	<span class="keyword">defer</span> srv.trackListener(l, <span class="literal">false</span>) <span class="comment">// 结束后删去 l</span></span><br><span class="line"></span><br><span class="line">	baseCtx := context.Background() <span class="comment">// baseContext 会一直存在，但没有值也没有 deadline，用于主函数或者初始化或者测试或者顶层接收请求的 context</span></span><br><span class="line">	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">	<span class="comment">// WithValue 返回 baseCtx 的副本，副本内的值是一个键值对 ServerContextKey - srv</span></span><br><span class="line">	<span class="comment">// ServerContextKey = &amp;contextKey&#123;"http-server"&#125; 与其绑定的 value 类型为 *Server</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rw, e := l.Accept() <span class="comment">// 接收到连接</span></span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-srv.getDoneChan(): <span class="comment">// server 已关闭</span></span><br><span class="line">				<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">				time.Sleep(tempDelay)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> e</span><br><span class="line">		&#125;</span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		c := srv.newConn(rw)</span><br><span class="line">		<span class="comment">// conn.setState 根据传入的状态调用 trackConn 来设置 server.activeConn 集合，再改变当前 conn.curState</span></span><br><span class="line">		<span class="comment">// 如果 server 设置了 ConnState 这个钩子函数，就调用</span></span><br><span class="line">		c.setState(c.rwc, StateNew)</span><br><span class="line">		<span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-Serve-最后调用-conn-serve"><a href="#server-Serve-最后调用-conn-serve" class="headerlink" title="server.Serve 最后调用 conn.serve"></a>server.Serve 最后调用 conn.serve</h3><p>在此函数中调用 <code>serverHandler{c.server}.ServeHTTP(w, w.req)</code> 转入路由模块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">	<span class="comment">// LocalAddrContextKey = &amp;contextKey&#123;"local-addr"&#125; 与其绑定的 value 类型是 net.Addr</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span> <span class="comment">// 64 KB</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !c.hijacked() &#123; <span class="comment">// 已经被 hijack 的连接不用管理，由 hijack 的调用者处理</span></span><br><span class="line">			c.<span class="built_in">close</span>()</span><br><span class="line">			c.setState(c.rwc, StateClosed)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123; <span class="comment">// HTTPS</span></span><br><span class="line">		<span class="keyword">if</span> d := c.server.ReadTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> d := c.server.WriteTimeout; d != <span class="number">0</span> &#123;</span><br><span class="line">			c.rwc.SetWriteDeadline(time.Now().Add(d))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := tlsConn.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.server.logf(<span class="string">"http: TLS handshake error from %s: %v"</span>, c.rwc.RemoteAddr(), err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.tlsState = <span class="built_in">new</span>(tls.ConnectionState)</span><br><span class="line">		*c.tlsState = tlsConn.ConnectionState() <span class="comment">// 获取当前 TLS 连接的详细信息</span></span><br><span class="line">		<span class="comment">// NegotiatedProtocol 协商的协议，validNPN 判断 proto 是否属于 "", "http/1.1", "http/1.0" 之一，不属于返回真</span></span><br><span class="line">		<span class="keyword">if</span> proto := c.tlsState.NegotiatedProtocol; validNPN(proto) &#123;</span><br><span class="line">			<span class="keyword">if</span> fn := c.server.TLSNextProto[proto]; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">				h := initNPNRequest&#123;tlsConn, serverHandler&#123;c.server&#125;&#125;</span><br><span class="line">				fn(c.server, tlsConn, h) <span class="comment">// 发生协议切换时触发钩子函数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HTTP/1.x following</span></span><br><span class="line"></span><br><span class="line">	ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">	<span class="comment">// WithCancel 返回 &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span></span><br><span class="line">	<span class="comment">// ctx.cancel close ctx.done 取消所有 ctx 的 children，如果第一个参数为 true，则把 ctx 从其 parent 的 children 列表删去</span></span><br><span class="line">	c.cancelCtx = cancelCtx</span><br><span class="line">	<span class="keyword">defer</span> cancelCtx() <span class="comment">// 关闭 ctx，以及相关 goroutines</span></span><br><span class="line"></span><br><span class="line">	c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">	c.bufr = newBufioReader(c.r)</span><br><span class="line">	c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		w, err := c.readRequest(ctx) <span class="comment">// 读取 request 返回 response 和可能的 err</span></span><br><span class="line">		<span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123; <span class="comment">// remain 代表 io.reader 剩余空间，initialReadLimitSize 返回 int64(srv.MaxHeaderBytes &gt; 0 ? srv.MaxHeaderBytes : DefaultMaxHeaderBytes) + 4096</span></span><br><span class="line">			c.setState(c.rwc, StateActive) <span class="comment">// StateActive 代表连接已经从 request 读到数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> errorHeaders = <span class="string">"\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err == errTooLarge &#123; <span class="comment">// errors.New("http: request too large")</span></span><br><span class="line">				<span class="keyword">const</span> publicErr = <span class="string">"431 Request Header Fields Too Large"</span></span><br><span class="line">				fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">				c.closeWriteAndWait()</span><br><span class="line">				<span class="comment">// closewrite flush 所有缓存的数据并发送一个 FIN 包（如果客户端是通过 TCP 连接的），表示我们这边已结束，然后 sleep 500 ms</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> isCommonNetReadError(err) &#123;</span><br><span class="line">				<span class="comment">// err 是否是 io.EOF 或者是网络超时 (net.Error) 或者是读 request 的 net.OpError 之一</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			publicErr := <span class="string">"400 Bad Request"</span></span><br><span class="line">			<span class="keyword">if</span> v, ok := err.(badRequestError); ok &#123;</span><br><span class="line">				publicErr = publicErr + <span class="string">": "</span> + <span class="keyword">string</span>(v)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fmt.Fprintf(c.rwc, <span class="string">"HTTP/1.1 "</span>+publicErr+errorHeaders+publicErr)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// request Header : Expect 100 Continue</span></span><br><span class="line">		req := w.req</span><br><span class="line">		<span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line">			<span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// after first '100 Continue' request, wrapper response with 'HTTP/1.1 100 Continue'</span></span><br><span class="line">				req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			w.sendExpectationFailed() <span class="comment">// response with status code 417 (Expectation Failed)</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> requestBodyRemains(req.Body) &#123; <span class="comment">// 之后是否还能从 body 读取到数据，true 表示能继续读 (未到 io.EOF)</span></span><br><span class="line">			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead) <span class="comment">// 当 body 读到 EOF，调用传入的 startBackgroundRead 函数</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 长连接下 HTTP 管线化请求时的处理</span></span><br><span class="line">			<span class="keyword">if</span> w.conn.bufr.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// [HTTP pipelining](https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96)</span></span><br><span class="line">				w.conn.r.closeNotifyFromPipelinedRequest() <span class="comment">// closeNotify()</span></span><br><span class="line">			&#125;</span><br><span class="line">			w.conn.r.startBackgroundRead()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req) <span class="comment">// server.Handler == nil -&gt; DefaultServeMux.ServeHTTP</span></span><br><span class="line">		w.cancelCtx()</span><br><span class="line">		<span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		w.finishRequest()</span><br><span class="line">		<span class="keyword">if</span> !w.shouldReuseConnection() &#123; <span class="comment">// tcp 连接是否可以继续使用</span></span><br><span class="line">			<span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">				<span class="comment">// requestBodyLimitHit 在 requestTooLarge 函数中设置，当此值为真，停止读取后续的 request 和输入</span></span><br><span class="line">				<span class="comment">// closedRequestBodyEarly 表示连接之前是否已关闭</span></span><br><span class="line">				c.closeWriteAndWait()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.setState(c.rwc, StateIdle) <span class="comment">// StateIdle 表示此连接已处理完一个 request 并处于 keep-alive 状态，等待后续 request</span></span><br><span class="line">		c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !w.conn.server.doKeepAlives() &#123; <span class="comment">// doKeepAlives 判断是否满足 disableKeepAlives == 0 &amp;&amp; inShutdown == 0 (处于 keep-alive 模式且不在 shutdown 状态)</span></span><br><span class="line">			<span class="comment">// We're in shutdown mode. We might've replied</span></span><br><span class="line">			<span class="comment">// to the user without "Connection: close" and</span></span><br><span class="line">			<span class="comment">// they might think they can send another</span></span><br><span class="line">			<span class="comment">// request, but such is life with HTTP/1.1.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">			<span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// SetReadDeadline 设置后续读去调用的截止时间，如果传入零值表示不会 timeout</span></span><br><span class="line">		c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>流程：<br>当一个请求 request 进来的时候，server 会依次根据 ServeMux.m 中的 string（路由表达式）来一个一个匹配，<br>如果找到了可以匹配的 muxEntry，就取出 muxEntry.h，这是个 handler，<br>调用 handler 中的 ServeHTTP（ResponseWriter, *Request）来组装 Response，并返回。</p></blockquote><hr><h3 id="路由接口"><a href="#路由接口" class="headerlink" title="路由接口"></a>路由接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResponseWriter 接口用于 HTTP handler 生成 response</span></span><br><span class="line"><span class="comment">// 在 Handler.ServeHTTP 返回后，ResponseWriter 不应该再被使用</span></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Header() Header             <span class="comment">// Header() 返回 WriteHeader 要发送的 Header map 集合</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)  <span class="comment">// Write 写入响应的 body</span></span><br><span class="line">    WriteHeader(statusCode <span class="keyword">int</span>) <span class="comment">// 这个方法发送 Response 的 Header 和传入的 HTTP 状态码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flusher 由 ResponseWriters 执行去允许 HTTP handler 将缓存中的数据推给客户端, 默认的 HTTP/1.x 和 HTTP/2 ResponseWriter 支持 Flusher，</span></span><br><span class="line"><span class="comment">// 但是 ResponseWriter 的封装可能会不支持，Handlers 在运行时需要测试是否支持此函数</span></span><br><span class="line"><span class="comment">// 即使 ResponseWriters 支持 Flush，如果客户端使用了 HTTP proxy，直到响应结束，缓存的数据也有可能到达不了客户端</span></span><br><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">interface</span> &#123;</span><br><span class="line">	Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hijacker 接口由 ResponseWriters 执行去允许 HTTP handler 接管连接</span></span><br><span class="line"><span class="comment">// 默认的 ResponseWriter 支持 HTTP/1.x 连接下的 Hijacker，但是 HTTP/2 连接不支持，HTTP/2 多路复用等情况不适合使用 Hijack 。</span></span><br><span class="line"><span class="comment">// ResponseWriter 封装也可能不支持 Hijacker. Handlers 在运行时需要测试是否支持此函数</span></span><br><span class="line"><span class="keyword">type</span> Hijacker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hijack() (net.Conn, *bufio.ReadWriter, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeMux 类型是 HTTP 请求的路由规则转换器。它会将每一个接收的请求的 URL 与一个注册路由的列表进行匹配，并调用和 URL 最匹配的 handler.</span></span><br><span class="line"><span class="comment">// 匹配到多个时较长的模式优先于较短的模式，模式也可以主机名开始，表示只匹配该主机上的路径，指定主机的模式优先于一般的模式，</span></span><br><span class="line"><span class="comment">// ServeMux 还会规范化请求的 URL 路径，将任何包含 "." 或 ".." 元素的请求重定向到等价的没有这两种元素的 URL</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex <span class="comment">// 读写锁</span></span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry <span class="comment">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span></span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有 host 信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h        Handler <span class="comment">// 这个路由表达式对应哪个 handler</span></span><br><span class="line">    pattern  <span class="keyword">string</span>  <span class="comment">// 固定的、由根开始的路径，如 "/favicon.ico"，或由根开始的子树，如 "/images/"，也可以主机名开头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 Handler 响应一个 HTTP 请求</span></span><br><span class="line"><span class="comment">// ServeHTTP 应该将回复的头域和数据写入 ResponseWriter 接口然后返回。返回标志着该请求已经结束，HTTP 服务端可以转移向该连接上的下一个请求。</span></span><br><span class="line"><span class="comment">// 在 ServeHTTP 调用结束之后或者并发执行时，使用 ResponseWriter 或者读取请求体是不可取的</span></span><br><span class="line"><span class="comment">// handler 应该第一时间读取请求体并作出应答，在向 ResponseWriter 写入数据后就不能读取 request body 了. 同时 handler 不应该修改传入的 request</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc(f) 是一个调用 f 的 handler</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求-响应实例"><a href="#请求-响应实例" class="headerlink" title="请求 - 响应实例"></a>请求 - 响应实例</h3><h4 id="这里实现了一个-404-not-found-响应"><a href="#这里实现了一个-404-not-found-响应" class="headerlink" title="这里实现了一个 404 not found 响应"></a>这里实现了一个 <code>404 not found</code> 响应</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFound</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123; Error(w, <span class="string">"404 page not found"</span>, StatusNotFound) &#125; <span class="comment">// 定义 handler</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFoundHandler</span><span class="params">()</span> <span class="title">Handler</span></span> &#123; <span class="keyword">return</span> HandlerFunc(NotFound) &#125;</span><br></pre></td></tr></table></figure><h4 id="server-导出的注册函数使用-DefaultServeMux-相应方法"><a href="#server-导出的注册函数使用-DefaultServeMux-相应方法" class="headerlink" title="server 导出的注册函数使用 DefaultServeMux 相应方法"></a>server 导出的注册函数使用 DefaultServeMux 相应方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125; <span class="comment">// 注册成功</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServeHTTP-调用-Handler-给-request-分派与-request-URL-最匹配的-handler"><a href="#ServeHTTP-调用-Handler-给-request-分派与-request-URL-最匹配的-handler" class="headerlink" title="ServeHTTP 调用 Handler() 给 request 分派与 request URL 最匹配的 handler"></a>ServeHTTP 调用 Handler() 给 request 分派与 request URL 最匹配的 handler</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123; <span class="comment">// ProtoAtLeast 判断是否大于等于协议最低标准，第一个参数是 major 版本号，第二个参数是 minor 版本号，即 http/1.1</span></span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>) <span class="comment">// 小于要求则在响应头返回关闭信息</span></span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest) <span class="comment">// 状态码 400</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r) <span class="comment">// 调用对应 handler 的 ServeHTTP，即执行注册好的 handler 函数，比如 NotFound 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler 通过判断 r.Method, r.Host, and r.URL.Path 返回与 request 对应的 handler</span></span><br><span class="line"><span class="comment">// 此函数总会返回非空的 handler. 如果 path 不符合规范形式，返回的是内部生成的重定向到规范路径的 handler</span></span><br><span class="line"><span class="comment">// 如果 host 包含端口，匹配 handlers 时会忽略端口。第二个参数返回已注册的与请求匹配的路由</span></span><br><span class="line"><span class="comment">// 如果没有已注册的 handler 与请求匹配, 则返回 ``page not found'' handler 和空的 pattern</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Method == <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">		<span class="comment">// redirectToPathSlash 判断 path 是否需要追加 "/"，因为存在 "path + /" 已注册但 "path"</span></span><br><span class="line">		<span class="comment">// 本身未注册的情况。如果需要追加 "/"，则返回追加的 url 和 true</span></span><br><span class="line">		<span class="keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host := stripHostPort(r.Host) <span class="comment">// 去掉 ":&lt;port&gt;"</span></span><br><span class="line">	path := cleanPath(r.URL.Path) <span class="comment">// 规范 path 格式，比如缺失多余 '/'、存在相对路径'.'、'..' 等</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 request 的不规范路径</span></span><br><span class="line">	<span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">		_, pattern = mux.handler(host, path)</span><br><span class="line">		url := *r.URL</span><br><span class="line">		url.Path = path</span><br><span class="line">		<span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ServerMux.handler 中当匹配不到注册的路由时返回 NotFoundHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	mux.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">		h, pattern = mux.match(host + path) <span class="comment">// match 根据完整 URL 优先匹配 handler</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = mux.match(path) <span class="comment">// 如果 URL 匹配不到再根据路径匹配</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener">Package http</a></li><li><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/" target="_blank" rel="noopener">Go Web 编程</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">wiki NPN/ALPN</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">wiki TLS</a></li></ul>]]></content>
    
    <summary type="html">
    
      go http/server 源码解读
    
    </summary>
    
      <category term="go" scheme="https://blog.wangriyu.wang/categories/go/"/>
    
    
      <category term="go 源码" scheme="https://blog.wangriyu.wang/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Golang RPC</title>
    <link href="https://blog.wangriyu.wang/2018/04-go-rpc.html"/>
    <id>https://blog.wangriyu.wang/2018/04-go-rpc.html</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.562Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://src.wangriyu.wang/images/blog/go/rpc.svg" alt="image"></p><h2 id="1-server"><a href="#1-server" class="headerlink" title="1. server"></a>1. server</h2><h3 id="service-与-server-结构体"><a href="#service-与-server-结构体" class="headerlink" title="service 与 server 结构体"></a>service 与 server 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span>                 <span class="comment">// 服务名</span></span><br><span class="line">	rcvr   reflect.Value          <span class="comment">// 服务中函数的接收者</span></span><br><span class="line">	typ    reflect.Type           <span class="comment">// 接收者类型</span></span><br><span class="line">	method <span class="keyword">map</span>[<span class="keyword">string</span>]*methodType <span class="comment">// 已注册的函数集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	serviceMap sync.Map   <span class="comment">// 服务对象集合</span></span><br><span class="line">	reqLock    sync.Mutex <span class="comment">// 请求锁用来保护 freeReq</span></span><br><span class="line">	freeReq    *Request</span><br><span class="line">	respLock   sync.Mutex <span class="comment">// 响应锁保护 freeResp</span></span><br><span class="line">	freeResp   *Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rpc-Register-调用-DefaultServer-Register，主要实现在内部函数-register-中"><a href="#rpc-Register-调用-DefaultServer-Register，主要实现在内部函数-register-中" class="headerlink" title="rpc.Register 调用 DefaultServer.Register，主要实现在内部函数 register 中"></a>rpc.Register 调用 DefaultServer.Register，主要实现在内部函数 register 中</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register 在 server 中注册并发布 receiver 的函数集时需满足以下条件:</span></span><br><span class="line"><span class="comment">//   * 函数和函数的类型名是已导出的</span></span><br><span class="line"><span class="comment">//   * 两个参数都是导出类型 (或內建类型)</span></span><br><span class="line"><span class="comment">//   * 第二个参数是指针</span></span><br><span class="line"><span class="comment">//   * 函数只有一个类型为 error 的返回类型</span></span><br><span class="line"><span class="comment">// 如果 receiver 不是导出的类型或者没有符合条件的函数，将会返回一个错误。Register 将会使用 log 包记录出现的 error</span></span><br><span class="line"><span class="comment">// 客户端使用 "Type.Method" 的格式来调用函数，比如上文例子中 Arith.Multiply，这里的 Type 是 receiver 的具体类型.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">register</span><span class="params">(rcvr <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>, useName <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新起一个 service 服务对象</span></span><br><span class="line">	s := <span class="built_in">new</span>(service)</span><br><span class="line">    s.typ = reflect.TypeOf(rcvr)</span><br><span class="line">    s.rcvr = reflect.ValueOf(rcvr)</span><br><span class="line">    sname := reflect.Indirect(s.rcvr).Type().Name() <span class="comment">// 默认服务名是 receiver 的反射类型</span></span><br><span class="line">    <span class="comment">// 在 server.Register 中调用 register(rcvr, "", false)</span></span><br><span class="line">    <span class="comment">// 在 server.RegisterName 中调用 register(rcvr, name, true)</span></span><br><span class="line">    <span class="comment">// 这里使用的 name 可以指定服务对象名，客户端调用 rpc 服务时可以使用 "name.Method" 代替原来的 "Type.Method"</span></span><br><span class="line">    <span class="keyword">if</span> useName &#123;</span><br><span class="line">        sname = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sname == <span class="string">""</span> &#123;</span><br><span class="line">        s := <span class="string">"rpc.Register: no service name for type "</span> + s.typ.String()</span><br><span class="line">        log.Print(s)</span><br><span class="line">        <span class="keyword">return</span> errors.New(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !isExported(sname) &amp;&amp; !useName &#123;</span><br><span class="line">        s := <span class="string">"rpc.Register: type "</span> + sname + <span class="string">" is not exported"</span></span><br><span class="line">        log.Print(s)</span><br><span class="line">        <span class="keyword">return</span> errors.New(s)</span><br><span class="line">    &#125;</span><br><span class="line">    s.name = sname</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断传入的接口对象的函数集是否符合 RPC 规范</span></span><br><span class="line">	s.method = suitableMethods(s.typ, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.method) == <span class="number">0</span> &#123;</span><br><span class="line">        str := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果满足条件的函数集为空，根据 s.typ 的指针地址对象是否有符合条件的函数返回错误说明</span></span><br><span class="line">        method := suitableMethods(reflect.PtrTo(s.typ), <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(method) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 此错误说明传入的 s.typ 不符合条件，应该传入 *s.typ</span></span><br><span class="line">            str = <span class="string">"rpc.Register: type "</span> + sname + <span class="string">" has no exported methods of suitable type (hint: pass a pointer to value of that type)"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str = <span class="string">"rpc.Register: type "</span> + sname + <span class="string">" has no exported methods of suitable type"</span></span><br><span class="line">        &#125;</span><br><span class="line">        log.Print(str)</span><br><span class="line">        <span class="keyword">return</span> errors.New(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadOrStore 会检查 sync.Map 类型对象中是否存在传入的键名，如果存在则返回相应的值和 true</span></span><br><span class="line">    <span class="comment">// 反之会先存入键值对再返回值和 false</span></span><br><span class="line">	<span class="keyword">if</span> _, dup := server.serviceMap.LoadOrStore(sname, s); dup &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"rpc: service already defined: "</span> + sname)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册后监听请求"><a href="#注册后监听请求" class="headerlink" title="注册后监听请求"></a>注册后监听请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept 从监听器上接收获取到的连接并服务每个连接的请求</span></span><br><span class="line"><span class="comment">// Accept 在监听器返回非空的错误前都处于阻塞态</span></span><br><span class="line"><span class="comment">// 调用者一般应使用 goroutine 启用 Accept，比如 `go server.Accept(l)`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Accept</span><span class="params">(lis net.Listener)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := lis.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Print(<span class="string">"rpc.Serve: accept:"</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> server.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Accept-中调用-ServeConn-函数进行服务"><a href="#在-Accept-中调用-ServeConn-函数进行服务" class="headerlink" title="在 Accept 中调用 ServeConn 函数进行服务"></a>在 Accept 中调用 ServeConn 函数进行服务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeConn 在一个连接上运行 server 并服务该连接.</span></span><br><span class="line"><span class="comment">// ServeConn 在服务该连接到客户端挂起的期间处于阻塞态.</span></span><br><span class="line"><span class="comment">// 一般另起线程来调用本函数，比如 `go server.ServeConn(conn)` (Accept 函数中有调用)</span></span><br><span class="line"><span class="comment">// ServeConn 在该连接上使用 gob 包的有线格式 (参见 gob 包) .</span></span><br><span class="line"><span class="comment">// 如需使用其他备份编解码器, 可以使用 ServeCodec 函数.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeConn</span><span class="params">(conn io.ReadWriteCloser)</span></span> &#123;</span><br><span class="line">	buf := bufio.NewWriter(conn)</span><br><span class="line">	srv := &amp;gobServerCodec&#123;</span><br><span class="line">		rwc:    conn,</span><br><span class="line">		dec:    gob.NewDecoder(conn),</span><br><span class="line">		enc:    gob.NewEncoder(buf),</span><br><span class="line">		encBuf: buf,</span><br><span class="line">	&#125;</span><br><span class="line">	server.ServeCodec(srv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeCodec 与 ServeConn 类似，只是使用了指定的编解码器来解码 requests 和编码 responses</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeCodec</span><span class="params">(codec ServerCodec)</span></span> &#123;</span><br><span class="line">	sending := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		service, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec) <span class="comment">// 读取请求信息</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> debugLog &amp;&amp; err != io.EOF &#123;</span><br><span class="line">				log.Println(<span class="string">"rpc:"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !keepReading &#123; <span class="comment">// 如果读请求的 header 就出错了，keepReading 为 false，跳出此循环；如果能读取 header 信息便继续</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 发送一个 response 表示此请求无效</span></span><br><span class="line">			<span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</span><br><span class="line">				server.sendResponse(sending, req, invalidRequest, codec, err.Error())</span><br><span class="line">				server.freeRequest(req)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> service.call(server, sending, wg, mtype, req, argv, replyv, codec)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有 request 后需等待 response 发送完成再关闭 codec</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	codec.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端请求某个服务后，服务端在-ServeCodec-中通过调用-service-call-调用相应服务"><a href="#客户端请求某个服务后，服务端在-ServeCodec-中通过调用-service-call-调用相应服务" class="headerlink" title="客户端请求某个服务后，服务端在 ServeCodec 中通过调用 service.call 调用相应服务"></a>客户端请求某个服务后，服务端在 ServeCodec 中通过调用 service.call 调用相应服务</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">call</span><span class="params">(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line">	mtype.Lock()</span><br><span class="line">	mtype.numCalls++</span><br><span class="line">	mtype.Unlock()</span><br><span class="line">	function := mtype.method.Func</span><br><span class="line">	<span class="comment">// 执行函数, 返回新的值给 reply</span></span><br><span class="line">	returnValues := function.Call([]reflect.Value&#123;s.rcvr, argv, replyv&#125;)</span><br><span class="line">	<span class="comment">// 返回值里的错误</span></span><br><span class="line">	errInter := returnValues[<span class="number">0</span>].Interface()</span><br><span class="line">	errmsg := <span class="string">""</span></span><br><span class="line">	<span class="keyword">if</span> errInter != <span class="literal">nil</span> &#123;</span><br><span class="line">		errmsg = errInter.(error).Error()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送响应，然后释放当前请求节点</span></span><br><span class="line">	server.sendResponse(sending, req, replyv.Interface(), codec, errmsg)</span><br><span class="line">	server.freeRequest(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP-方式"><a href="#HTTP-方式" class="headerlink" title="HTTP 方式"></a>HTTP 方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ServeHTTP 实现一个用于回应 RPC 请求的 http.Handler</span><br><span class="line">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	if req.Method != &quot;CONNECT&quot; &#123;</span><br><span class="line">		w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)</span><br><span class="line">		w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line">		io.WriteString(w, &quot;405 must CONNECT\n&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	conn, _, err := w.(http.Hijacker).Hijack() // 让调用者主动接管连接</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Print(&quot;rpc hijacking &quot;, req.RemoteAddr, &quot;: &quot;, err.Error())</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	io.WriteString(conn, &quot;HTTP/1.0 &quot;+connected+&quot;\n\n&quot;)</span><br><span class="line">	server.ServeConn(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HandleHTTP 注册 server 的 RPC 信息到 rpcPath 上，注册 server 的 debug 信息到 debugPath 上</span><br><span class="line">// HandleHTTP 会注册到 http.DefaultServeMux 上</span><br><span class="line">// 之后，仍需要调用 http.Serve()，一般会另起线程：&quot;go http.Serve(l, nil)&quot;</span><br><span class="line">func (server *Server) HandleHTTP(rpcPath, debugPath string) &#123;</span><br><span class="line">	http.Handle(rpcPath, server)</span><br><span class="line">	http.Handle(debugPath, debugHTTP&#123;server&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-client"><a href="#2-client" class="headerlink" title="2. client"></a>2. client</h2><p><img src="https://src.wangriyu.wang/images/blog/go/RPC-Client.png" alt="image"><br></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call 代表一个活跃的 RPC.</span></span><br><span class="line"><span class="keyword">type</span> Call <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServiceMethod <span class="keyword">string</span>      <span class="comment">// 调用的服务名</span></span><br><span class="line">	Args          <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 函数传入参数 (*struct)</span></span><br><span class="line">	Reply         <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 函数返回结果 (*struct)</span></span><br><span class="line">	Error         error       <span class="comment">// 结束后的错误状态</span></span><br><span class="line">	Done          <span class="keyword">chan</span> *Call  <span class="comment">// 非空表示一个 rpc 调用结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client 代表一个 RPC 客户端，同一个客户端可能有多个未返回的调用，也可能被多个 go 线程同时使用</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	codec ClientCodec</span><br><span class="line">	reqMutex sync.Mutex <span class="comment">// 保护 request</span></span><br><span class="line">	request  Request</span><br><span class="line">	mutex    sync.Mutex <span class="comment">// 保护 seq</span></span><br><span class="line">	seq      <span class="keyword">uint64</span> <span class="comment">// 一个序列值，request 和 response 会以此标识</span></span><br><span class="line">	pending  <span class="keyword">map</span>[<span class="keyword">uint64</span>]*Call <span class="comment">// 等待响应的 Call 集合</span></span><br><span class="line">	closing  <span class="keyword">bool</span> <span class="comment">// 用户已调用 Close</span></span><br><span class="line">	shutdown <span class="keyword">bool</span> <span class="comment">// 服务器已告知停止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientCodec 接口实现了 RPC 会话的客户端一侧 RPC 请求的写入和 RPC 响应的读取。</span></span><br><span class="line"><span class="comment">// 客户端调用 WriteRequest 来写入请求到连接，然后成对调用 ReadRsponseHeader 和</span></span><br><span class="line"><span class="comment">// ReadResponseBody 以读取响应。客户端在结束该连接的事务时调用 Close 方法。</span></span><br><span class="line"><span class="comment">// ReadResponseBody 可以使用 nil 参数调用，以强制回复的主体被读取然后丢弃。</span></span><br><span class="line"><span class="keyword">type</span> ClientCodec <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// WriteRequest 必须能安全的被多个 go 协程同时使用</span></span><br><span class="line">	WriteRequest(*Request, <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">	ReadResponseHeader(*Response) error</span><br><span class="line">	ReadResponseBody(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">	Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端获取-Client-对象"><a href="#客户端获取-Client-对象" class="headerlink" title="客户端获取 Client 对象"></a>客户端获取 Client 对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DialHTTP 通过地址连向一个 HTTP RPC server (建立 HTTP 连接)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHTTP</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DialHTTPPath(network, address, DefaultRPCPath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialHTTPPath 通过地址和路径连向一个 HTTP RPC server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHTTPPath</span><span class="params">(network, address, path <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	conn, err := net.Dial(network, address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	io.WriteString(conn, <span class="string">"CONNECT "</span>+path+<span class="string">" HTTP/1.0\n\n"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在切换 RPC 协议前需要保证成功的 HTTP 响应</span></span><br><span class="line">	resp, err := http.ReadResponse(bufio.NewReader(conn), &amp;http.Request&#123;Method: <span class="string">"CONNECT"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; resp.Status == connected &#123;</span><br><span class="line">		<span class="keyword">return</span> NewClient(conn), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">"unexpected HTTP response: "</span> + resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	conn.Close()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, &amp;net.OpError&#123;</span><br><span class="line">		Op:   <span class="string">"dial-http"</span>,</span><br><span class="line">		Net:  network + <span class="string">" "</span> + address,</span><br><span class="line">		Addr: <span class="literal">nil</span>,</span><br><span class="line">		Err:  err,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dial 通过指定的地址连向一个 RPC server (建立 TCP 连接)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(network, address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NewClient(conn), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建-Client-对象"><a href="#新建-Client-对象" class="headerlink" title="新建 Client 对象"></a>新建 Client 对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn io.ReadWriteCloser)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">	encBuf := bufio.NewWriter(conn)</span><br><span class="line">	client := &amp;gobClientCodec&#123;conn, gob.NewDecoder(conn), gob.NewEncoder(encBuf), encBuf&#125;</span><br><span class="line">	<span class="keyword">return</span> NewClientWithCodec(client)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientWithCodec</span><span class="params">(codec ClientCodec)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">	client := &amp;Client&#123;</span><br><span class="line">		codec:   codec,</span><br><span class="line">		pending: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]*Call),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> client.input() <span class="comment">// 另起线程接收 response</span></span><br><span class="line">	<span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从连接中读取-response-根据-seq-找到-pending-集合中对应的-Call-对象，获取响应内容，Done-结束"><a href="#从连接中读取-response-根据-seq-找到-pending-集合中对应的-Call-对象，获取响应内容，Done-结束" class="headerlink" title="从连接中读取 response, 根据 seq 找到 pending 集合中对应的 Call 对象，获取响应内容，Done 结束"></a>从连接中读取 response, 根据 seq 找到 pending 集合中对应的 Call 对象，获取响应内容，Done 结束</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">input</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> response Response</span><br><span class="line">	<span class="keyword">for</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		response = Response&#123;&#125;</span><br><span class="line">		err = client.codec.ReadResponseHeader(&amp;response)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		seq := response.Seq</span><br><span class="line">		client.mutex.Lock()</span><br><span class="line">		call := client.pending[seq] <span class="comment">// 等待队列中的对应当前 response 的序列号的 Call 对象</span></span><br><span class="line">		<span class="built_in">delete</span>(client.pending, seq)</span><br><span class="line">		client.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> call == <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// call == nil 代表等待序列中没有对应的 Call 对象，一般意味着 WriteRequest 时失败了并且 call 已经被删去</span></span><br><span class="line">			<span class="comment">// 返回的 response 是读取错误 request 的错误信息</span></span><br><span class="line">			err = client.codec.ReadResponseBody(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = errors.New(<span class="string">"reading error body: "</span> + err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> response.Error != <span class="string">""</span>:</span><br><span class="line">			<span class="comment">// 获取到一个错误响应. 将这个传给 Call;</span></span><br><span class="line">			call.Error = ServerError(response.Error)</span><br><span class="line">			err = client.codec.ReadResponseBody(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = errors.New(<span class="string">"reading error body: "</span> + err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			call.done()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			err = client.codec.ReadResponseBody(call.Reply)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				call.Error = errors.New(<span class="string">"reading body "</span> + err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			call.done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭等待中的 calls.</span></span><br><span class="line">	client.reqMutex.Lock()</span><br><span class="line">	client.mutex.Lock()</span><br><span class="line">	client.shutdown = <span class="literal">true</span></span><br><span class="line">	closing := client.closing</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="keyword">if</span> closing &#123;</span><br><span class="line">			err = ErrShutdown</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = io.ErrUnexpectedEOF</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, call := <span class="keyword">range</span> client.pending &#123;</span><br><span class="line">		call.Error = err</span><br><span class="line">		call.done()</span><br><span class="line">	&#125;</span><br><span class="line">	client.mutex.Unlock()</span><br><span class="line">	client.reqMutex.Unlock()</span><br><span class="line">	<span class="keyword">if</span> debugLog &amp;&amp; err != io.EOF &amp;&amp; !closing &#123;</span><br><span class="line">		log.Println(<span class="string">"rpc: client protocol error:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client-使用不同函数去调取-rpc-服务，Go-可以异步执行，Call-是同步的"><a href="#Client-使用不同函数去调取-rpc-服务，Go-可以异步执行，Call-是同步的" class="headerlink" title="Client 使用不同函数去调取 rpc 服务，Go 可以异步执行，Call 是同步的"></a>Client 使用不同函数去调取 rpc 服务，Go 可以异步执行，Call 是同步的</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go 异步地执行函数. 本方法 Call 结构体类型指针的返回值代表该次远程调用.</span></span><br><span class="line"><span class="comment">// 通道类型的参数 done 会在本次调用完成时发出信号（通过返回本次 Go 方法的返回值）</span></span><br><span class="line"><span class="comment">// 如果 done 为 nil，Go 会申请一个新的通道（写入返回值的 Done 字段）</span></span><br><span class="line"><span class="comment">// 如果 done 非 nil，done 必须有缓冲，否则 Go 方法会崩溃。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Go</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;, done <span class="keyword">chan</span> *Call)</span> *<span class="title">Call</span></span> &#123;</span><br><span class="line">	call := <span class="built_in">new</span>(Call)</span><br><span class="line">	call.ServiceMethod = serviceMethod</span><br><span class="line">	call.Args = args</span><br><span class="line">	call.Reply = reply</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		done = <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">10</span>) <span class="comment">// buffered.</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果调用者传的 done != nil，则必须确保通道有足够的缓冲来给多个同步 RPCs 使用</span></span><br><span class="line">		<span class="comment">// 如果通道完全没有缓冲，最好不要去运行</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">cap</span>(done) == <span class="number">0</span> &#123;</span><br><span class="line">			log.Panic(<span class="string">"rpc: done channel is unbuffered"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	call.Done = done</span><br><span class="line">	client.send(call)</span><br><span class="line">	<span class="keyword">return</span> call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call 调用传入名的远程服务，并等待结束返回结果和错误状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Call</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	call := &lt;-client.Go(serviceMethod, args, reply, <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">1</span>)).Done</span><br><span class="line">	<span class="keyword">return</span> call.Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-中调用的函数"><a href="#Go-中调用的函数" class="headerlink" title="Go 中调用的函数"></a>Go 中调用的函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">send</span><span class="params">(call *Call)</span></span> &#123;</span><br><span class="line">	client.reqMutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> client.reqMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 call 转入等待集合</span></span><br><span class="line">	client.mutex.Lock()</span><br><span class="line">	<span class="keyword">if</span> client.shutdown || client.closing &#123;</span><br><span class="line">		call.Error = ErrShutdown</span><br><span class="line">	client.mutex.Unlock()</span><br><span class="line">		call.done()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	seq := client.seq</span><br><span class="line">	client.seq++</span><br><span class="line">	client.pending[seq] = call</span><br><span class="line">	client.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 request 编码并发送</span></span><br><span class="line">	client.request.Seq = seq</span><br><span class="line">	client.request.ServiceMethod = call.ServiceMethod</span><br><span class="line">	err := client.codec.WriteRequest(&amp;client.request, call.Args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		client.mutex.Lock()</span><br><span class="line">		call = client.pending[seq]</span><br><span class="line">		<span class="built_in">delete</span>(client.pending, seq)</span><br><span class="line">		client.mutex.Unlock()</span><br><span class="line">		<span class="keyword">if</span> call != <span class="literal">nil</span> &#123;</span><br><span class="line">			call.Error = err</span><br><span class="line">			call.done()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-jsonrpc"><a href="#3-jsonrpc" class="headerlink" title="3. jsonrpc"></a>3. jsonrpc</h2><p>jsonrpc 主要将 gob 序列化工具换成 json 序列化工具，主要函数还是调用 server 里的 FuncWithCodec 函数，原理基本一致</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.gitbook.com/book/smallnest/go-rpc-programming-guide/details" target="_blank" rel="noopener">Go RPC 开发指南</a></li><li><a href="http://colobu.com/2016/09/18/go-net-rpc-guide/" target="_blank" rel="noopener">Go 官方库 RPC 开发指南</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.4.md" target="_blank" rel="noopener">build-web-application-with-golang</a></li><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">rpc wikipedia</a></li><li><a href="https://technet.microsoft.com/en-us/library/cc738291%28v=ws.10%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">How RPC Works</a></li></ul>]]></content>
    
    <summary type="html">
    
      go net/rpc 包源码解读
    
    </summary>
    
      <category term="go" scheme="https://blog.wangriyu.wang/categories/go/"/>
    
    
      <category term="go 源码" scheme="https://blog.wangriyu.wang/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>PKI 体系</title>
    <link href="https://blog.wangriyu.wang/2018/04-http-pki.html"/>
    <id>https://blog.wangriyu.wang/2018/04-http-pki.html</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中间人攻击和信息抵赖"><a href="#中间人攻击和信息抵赖" class="headerlink" title="中间人攻击和信息抵赖"></a>中间人攻击和信息抵赖</h2><p>没有身份验证的情况下，在非对称加密中实现身份验证和密钥协商时，比如常用的 RSA 算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息。可能出现如下两种情况:</p><ul><li>中间人攻击 (MITM): 攻击者介入通信双方，C - M 通信时使用的是中间人自己的一对公私钥 Key_M，中间人可以解密客户端用 Key_M 加密的信看;<br>M - S 通信时使用的是服务器提供的公钥，加密从客户端得到的消息给服务器完成双方通信</li><li>信息抵赖: 发送消息者可以否认之前发过的消息，因为接收端使用公钥不能确定之前接收的消息来源身份</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/MITM.png" alt="image"></p><p>此时需要一种认证体系以确保通信者是安全可靠的。</p><h2 id="PKI-互联网公钥基础设施"><a href="#PKI-互联网公钥基础设施" class="headerlink" title="PKI - 互联网公钥基础设施"></a>PKI - 互联网公钥基础设施</h2><p><strong>PKI</strong> 的目标就是实现不同成员在不见面的情况下进行安全通信，当前采用的模型是基于可信的第三方机构，也就是 <strong>证书颁发机构 (certification authority，CA)</strong> 签发的证书。<br>PKI 通过数字证书认证机构 (CA) 将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系由注册和发布过程确定，取决于担保级别，链接关系可能由 CA 的各种软件或在人为监督下完成。</p><p><img src="https://src.wangriyu.wang/images/blog/http/PKI.png" alt="image"></p><ul><li>订阅人: 或者叫最终实体，是指那些需要证书来提供安全服务的团体，维护服务端的人</li><li>登记机构 (registration authority - RA): 主要是完成一些证书签发的相关管理工作。例如， RA 会首先对用户进行必要的身份验证，然后才会去找 CA 签发证书。在某些情况下，<br>当 CA 希望在用户附近建立一个分支机构时（例如在不同的国家建立当地登记中心），我们也称 RA 为本地登记机构（local registration authority，LRA）。实际上，很多 CA 也执行 RA 的职责。RA 确保公开密钥和个人身份链接，可以防抵赖。</li><li>凭证签发请求文件 (Certificate Signing Request - CSR): 一种包含凭证签发时所需的公钥、组织信息、个人信息 (域名) 等信息的 (.csr) 文件，不含私钥信息。</li><li>证书颁发机构 (certification authority - CA): 是指我们都信任的证书颁发机构，CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等，确认申请用户的身份之后再签发证书。<br>同时 CA 会在线提供其所签发证书的最新吊销信息，这样信赖方就可以验证证书是否仍然有效。</li><li>证书 (certificate) 包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名（使用散列函数计算公开的明文信息的信息摘要，<br>然后采用 CA 的私钥对信息摘要进行加密，此密文即签名）。<strong>证书 = 公钥 + 申请者与颁发者信息 + 签名</strong></li><li>信赖方 (relying party): 是指那些证书使用者。一般是指那些需要证书验证的网页浏览器、其他程序以及操作系统。他们通过维护根可信证书库来执行验证，<br>这些证书库包含某些 CA 的最终可信证书（信任密钥，trust anchor）。更广泛地说，信赖方是指那些需要通过证书在互联网上进行安全通信的最终用户。用户接收到证书后，读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，<br>然后利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性；然后去查询证书的吊销情况</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/certificate-status.png" alt="image"></p><ul><li>证书吊销列表 (Certificate Revocation List - CRL): 一个单独的文件。该文件包含了 CA 已经吊销的证书序列号 (唯一) 与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。<br>证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。</li><li>证书状态在线查询协议 (Online Certificate Status Protocol - OCSP): 一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。<br>部分 CA 或大部分的 <a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89#%E8%87%AA%E7%B0%BD%E8%AD%89%E6%9B%B8" target="_blank" rel="noopener">自签 CA (根证书)</a> 都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。</li></ul><p>一个具体实例: <a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89#%E7%94%B3%E9%A0%98%E5%8F%8A%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89#%E7%94%B3%E9%A0%98%E5%8F%8A%E4%BD%BF%E7%94%A8</a></p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><h3 id="证书大致分为三类"><a href="#证书大致分为三类" class="headerlink" title="证书大致分为三类"></a>证书大致分为三类</h3><ul><li>自签名 CA: 在自签名 CA 中，证书中的公钥和用于验证证书的密钥是相同的。一些自签名 CA 是根 CA。这种自签名证书通常不会被广泛信任，使用时可能会遇到电脑软件的安全警告。自签名证书本身就是根证书。</li><li>从属 CA: 在从属 CA 中，证书中的公钥和用于核实证书的密钥是不同的。一个 CA 向另一个 CA 颁发证书的过程叫做交叉认证 。</li><li>根 CA: 根 CA 是一种特殊的 CA，它受到客户无条件地信任，位于证书层次结构的最高层。所有证书链均终止于根 CA。根颁发机构必须对它自己的证书签名，因为在证书层次结构中再也没有更高的认证机构了。根证书也是自签名证书。</li></ul><p>其他的还可以细分为中介证书、终端实体证书、授权证书、TLS 服务器证书、通配符证书、TLS 客户端证书</p><h3 id="审核级别-担保级别"><a href="#审核级别-担保级别" class="headerlink" title="审核级别 (担保级别)"></a>审核级别 (担保级别)</h3><ul><li>域名验证 (DV): 最基本的审核级别，如果申领代表可以证明他拥有管理某域名的权力，认证机构就可以发放域名验证（DV）证书，一般认证机构通常使用自动机制或通过电邮确认审核域名拥有权，成本较低</li><li>组织验证 (OV): 代表可以证明他拥有管理某域名的权力，而且相关组织是实际存在的法人，认证机构可以发放组织验证（OV）证书。审核程序通常需要经过人手处理。</li><li>扩展验证 (EV): 最严格的审核级别，审核过程可能牵涉专业法律人员的调查及独立审计人员的确认，成本也更高；成功获得扩展验证证书的网站，浏览器通常会在地址栏以绿色表示相关机构的法人名称及所属国家代码。扩展验证证书的主体名称或主体别名上不可以有通配符</li></ul><h3 id="证书结构"><a href="#证书结构" class="headerlink" title="证书结构"></a>证书结构</h3><p><img src="https://src.wangriyu.wang/images/blog/http/certificate-struct.png" alt="image"></p><ul><li>版本号 (version): 证书一共有 3 个版本号，分别用 0、1、2 编码表示版本 1、版本 2 和版本 3。版本 1 只支持简单的字段，版本 2 增加了两个标识符，而版本 3 则增加了扩展功能。现在大部分的证书都采用版本 3 的格式。</li><li>序列号 (serialNumber): 在一开始，序列号只要是正整数即可，是每个 CA 用来唯一标识其所签发的证书。但是在出现了针对证书签名的预选 <a href="http://www.freebuf.com/articles/database/133391.html" target="_blank" rel="noopener">前缀攻击</a> 之后，序列号增加了更多的要求来防止此类攻击；现在序列号需要是无序的（无法被预测）而且至少包括 20 位的熵</li><li>签名算法 (signture Algorithm): 这个字段指明证书签名所用的算法，需要放到证书里面，这样才能被证书签名保护</li><li>颁发者 (issuer): 证书颁发者的可分辨名称（distinguished name，DN），这个字段比较复杂，根据不同的实体会包含许多部分。举例来说，Verisign 根证书的可分辨名称是 /C=US/O=VeriSign, Inc./OU=Class 3 Public Primary Certification Authority；它包括了国家、组织和组织单位三个部分。</li><li>有效期 (validity): 证书的有效期包括开始日期和结束日期，在这段时间内证书是有效的。</li><li>使用者 (subject): 证书使用实体的可分辨名称，和公钥一起用于证书的签发。在自签名证书里，使用者 (subject) 和颁发者 (issuer) 字段的可分辨名称是一样的。在最开始，可分辨名称里面的公用名（common name， CN）主要用于服务器主机名（例如 /CN=<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 用于 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 域名的证书）</li><li>公钥 (subject public-key info): 这个字段包含了公钥、算法 ID、可选参数</li><li>扩展 (extensions): 比如密钥用法、证书策略、CRL 分发点、使用者密钥标识符等等</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/github-certificate.png" alt="image"></p><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>CA 根证书和服务器实体证书中间增加一层证书机构，即中介证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的 CA 根证书验证合法即可</p><ol><li>服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书;</li><li>中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书;</li><li>客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 被信任。</li></ol><p><img src="https://src.wangriyu.wang/images/blog/http/certificate-chain.png" alt="image"></p><p>具体例子可以看维基百科的例子: <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88#%E8%88%89%E4%BE%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88#%E8%88%89%E4%BE%8B</a></p><p>点击浏览器地址栏的绿色小锁可以查看网站的证书链:</p><p><img src="https://src.wangriyu.wang/images/blog/http/chrome-certificate-chain.png" alt="image"></p><p>二级证书结构存在的优势：</p><ul><li>减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发;</li><li>根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救;</li><li>中介证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书;</li><li>证书链四级以内一般不会对 HTTPS 的性能造成明显影响</li></ul><p>服务器一般提供一条证书链，但也有多条路径的可能。以 <a href="https://blog.csdn.net/fangwm2011/article/details/6623887" target="_blank" rel="noopener">交叉证书</a> 为例，一条可信路径可以一直到 CA 的主要根证书，另外一条则是到可选根证书上。<br>CA 有时候会为同样的密钥签发多张证书，例如现在最常使用的签名算法是 SHA1，因为安全原因正在逐步迁移到 SHA256， CA 可以使用同样的密钥签发出不同签名的新证书。如果信赖方恰好有两张这样的证书，那么就可以构建出两条不同的可信路径。</p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>再回过头来看中间人攻击，需要身份验证后中间人与 Server 通信时接收服务器的证书实现身份验证，但与客户端通信时无法向用户提供可信任的证书。</p><p><img src="https://src.wangriyu.wang/images/blog/http/MITM-Cert.png" alt="image"></p><p>除非伪造一份证书 (很困难)，或者骗取客户端信任，比如在客户机操作系统上添加中间人证书的完全信任，以此实现用户的信任和身份验证。</p><p>举个栗子:</p><p>使用抓包工具 Charles 时，如果想抓取 HTTPS 的内容，就需要安装其提供的证书并添加信任</p><p><img src="https://src.wangriyu.wang/images/blog/http/Charles.png" alt="image"></p><p>没有信任时，抓取的 HTTPS 内容无法解析</p><p><img src="https://src.wangriyu.wang/images/blog/http/nossl.png" alt="image"></p><p>取得信任后，抓取的 HTTPS 请求可以和 HTTP 请求一样直接读取</p><p><img src="https://src.wangriyu.wang/images/blog/http/withssl.png" alt="image"></p><p>在这个过程中 Charles 就是一个中间人，而且可以完全获取 HTTPS 信息，因为用户安装并信任它的证书，也就可以做到身份验证。</p><blockquote><p>可以看到加密协议下所有连接都是 Connect 形式，这涉及到 <a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议 - Tunneling Protocol</a> 的概念</p></blockquote><p>使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。</p><p>隧道通信的机制如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination.</span><br><span class="line">The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server,</span><br><span class="line">the Proxy server continues to proxy the TCP stream to and from the client.The client is now being proxied to the remote host.</span><br><span class="line">Any data sent to the proxy server is now forwarded, unmodified, to the remote host and the client can communicate using any protocol accepted by the remote host</span><br><span class="line"></span><br><span class="line">Proxy servers may also limit connections by only allowing connections to the default HTTPS port 443, whitelisting hosts, or blocking traffic which doesn&apos;t appear to be SSL.</span><br><span class="line"></span><br><span class="line">客户端先请求一个代理服务器去建立和目标服务器之间的 tcp tunnel，目标服务器尝试连接客户端 (实际是代理服务器)，如果连接成功建立，代理服务器会给客户端返回 200 ok 并继续代理客户端和目标服务器之间的 tcp 流。</span><br><span class="line">任何发送给代理服务器的数据都会不加修改地被转发，远程主机和客户端可以通过任何协议 (TLS、SSH、SOCKS、PPTP...) 进行后续交互。</span><br><span class="line"></span><br><span class="line">代理服务器也可以通过端口限制 (443)、host 白名单、阻止非 SSL 的数据流来限制连接</span><br></pre></td></tr></table></figure><p>一些代理服务器需要认证信息来建立 tunnel. 常见的是 Proxy-Authorization 头域:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONNECT server.example.com:80 HTTP/1.1</span><br><span class="line">Host: server.example.com:80</span><br><span class="line">Proxy-Authorization: basic aGVsbG86d29ybGQ=</span><br></pre></td></tr></table></figure><p>关于这个中间代理的详细信息见 <a href="https://en.wikipedia.org/wiki/DMZ_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/DMZ_(computing)</a></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>讲到 Charles，不得不提另一个抓包工具 Wireshark。这两个工具的抓包原理不同，Charles 是通过代理过滤抓取本机的网络请求，主要抓 HTTP、HTTPS 的请求；<br>Wireshark 则是使用了 <a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">网卡混杂模式 - promiscuous mode</a>，可以抓取指定网卡上所有流过的包，可以抓取应用层、传输层、网络层的各种封包，但是正常情况下不能解析 HTTPS 的内容 (可以通过配置浏览器提供的对称协商密钥或者服务器的私钥来解密 TLS 内容)。</p><p>开启混杂模式时除了可以看到自己电脑上的网络封包，还可以看到目标地址不是本机的网络包 (如果路由器没有做网络分发的工作的话，完全有可能接收到其他电脑的网络包)，还可以看到局域网内的广播等等。我看了一篇于此相关的网络攻击手段 - <a href="https://zhuanlan.zhihu.com/p/28818627" target="_blank" rel="noopener">ARP 攻击</a>。</p><p>ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址，如图</p><p><img src="https://src.wangriyu.wang/images/blog/http/ARP.png" alt="image"></p><p>而 ARP 攻击者可以通过两种方式实现抓取监听局域网内全部或者想要的目标的网络数据:</p><ul><li>通过大密集的 ARP 回应抢占或覆盖路由的映射表，使路由以为攻击者就是目标，然后把 ip 映射到错误对象的 mac 上，之后攻击者便能接收目标 ip 的网络数据</li><li>在局域网内向所有 ip 客户机广播，假装自己是网关，然后所有目标机器向自己发送外网或者转发请求数据</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD" target="_blank" rel="noopener">PKI - wiki</a></li><li><a href="https://www.wosign.com/faq/faq2016-0309-03.htm" target="_blank" rel="noopener">PKI 体系</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88" target="_blank" rel="noopener">信任链 - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">MITM</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">数字证书 - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">数字签名 - wiki</a></li><li><a href="https://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="noopener">http tunnel</a></li><li><a href="https://en.wikipedia.org/wiki/Tunneling_protocol" target="_blank" rel="noopener">Tunneling protocol</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">代理服务器 - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">反向代理 - wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      了解证书的相关内容以及 PKI 体系的规范和流程
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SSL/TLS 详解</title>
    <link href="https://blog.wangriyu.wang/2018/03-http-tls.html"/>
    <id>https://blog.wangriyu.wang/2018/03-http-tls.html</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-05-24T12:17:08.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-TLS-定义"><a href="#1-TLS-定义" class="headerlink" title="1. TLS 定义"></a>1. TLS 定义</h2><p><strong>SSL</strong>(Secure Sockets Layer) 安全套接层，是一种安全协议，经历了 SSL 1.0、2.0、3.0 版本后发展成了标准安全协议 - <strong>TLS</strong>(Transport Layer Security) 传输层安全性协议。TLS 有 1.0 (RFC 2246)、1.1(RFC 4346)、1.2(RFC 5246)、1.3(1.3 在 3.26 号正式被批准) 版本。</p><p>TLS 在实现上分为 <strong>记录层</strong> 和 <strong>握手层</strong> 两层，其中握手层又含四个子协议: 握手协议（handshake protoco 协议（change cipher spec protocol）、应用数据协议（application data protocol）和警报协议（alert protocol）</p><p><img src="https://src.wangriyu.wang/images/blog/http/tls.png" alt="image"></p><h2 id="2-HTTPS-HTTP-over-TLS"><a href="#2-HTTPS-HTTP-over-TLS" class="headerlink" title="2. HTTPS = HTTP over TLS."></a>2. HTTPS = HTTP over TLS.</h2><p>只需配置浏览器和服务器相关设置开启 TLS，即可实现 HTTPS，TLS 高度解耦，可装可卸，与上层高级应用层协议相互协作又相互独立。</p><p><img src="https://src.wangriyu.wang/images/blog/http/https.png" alt="image"></p><h2 id="3-加密"><a href="#3-加密" class="headerlink" title="3. 加密"></a>3. 加密</h2><p>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p><p><img src="https://src.wangriyu.wang/images/blog/http/encrypt.png" alt="image"></p><p>TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p><p>例如，在 HTTPS 协议中，客户端发出请求，服务端会将公钥发给客户端，客户端验证过后生成一个密钥再用公钥加密后发送给服务端，成功后建立连接。通信过程中客户端将请求数据用得到的公钥加密后发送，服务端用私钥解密；服务端用客户端给的密钥加密响应报文，回复客户端，客户端再用存好的相同的密钥解密。</p><h2 id="4-记录层"><a href="#4-记录层" class="headerlink" title="4. 记录层"></a>4. 记录层</h2><p>记录协议负责在传输连接上交换的所有底层消息，并且可以配置加密。每一条 TLS 记录以一个短标头开始。标头包含记录内容的类型 (或子协议)、协议版本和长度。原始消息经过分段 (或者合并)、压缩、添加认证码、加密转为 TLS 记录的数据部分。</p><p><img src="https://src.wangriyu.wang/images/blog/http/message.png" alt="image"></p><h3 id="分片-Fragmentation"><a href="#分片-Fragmentation" class="headerlink" title="分片 (Fragmentation)"></a>分片 (Fragmentation)</h3><p>记录层将信息块分割成携带 2^14 字节 (16KB) 或更小块的数据的 TLSPlaintext 记录。</p><p>记录协议传输由其他协议层提交给它的不透明数据缓冲区。如果缓冲区超过记录的长度限制（2^14），记录协议会将其切分成更小的片段。反过来也是可能的，属于同一个子协议的小缓冲区也可以组合成一个单独的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  uint8 major, minor;</span><br><span class="line">&#125; ProtocolVersion;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">  change_cipher_spec(20),</span><br><span class="line">  alert(21),</span><br><span class="line">  handshake(22),</span><br><span class="line">  application_data(23), (255)</span><br><span class="line">&#125; ContentType;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  ContentType type; // 用于处理封闭片段的较高级协议</span><br><span class="line">  ProtocolVersion version; // 使用的安全协议版本</span><br><span class="line">  uint16 length; // TLSPlaintext.fragment 的长度（以字节为单位），不超过 2^14</span><br><span class="line">  opaque fragment[TLSPlaintext.length]; // 透明的应用数据，被视为独立的块，由类型字段指定的较高级协议处理</span><br><span class="line">&#125; TLSPlaintext;</span><br></pre></td></tr></table></figure><h3 id="记录压缩和解压缩-Record-compression-and-decompression"><a href="#记录压缩和解压缩-Record-compression-and-decompression" class="headerlink" title="记录压缩和解压缩 (Record compression and decompression)"></a>记录压缩和解压缩 (Record compression and decompression)</h3><p>压缩算法将 TLSPlaintext 结构转换为 TLSCompressed 结构。如果定义 CompressionMethod 为 null 表示不压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  ContentType type; // same as TLSPlaintext.type</span><br><span class="line">  ProtocolVersion version; // same as TLSPlaintext.version</span><br><span class="line">  uint16 length; // TLSCompressed.fragment 的长度，不超过 2^14 + 1024</span><br><span class="line">  opaque fragment[TLSCompressed.length];</span><br><span class="line">&#125; TLSCompressed;</span><br></pre></td></tr></table></figure><h3 id="空或标准流加密-Null-or-standard-stream-cipher"><a href="#空或标准流加密-Null-or-standard-stream-cipher" class="headerlink" title="空或标准流加密 (Null or standard stream cipher)"></a>空或标准流加密 (Null or standard stream cipher)</h3><p>流加密（BulkCipherAlgorithm）将 TLSCompressed.fragment 结构转换为流 TLSCiphertext.fragment 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream-ciphered struct &#123;</span><br><span class="line">opaque content[TLSCompressed.length];</span><br><span class="line">opaque MAC[CipherSpec.hash_size];</span><br><span class="line">&#125; GenericStreamCipher;</span><br></pre></td></tr></table></figure><p>MAC 产生方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +</span><br><span class="line">TLSCompressed.version + TLSCompressed.length +</span><br><span class="line">TLSCompressed.fragment));</span><br></pre></td></tr></table></figure><p>seq_num（记录的序列号）、hash（SecurityParameters.mac_algorithm 指定的哈希算法）</p><blockquote><p>MAC(Message authentication code) - 消息认证码</p></blockquote><blockquote><p>注意，MAC 是在加密之前计算的。流加密加密整个块，包括 MAC。对于不使用同步向量 (例如 RC4) 的流加密，从一个记录结尾处的流加密状态仅用于后续数据包。如果 CipherSuite 是 TLS_NULL_WITH_NULL_NULL，则加密由身份操作 (数据未加密，MAC 大小为零，暗示不使用 MAC) 组成。TLSCiphertext.length 是 TLSCompressed.length 加上 CipherSpec.hash_size。</p></blockquote><h3 id="CBC-块加密-分组加密"><a href="#CBC-块加密-分组加密" class="headerlink" title="CBC 块加密 (分组加密)"></a>CBC 块加密 (分组加密)</h3><p>块加密（如 RC2 或 DES），将 TLSCompressed.fragment 结构转换为块 TLSCiphertext.fragment 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block-ciphered struct &#123;</span><br><span class="line">  opaque content[TLSCompressed.length];</span><br><span class="line">  opaque MAC[CipherSpec.hash_size];</span><br><span class="line">  uint8 padding[GenericBlockCipher.padding_length];</span><br><span class="line">  uint8 padding_length;</span><br><span class="line">&#125; GenericBlockCipher;</span><br></pre></td></tr></table></figure><p>padding: 添加的填充将明文长度强制为块密码块长度的整数倍。填充可以是长达 255 字节的任何长度，只要满足 TLSCiphertext.length 是块长度的整数倍。长度大于需要的值可以阻止基于分析交换信息长度的协议攻击。填充数据向量中的每个 uint8 必须填入填充长度值 (即 padding_length)。</p><p>padding_length: 填充长度应该使得 GenericBlockCipher 结构的总大小是加密块长度的倍数。合法值范围从零到 255（含）。<strong>该长度指定 padding_length 字段本身除外的填充字段的长度</strong></p><p>加密块的数据长度（TLSCiphertext.length）是 TLSCompressed.length，CipherSpec.hash_size 和 padding_length 的总和加一</p><blockquote><p>示例: 如果块长度为 8 字节，压缩内容长度（TLSCompressed.length）为 61 字节，MAC 长度为 20 字节，则填充前的长度为 82 字节（padding_length 占 1 字节）。<br>因此，为了使总长度为块长度 (8 字节) 的偶数倍，模 8 的填充长度必须等于 6，所以填充长度可以为 6，14，22 等。如果填充长度是需要的最小值，比如 6，填充将为 6 字节，每个块都包含值 6。因此，块加密之前的 GenericBlockCipher 的最后 8 个八位字节将为 xx 06 06 06 06 06 06 06，其中 xx 是 MAC 的最后一个八位字节。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; XX  - 06 06 06 06 06 06 - 06</span><br><span class="line">&gt; MAC -     padding[6]    - padding_length</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="记录有效载荷保护-Record-payload-protection"><a href="#记录有效载荷保护-Record-payload-protection" class="headerlink" title="记录有效载荷保护 (Record payload protection)"></a>记录有效载荷保护 (Record payload protection)</h3><p>加密和 MAC 功能将 TLSCompressed 结构转换为 TLSCiphertext。记录的 MAC 还包括序列号，以便可以检测到丢失，额外或重复的消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  ContentType type; // same</span><br><span class="line">  ProtocolVersion version; // same</span><br><span class="line">  uint16 length; // TLSCiphertext.fragment 的长度，不超过 2^14 + 2048</span><br><span class="line">  select (CipherSpec.cipher_type) &#123;</span><br><span class="line">    case stream: GenericStreamCipher;</span><br><span class="line">    case block: GenericBlockCipher;</span><br><span class="line">  &#125; fragment; // TLSCompressed.fragment 的加密形式，带有 MAC</span><br><span class="line">&#125; TLSCiphertext;</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>这里提到的都是先 MAC 再加密，是基于 RFC 2246 的方案 (TLS 1.0) 写的。但新的方案选择先加密再 MAC，这种替代方案中，首先对明文和填充进行加密，再将结果交给 MAC 算法。这可以保证主动网络攻击者不能操纵任何加密数据。</p></blockquote><h3 id="密钥计算-Key-calculation"><a href="#密钥计算-Key-calculation" class="headerlink" title="密钥计算 (Key calculation)"></a>密钥计算 (Key calculation)</h3><p>记录协议需要一种算法，从握手协议提供的安全性参数生成密钥、<a href="https://zh.wikipedia.org/wiki/%E5%88%9D%E5%A7%8B%E5%90%91%E9%87%8F" target="_blank" rel="noopener">IV</a> 和 MAC secret.</p><p>主密钥 (Master secret): 在连接中双方共享的一个 48 字节的密钥<br>客户随机数 (client random): 由客户端提供的 32 字节值<br>服务器随机数 (server random): 由服务器提供的 32 字节值</p><h2 id="5-握手层"><a href="#5-握手层" class="headerlink" title="5. 握手层"></a>5. 握手层</h2><ul><li>握手协议的职责是生成通信过程所需的共享密钥和进行身份认证。这部分使用无密码套件，为防止数据被窃听，通过公钥密码或 Diffie-Hellman 密钥交换技术通信。</li><li>密码规格变更协议，用于密码切换的同步，是在握手协议之后的协议。握手协议过程中使用的协议是“不加密”这一密码套件，握手协议完成后则使用协商好的密码套件。</li><li>警告协议，当发生错误时使用该协议通知通信对方，如握手过程中发生异常、消息认证码错误、数据无法解压缩等。</li><li>应用数据协议，通信双方真正进行应用数据传输的协议，传送过程通过 TLS 应用数据协议和 TLS 记录协议来进行传输。</li></ul><p>握手是 TLS 协议中最精密复杂的部分。在这个过程中，通信双方协商连接参数，并且完成身 份验证。根据使用的功能的不同，整个过程通常需要交换 6~10 条消息。根据配置和支持的协议扩展的不同，交换过程可能有许多变种。在使用中经常可以观察到以下三种流程：(1) 完整的握手， 对服务器进行身份验证；(2) 恢复之前的会话采用的简短握手；(3) 对客户端和服务器都进行身份验证的握手。</p><p>握手协议消息的标头信息包含消息类型（1 字节）和长度（3 字节），余下的信息则取决于消息类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  HandshakeType msg_type;</span><br><span class="line">  uint24 length;</span><br><span class="line">  HandshakeMessage message;</span><br><span class="line">&#125; Handshake;</span><br></pre></td></tr></table></figure><h3 id="5-1-完整握手"><a href="#5-1-完整握手" class="headerlink" title="5.1 完整握手"></a>5.1 完整握手</h3><p>每一个 TLS 连接都会以握手开始。如果客户端此前并未与服务器建立会话，那么双方会执行一次完整的握手流程来协商 TLS 会话。握手过程中，客户端和服务器将进行以下四个主要步骤:</p><ul><li>交换各自支持的功能，对需要的连接参数达成一致</li><li>验证出示的证书，或使用其他方式进行身份验证</li><li>对将用于保护会话的共享主密钥达成一致</li><li>验证握手消息并未被第三方团体修改</li></ul><p>下面介绍最常见的握手规则，一种不需要验证客户端身份但需要验证服务器身份的握手:</p><p><img src="https://src.wangriyu.wang/images/blog/http/full-handshake.png" alt="image"></p><h4 id="5-1-1-ClientHello"><a href="#5-1-1-ClientHello" class="headerlink" title="5.1.1 ClientHello"></a>5.1.1 ClientHello</h4><p>这条消息将客户端的功能和首选项传送给服务器。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-clienthello.png" alt="image"></p><ul><li>Version: 协议版本（protocol version）指示客户端支持的最佳协议版本</li><li>Random: 一个 32 字节数据，28 字节是随机生成的 (图中的 Random Bytes)；剩余的 4 字节包含额外的信息，与客户端时钟有关 (图中使用的是 GMT Unix Time)。在握手时，客户端和服务器都会提供随机数，客户端的暂记作 random_C (用于后续的密钥的生成)。这种随机性对每次握手都是独一无二的，在身份验证中起着举足轻重的作用。它可以防止 <a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">重放攻击</a>，并确认初始数据交换的完整性。</li><li>Session ID: 在第一次连接时，会话 ID（session ID）字段是空的，这表示客户端并不希望恢复某个已存在的会话。典型的会话 ID 包含 32 字节随机生成的数据，一般由服务端生成通过 ServerHello 返回给客户端。</li><li>Cipher Suites: 密码套件（cipher suite）块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的</li><li>Compression: 客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是 null，代表没有压缩</li><li>Extensions: 扩展（extension）块由任意数量的扩展组成。这些扩展会携带额外数据</li></ul><h4 id="5-1-2-ServerHello"><a href="#5-1-2-ServerHello" class="headerlink" title="5.1.2 ServerHello"></a>5.1.2 ServerHello</h4><p>是将服务器选择的连接参数传回客户端。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-serverhello.png" alt="image"></p><p>这个消息的结构与 ClientHello 类似，只是每个字段只包含一个选项，其中包含服务端的 random_S 参数 (用于后续的密钥协商)。服务器无需支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受</p><p>图中的 <code>Cipher Suite</code> 是后续密钥协商和身份验证要用的加密套件，此处选择的密钥交换与签名算法是 ECDHE_RSA，对称加密算法是 AES-GCM，后面会讲到这个</p><p>还有一点默认情况下 TLS 压缩都是关闭的，因为 <a href="https://zh.wikipedia.org/wiki/CRIME" target="_blank" rel="noopener">CRIME</a> 攻击会利用 TLS 压缩恢复加密认证 cookie，实现会话劫持，而且一般配置 gzip 等内容压缩后再压缩 TLS 分片效益不大又额外占用资源，所以一般都关闭 TLS 压缩</p><h4 id="5-1-3-Certificate"><a href="#5-1-3-Certificate" class="headerlink" title="5.1.3 Certificate"></a>5.1.3 Certificate</h4><p>典型的 Certificate 消息用于携带服务器 X.509 <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88" target="_blank" rel="noopener">证书链</a>。<br>服务器必须保证它发送的证书与选择的算法套件一致。比方说，公钥算法与套件中使用的必须匹配。除此以外，一些密钥交换算法依赖嵌入证书的特定数据，而且要求证书必须以客户端支持的算法签名。所有这些都表明服务器需要配置多个证书（每个证书可能会配备不同的证书链）。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-certificate.png" alt="image"></p><p>Certificate 消息是可选的，因为并非所有套件都使用身份验证，也并非所有身份验证方法都需要证书。更进一步说，虽然消息默认使用 X.509 证书，但是也可以携带其他形式的标志；一些套件就依赖 <a href="https://zh.wikipedia.org/wiki/PGP" target="_blank" rel="noopener">PGP 密钥</a></p><h4 id="5-1-4-ServerKeyExchange"><a href="#5-1-4-ServerKeyExchange" class="headerlink" title="5.1.4 ServerKeyExchange"></a>5.1.4 ServerKeyExchange</h4><p>携带密钥交换需要的额外数据。ServerKeyExchange 是可选的，消息内容对于不同的协商算法套件会存在差异。部分场景下，比如使用 RSA 算法时，服务器不需要发送此消息。</p><p>ServerKeyExchange 仅在服务器证书消息（也就是上述 Certificate 消息）不包含足够的数据以允许客户端交换预主密钥（premaster secret）时才由服务器发送。</p><p>比如基于 DH 算法的握手过程中，需要单独发送一条 ServerKeyExchange 消息带上 DH 参数:</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-serverhellodone.png" alt="image"></p><h4 id="5-1-5-ServerHelloDone"><a href="#5-1-5-ServerHelloDone" class="headerlink" title="5.1.5 ServerHelloDone"></a>5.1.5 ServerHelloDone</h4><p>表明服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。</p><h4 id="5-1-6-verify-certificate"><a href="#5-1-6-verify-certificate" class="headerlink" title="5.1.6 verify certificate"></a>5.1.6 verify certificate</h4><p>客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证内容包括如下:</p><ul><li>证书链的可信性 trusted certificate path;</li><li>证书是否吊销 revocation，有两类方式 - 离线 CRL 与在线 OCSP，不同的客户端行为会不同;</li><li>有效期 expiry date，证书是否在有效时间范围;</li><li>域名 domain，核查证书域名是否与当前的访问域名匹配;</li></ul><p>由 <code>PKI 体系</code> 的内容可知，对端发来的证书签名是 CA 私钥加密的，接收到证书后，先读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性；然后去查询证书的吊销情况等</p><h4 id="5-1-7-ClientKeyExchange"><a href="#5-1-7-ClientKeyExchange" class="headerlink" title="5.1.7 ClientKeyExchange"></a>5.1.7 ClientKeyExchange</h4><p>合法性验证通过之后，客户端计算产生随机数字的预主密钥（Pre-master），并用证书公钥加密，发送给服务器并携带客户端为密钥交换提供的所有信息。这个消息受协商的密码套件的影响，内容随着不同的协商密码套件而不同。</p><p>此时客户端已经获取全部的计算协商密钥需要的信息: 两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，然后得到协商密钥(用于之后的消息加密)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enc_key = PRF(Pre_master, &quot;master secret&quot;, random_C + random_S)</span><br></pre></td></tr></table></figure><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-clientkeychange.png" alt="image"></p><p>图中使用的是 ECDHE 算法，ClientKeyExchange 传递的是 DH 算法的客户端参数，如果使用的是 RSA 算法则此处应该传递加密的预主密钥</p><h4 id="5-1-8-ChangeCipherSpec"><a href="#5-1-8-ChangeCipherSpec" class="headerlink" title="5.1.8 ChangeCipherSpec"></a>5.1.8 ChangeCipherSpec</h4><p>通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信</p><blockquote><p>注意<br>ChangeCipherSpec 不属于握手消息，它是另一种协议，只有一条消息，作为它的子协议进行实现。</p></blockquote><h4 id="5-1-9-Finished-Encrypted-Handshake-Message"><a href="#5-1-9-Finished-Encrypted-Handshake-Message" class="headerlink" title="5.1.9 Finished (Encrypted Handshake Message)"></a>5.1.9 Finished (Encrypted Handshake Message)</h4><p>Finished 消息意味着握手已经完成。消息内容将加密，以便双方可以安全地交换验证整个握手完整性所需的数据。</p><p>这个消息包含 verify_data 字段，它的值是握手过程中所有消息的散列值。这些消息在连接两端都按照各自所见的顺序排列，并以协商得到的主密钥 (enc_key) 计算散列。这个过程是通过一个伪随机函数（pseudorandom function，PRF）来完成的，这个函数可以生成任意数量的伪随机数据。<br>两端的计算方法一致，但会使用不同的标签（finished_label）：客户端使用 client finished，而服务器则使用 server finished。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verify_data = PRF(master_secret, finished_label, Hash(handshake_messages))</span><br></pre></td></tr></table></figure><p>因为 Finished 消息是加密的，并且它们的完整性由协商 MAC 算法保证，所以主动网络攻击者不能改变握手消息并对 vertify_data 的值造假。在 TLS 1.2 版本中，Finished 消息的长度默认是 12 字节（96 位），并且允许密码套件使用更长的长度。在此之前的版本，除了 SSL 3 使用 36 字节的定长消息，其他版本都使用 12 字节的定长消息。</p><h4 id="5-1-10-Server"><a href="#5-1-10-Server" class="headerlink" title="5.1.10 Server"></a>5.1.10 Server</h4><p>服务器用私钥解密加密的 Pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，同样计算得到协商密钥: <code>enc_key = PRF(Pre_master, &quot;master secret&quot;, random_C + random_S)</code>;</p><p>同样计算之前所有收发信息的 hash 值，然后用协商密钥解密客户端发送的 verify_data_C，验证消息正确性;</p><h4 id="5-1-11-change-cipher-spec"><a href="#5-1-11-change-cipher-spec" class="headerlink" title="5.1.11 change_cipher_spec"></a>5.1.11 change_cipher_spec</h4><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-serverchangecipher.png" alt="image"></p><p>服务端验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信（图中多了一步 New Session Ticket，此为会话票证，会在会话恢复中解释）;</p><h4 id="5-1-12-Finished-Encrypted-Handshake-Message"><a href="#5-1-12-Finished-Encrypted-Handshake-Message" class="headerlink" title="5.1.12 Finished (Encrypted Handshake Message)"></a>5.1.12 Finished (Encrypted Handshake Message)</h4><p>服务器也结合所有当前的通信参数信息生成一段数据 (verify_data_S) 并采用协商密钥 session secret (enc_key) 与算法加密并发送到客户端;</p><h4 id="5-1-13-握手结束"><a href="#5-1-13-握手结束" class="headerlink" title="5.1.13 握手结束"></a>5.1.13 握手结束</h4><p>客户端计算所有接收信息的 hash 值，并采用协商密钥解密 verify_data_S，验证服务器发送的数据和密钥，验证通过则握手完成;</p><h4 id="5-1-14-加密通信"><a href="#5-1-14-加密通信" class="headerlink" title="5.1.14 加密通信"></a>5.1.14 加密通信</h4><p>开始使用协商密钥与算法进行加密通信。</p><p><img src="https://src.wangriyu.wang/images/blog/http/wireshark-applicationdata.png" alt="image"></p><h3 id="5-2-密钥交换和签名算法"><a href="#5-2-密钥交换和签名算法" class="headerlink" title="5.2 密钥交换和签名算法"></a>5.2 密钥交换和签名算法</h3><h4 id="常用的密钥交换和签名算法"><a href="#常用的密钥交换和签名算法" class="headerlink" title="常用的密钥交换和签名算法"></a>常用的密钥交换和签名算法</h4><p>HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能。加密过程中，需要用到非对称密钥交换和对称内容加密两大算法。</p><p>对称内容加密强度非常高，加解密速度也很快，只是无法安全地生成和保管密钥。在 TLS 协议中，最后的应用数据都是经过对称加密后传输的，传输中所使用的对称协商密钥(上文中的 enc_key)，则是在握手阶段通过非对称密钥交换而来。常见的 AES-GCM、ChaCha20-Poly1305，都是对称加密算法。</p><p>非对称密钥交换能在不安全的数据通道中，产生只有通信双方才知道的对称加密密钥。目前最常用的密钥交换算法有 RSA 和 ECDHE。</p><p>RSA 历史悠久，支持度好，但不支持 <a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E5%90%91%E5%AE%89%E5%85%A8%E6%80%A7" target="_blank" rel="noopener">完美前向安全 - PFS(Perfect Forward Secrecy)</a>；而 ECDHE 是使用了 ECC（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，且支持 PFS。</p><p>在 <code>PKI 体系</code> 一节中说明了仅有非对称密钥交换还是无法抵御 MITM 攻击的，所以需要引入了 PKI 体系的证书来进行身份验证，其中服务端非对称加密产生的公钥会放在证书中传给客户端。</p><p>在 RSA 密钥交换中，浏览器使用证书提供的 RSA 公钥加密相关信息，如果服务端能解密，意味着服务端拥有与公钥对应的私钥，同时也能算出对称加密所需密钥。密钥交换和服务端认证合并在一起。</p><p>在 ECDH 密钥交换中，服务端使用私钥 (RSA 或 ECDSA) 对相关信息进行签名，如果浏览器能用证书公钥验证签名，就说明服务端确实拥有对应私钥，从而完成了服务端认证。密钥交换则是各自发送 DH 参数完成的，密钥交换和服务端认证是完全分开的。</p><p>可用于 ECDHE 数字签名的算法主要有 <a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">RSA</a> 和 <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" target="_blank" rel="noopener">ECDSA - 椭圆曲线数字签名算法</a>，也就是目前密钥交换 + 签名有三种主流选择:</p><ul><li><code>RSA</code> - RSA 密钥交换（无需签名）</li><li><code>ECDHE_RSA</code> - ECDHE 密钥交换、RSA 签名</li><li><code>ECDHE_ECDSA</code> - ECDHE 密钥交换、ECDSA 签名</li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/signatureAlgorithm.png" alt="image"></p><p>比如我的网站使用的加密套件是 ECDHE_RSA，可以看到数字签名算法是 sha256 哈希加 RSA 加密，在 <code>PKI 体系</code> 一节中讲了签名是服务器信息摘要的哈希值加密生成的</p><p>内置 ECDSA 公钥的证书一般被称之为 ECC 证书，内置 RSA 公钥的证书就是 RSA 证书。因为 256 位 ECC Key 在安全性上等同于 3072 位 RSA Key，所以 ECC 证书体积比 RSA 证书小，而且 ECC 运算速度更快，ECDHE 密钥交换 + ECDSA 数字签名是目前最好的加密套件</p><p>以上内容来自本文: <a href="https://imququ.com/post/ecc-certificate.html" target="_blank" rel="noopener">开始使用 ECC 证书</a></p><p>关于 ECC 证书的更多细节可见文档: <a href="https://www.rfc-editor.org/rfc/rfc4492.txt" target="_blank" rel="noopener">ECC Cipher Suites for TLS - RFC4492</a></p><h4 id="RSA-密钥交换和-DH-密钥交换的区别"><a href="#RSA-密钥交换和-DH-密钥交换的区别" class="headerlink" title="RSA 密钥交换和 DH 密钥交换的区别"></a>RSA 密钥交换和 DH 密钥交换的区别</h4><p>使用 RSA 进行密钥交换的握手过程与前面说明的基本一致，只是没有 ServerKeyExchange 消息，其中协商密钥涉及到三个参数 (客户端随机数 random_C、服务端随机数 random_S、预主密钥 Premaster secret)，<br>其中前两个随机数和协商使用的算法是明文的很容易获取，最后一个 Premaster secret 会用服务器提供的公钥加密后传输给服务器 (密钥交换)，如果这个预主密钥被截取并破解则协商密钥也可以被破解。</p><p>RSA 算法的细节见: <a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">wiki</a> 和 <a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理（二）- 阮一峰</a></p><p>RSA 的算法核心思想是利用了极大整数 <a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">因数分解</a> 的计算复杂性</p><p>而使用 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">DH(Diffie-Hellman) 算法</a> 进行密钥交换，双方只要交换各自的 DH 参数(在 ServerKeyExchange 发送 Server params，在 ClientKeyExchange 发送 Client params)，不需要传递 Premaster secret，就可以各自算出这个预主密钥</p><p>DH 的握手过程如下，大致过程与 RSA 类似，图中只表达如何生成预主密钥:</p><p><img src="https://src.wangriyu.wang/images/blog/http/DH-handshake.png" alt="image"></p><p>服务器通过私钥将客户端随机数 random_C，服务端随机数 random_S，服务端 DH 参数 Server params 签名生成 signature，然后在 ServerKeyExchange 消息中发送服务端 DH 参数和该签名；</p><p>客户端收到后用服务器给的公钥解密验证签名，并在 ClientKeyExchange 消息中发送客户端 DH 参数 Client params；</p><p>服务端收到后，双方都有这两个参数，再各自使用这两个参数生成预主密钥 Premaster secret，之后的协商密钥等步骤与 RSA 基本一致。</p><blockquote><p>基于 RSA 算法与 DH 算法的握手最大的区别就在于密钥交换与身份认证。前者客户端使用公钥加密预主密钥并发送给服务端完成密钥交换，服务端利用私钥解密完成身份认证。后者利用各自发送的 DH 参数完成密钥交换，服务器私钥签名数据，客户端公钥验签完成身份认证。</p></blockquote><p>关于 DH 算法如何生成预主密钥，推荐看下 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">Wiki</a> 和 <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/#ephemeraldiffiehellmanhandshake" target="_blank" rel="noopener">Ephemeral Diffie-Hellman handshake</a></p><p>其核心思想是利用了 <a href="https://en.wikipedia.org/wiki/Discrete_logarithm" target="_blank" rel="noopener">离散对数问题</a> 的计算复杂性</p><blockquote><p>原根：假设一个整数 g 对于质数 P 来说是原根，那么 g^i mod P (1 ≦ i &lt; P) 的结果各不相同，且其结果按一定顺序排列后是 1 到 P-1 的所有整数，<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9#%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">例子</a></p></blockquote><blockquote><p>离散对数：如果对于一个整数 n 和质数 P 的一个原根 g，可以找到一个唯一的指数 i，使得 n = g^i mod P (0 ≦ i &lt; P)，那么指数 i 称为 n 的以 g 为基数的模 P 的离散对数</p></blockquote><blockquote><p>Diffie-Hellman 算法的有效性依赖于计算离散对数的难度，其含义是：当已知大素数 P 和它的一个原根 g 后，对给定的 n，要计算 i，被认为是很困难的，而给定 i 计算 n 却相对容易</p></blockquote><p>算法过程可以抽象成下图:</p><p><img src="https://src.wangriyu.wang/images/blog/http/Diffie-Hellman.png" alt="image"></p><p>双方预先商定好了一对 P g 值 (公开的)，而 Alice 有一个私密数 a(非公开，对应一个私钥)，Bob 有一个私密数 b(非公开，对应一个私钥)</p><ul><li><p>Alice 计算 A = g^a mod P，并把 A(公开，对应一个公钥) 发给 Bob</p></li><li><p>Bob 计算 B = g^b mod P，并把 B(公开，对应一个公钥) 发给 Alice</p></li><li><p>双方计算出共享密钥，K = B^a mod P = A^b mod P (= g^ab mod P)</p></li></ul><p>对于 Alice 和 Bob 来说通过对方发过来的公钥参数和自己手中的私钥可以得到最终相同的密钥</p><p>而第三方最多知道 P g A B，想得到私钥和最后的密钥很困难，当然前提是 a b P 足够大 (RFC3526 文档中有几个常用的大素数可供使用)，否则暴力破解也有可能试出答案，至于 g 一般取个较小值就可以</p><p>如下几张图是实际 DH 握手发送的内容:</p><p><img src="https://src.wangriyu.wang/images/blog/http/Cipher-suite.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/Server-params.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/Client-params.png" alt="image"></p><p>可以看到双方发给对方的参数中携带了一个公钥值，对应上述的 A 和 B</p><p>而且实际用的加密套件是 <a href="https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">椭圆曲线 DH 密钥交换 (ECDH)</a>，利用由椭圆曲线加密建立公钥与私钥对可以更进一步加强 DH 的安全性，因为目前解决椭圆曲线离散对数问题要比因式分解困难的多，而且 ECC 使用的密钥长度比 RSA 密钥短得多(目前 RSA 密钥需要 2048 位以上才能保证安全，而 ECC 密钥 256 位就足够)</p><p>关于 <a href="https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6" target="_blank" rel="noopener">椭圆曲线密码学 - ECC</a>，推荐看下 <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/" target="_blank" rel="noopener">A Primer on Elliptic Curve Cryptography - 原文</a> - <a href="https://zhuanlan.zhihu.com/p/26029199" target="_blank" rel="noopener">译文</a></p><h3 id="5-3-客户端身份验证"><a href="#5-3-客户端身份验证" class="headerlink" title="5.3 客户端身份验证"></a>5.3 客户端身份验证</h3><p>尽管可以选择对任意一端进行身份验证，但人们几乎都启用了对服务器的身份验证。如果服 务器选择的套件不是匿名的，那么就需要在 Certificate 消息中跟上自己的证书。</p><p><img src="https://src.wangriyu.wang/images/blog/http/mutualAuthentication.png" alt="image"></p><p>相比之下，服务器通过发送 CertificateRequest 消息请求对客户端进行身份验证。消息中列 出所有可接受的客户端证书。作为响应，客户端发送自己的 Certificate 消息（使用与服务器发 送证书相同的格式），并附上证书。此后，客户端发送 CertificateVerify 消息，证明自己拥有对应的私钥。</p><p>只有已经过身份验证的服务器才被允许请求客户端身份验证。基于这个原因，这个选项也被称为相互身份验证（mutual authentication）。</p><h4 id="5-3-1-CertificateRequest"><a href="#5-3-1-CertificateRequest" class="headerlink" title="5.3.1 CertificateRequest"></a>5.3.1 CertificateRequest</h4><p>在 ServerHello 的过程中发出，请求对客户端进行身份验证，并将其接受的证书的公钥 和签名算法传送给客户端。</p><p>它也可以选择发送一份自己接受的证书颁发机构列表，这些机构都用其可分辨名称来表示:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  ClientCertificateType certificate_types;</span><br><span class="line">  SignatureAndHashAlgorithm supported_signature_algorithms;</span><br><span class="line">  DistinguishedName certificate_authorities;</span><br><span class="line">&#125; CertificateRequest;</span><br></pre></td></tr></table></figure><p></p><h4 id="5-3-2-CertificateVerify"><a href="#5-3-2-CertificateVerify" class="headerlink" title="5.3.2 CertificateVerify"></a>5.3.2 CertificateVerify</h4><p>在 ClientKeyExchange 的过程中发出，证明自己拥有的私钥与之前发送的客户端证书中的公钥匹配。消息中包含一条到这一步为止的所有握手消息的签名：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  Signature handshake_messages_signature;</span><br><span class="line">&#125; CertificateVerify;</span><br></pre></td></tr></table></figure><p></p><h3 id="5-4-会话恢复"><a href="#5-4-会话恢复" class="headerlink" title="5.4 会话恢复"></a>5.4 会话恢复</h3><p>最初的会话恢复机制是，在一次完整协商的连接断开时，客户端和服务器都会将会话的安全参数保存一段时间。希望使用会话恢复的服务器为会话指定唯一的标识，称为会话 ID(Session ID)。服务器在 ServerHello 消息中将会话 ID 发回客户端。</p><p>希望恢复早先会话的客户端将适当的 Session ID 放入 ClientHello 消息，然后提交。服务器如果同意恢复会话，就将相同的 Session ID 放入 ServerHello 消息返回，接着使用之前协商的主密钥生成一套新的密钥，再切换到加密模式，发送 Finished 消息。<br>客户端收到会话已恢复的消息以后，也进行相同的操作。这样的结果是握手只需要一次网络往返。</p><p>Session ID 由服务器端支持，协议中的标准字段，因此基本所有服务器都支持，服务器端保存会话 ID 以及协商的通信信息，占用服务器资源较多。</p><p><img src="https://src.wangriyu.wang/images/blog/http/simple-handshake.png" alt="image"></p><p>用来替代服务器会话缓存和恢复的方案是使用会话票证（Session ticket）。使用这种方式，除了所有的状态都保存在客户端（与 HTTP Cookie 的原理类似）之外，其消息流与服务器会话缓存是一样的。</p><p>其思想是服务器取出它的所有会话数据（状态）并进行加密 (密钥只有服务器知道)，再以票证的方式发回客户端。在接下来的连接中，客户端恢复会话时在 <strong>ClientHello 的扩展字段</strong> session_ticket 中携带加密信息将票证提交回服务器，由服务器检查票证的完整性，解密其内容，再使用其中的信息恢复会话。</p><p>这种方法有可能使扩展服务器集群更为简单，因为如果不使用这种方式，就需要在服务集群的各个节点之间同步会话。<br>Session ticket 需要服务器和客户端都支持，属于一个扩展字段，占用服务器资源很少。</p><blockquote><p>警告<br>会话票证破坏了 TLS 安全模型。它使用票证密钥加密的会话状态并将其暴露在线路上。有些实现中的票证密钥可能会比连接使用的密码要弱。如果票证密钥被暴露，就可以解密连接上的全部数据。因此，使用会话票证时，票证密钥需要频繁轮换。</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.ietf.org/rfc/rfc2246.txt" target="_blank" rel="noopener">RFC 2246 - The TLS Protocol Version 1.0</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">NPN/ALPN - wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">TLS - wiki</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc785811(v=ws.10" target="_blank" rel="noopener">SSL/TLS in detail</a>)</li><li><a href="https://www.wosign.com/faq/faq2016-0309-02.htm" target="_blank" rel="noopener">HTTPS 加密协议详解</a></li><li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/#rsahandshake" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a></li><li><a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm" target="_blank" rel="noopener">DSA - 数字签名算法</a></li><li>《HTTPS 权威指南 - 在服务器和 web 应用上部署 SSL/TLS 和 PKI》</li></ul>]]></content>
    
    <summary type="html">
    
      深入 tls 协议，了解 https 加密的过程
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Message</title>
    <link href="https://blog.wangriyu.wang/2018/03-http-message.html"/>
    <id>https://blog.wangriyu.wang/2018/03-http-message.html</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-06-08T14:24:07.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="noopener">RFC2616</a> 中定义的 HTTP Request 消息体结构：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Request = Request-Line             // 请求行</span><br><span class="line">          *(( general-header       // 通用首部</span><br><span class="line">            | request-header       // 请求首部</span><br><span class="line">            | entity-header )CRLF) // 实体首部</span><br><span class="line">          CRLF</span><br><span class="line">          [ message-body ]</span><br></pre></td></tr></table></figure><p></p><p><img src="https://src.wangriyu.wang/images/blog/http/request.png" alt="image"></p><p>一个 HTTP 的 request 消息以一个请求行开始，从第二行开始是 headers (️每个键值对都以 CRLF 结尾)，接下来是一个 CRLF 开头的空行，表示 header 结束，最后是消息主体。</p><h3 id="请求行的定义如下"><a href="#请求行的定义如下" class="headerlink" title="请求行的定义如下:"></a>请求行的定义如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request-Line = Method SP Request-URI SP HTTP-Version CRLF</span><br><span class="line"></span><br><span class="line">Method = &quot;OPTIONS&quot; | &quot;GET&quot; | &quot;HEAD&quot; | &quot;POST&quot; | &quot;PUT&quot; | &quot;DELETE&quot; | &quot;TRACE&quot; | &quot;CONNECT&quot; | extension-method</span><br><span class="line"></span><br><span class="line">Request-URI = &quot;*&quot; | absoluteURI | abs_path | authotity（CONNECT）</span><br></pre></td></tr></table></figure><h3 id="请求方法（也叫请求动作）"><a href="#请求方法（也叫请求动作）" class="headerlink" title="请求方法（也叫请求动作）"></a>请求方法（也叫请求动作）</h3><ul><li>GET 请求会显示请求指定的资源。一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET 会方法请求指定的页面信息，并返回响应主体，GET 被认为是不安全的方法，因为 GET 方法会被网络蜘蛛等任意的访问。</li><li>HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。</li><li>POST 请求会向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或 / 和修改现有资源。</li><li>PUT 请求会身向指定资源位置上传其最新内容，PUT 方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</li><li>DELETE 请求用于请求服务器删除所请求 URI 所标识的资源。DELETE 请求后指定资源会被删除，DELETE 方法也是幂等的。</li><li>CONNECT 方法是 HTTP/1.1 协议预留的，代表使用隧道协议 (Tunneling Protocol) 进行连接。通常用于 SSL/TLS 加密服务器的链接与非加密的 HTTP 代理服务器的通信。</li><li>OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用 ‘*’ 来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li><li>TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。</li></ul><h3 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request-URI = &quot;*&quot; | absoluteURI | abs_path | authority（CONNECT）</span><br></pre></td></tr></table></figure><ul><li>“*“ 代表请求不指向特定的资源，而是服务器本身，且只在所使用的方法没必要应用到资源时允许。一个典型的例子是 <code>OPTIONS * HTTP/1.1</code></li><li>absoluteURI 绝对地址，比如 <code>GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1</code>。只用于向代理服务器 (proxy) 发送请求</li><li>abs_path 相对路径，“/” 代表服务器根</li><li>只有 CONNECT 方法使用 authority 形式，由域名和可选端口组成的 URL，比如 <code>CONNECT developer.mozilla.org:80 HTTP/1.1</code></li></ul><blockquote><p>向一个代理服务器发送 HTTP 请求时，请求行中应该使用绝对路径的 URL。如果向目标服务器直接发送请求，则请求行中只会包含相对路径的 URL(完整 URL 的 path 部分)。<br>为了能在后续 http 版本中过渡，所有 http/1.1 服务器都应该能够处理 absoluteURI 形式的请求，即使客户端只会向代理发送这种形式的请求，详见 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2</a></p></blockquote><p>HTTP/1.1 中 Host 和 Request-URI 一起作为 Request 消息接收者判断请求资源的条件, 确认主机资源的方法如下：</p><ul><li><p>如果 Request-URI 是绝对地址（absoluteURI），这时请求里的主机存在于 Request-URI 里。忽略任何出现在请求里 Host 头域值</p></li><li><p>假如 Request-URI 不是绝对地址（absoluteURI），并且请求包括一个 Host 头域，则主机由该 Host 头域值决定</p></li><li><p>假如由规则１或规则２定义的主机是一个无效的主机，则应当以一个 400（错误请求）错误消息返回</p></li></ul><blockquote><p>⚠️ HTTP/1.1 请求必须带 Host 头域，否则会报 bad request;</p></blockquote><blockquote><p>HTTP/1.0 不支持 Host 头域，因为 1.0 认为一个 ip 只绑定一个主机，通过 ip 就能确认主机，但后来一台服务器可以存在多个虚拟主机 (virtual host) 共用一个 ip 的情况，所以 1.1 添加 Host 头域显示指定主机。</p></blockquote><h3 id="URI-统一资源标识符，Uniform-Resource-Identifier"><a href="#URI-统一资源标识符，Uniform-Resource-Identifier" class="headerlink" title="URI(统一资源标识符，Uniform Resource Identifier)"></a>URI(统一资源标识符，Uniform Resource Identifier)</h3><p>URI 就是由某个协议方案表示的资源的定位标识符，这个协议可以使 htpp、https、ftp 等，比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ftp://ftp.is.co.za/rfc/rfc1808.txt</span><br><span class="line">http://www.ietf.org/rfc/rfc2396.txt</span><br><span class="line">ldap://[2001:db8::7]/c=GB?objectClass?one</span><br><span class="line">mailto:John.Doe@example.com</span><br><span class="line">news:comp.infosystems.www.servers.unix</span><br><span class="line">tel:+1-816-555-1212 telnet://192.0.2.16:80/</span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:4.1.2</span><br></pre></td></tr></table></figure><p></p><p>绝对 URI 的格式应该是这样的:</p><hr><p><u>http</u>://<u>user:pass</u>@<u><a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></u>:<u>80</u>/<u>dir/index.html</u>?<u>uid=1</u>#<u>ch1</u></p><p>协议:// 登录信息 @服务器地址: 端口号 / 文件路径? 查询字符串#片段标识符</p><hr><blockquote><p>与 URL(统一资源定位符，Universal Resource Locator) 和 URN(统一资源名，Uniform Resource Name) 的关系：</p></blockquote><blockquote><blockquote><p>URL 和 URN 是 URI 的两个子集，URI 唯一标识了文件资源对象 (类似身份证)，URN 标识资源名称，URL 标识资源地址</p></blockquote></blockquote><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response = Status-Line             // 状态行</span><br><span class="line">           *(( general-header      // 通用首部</span><br><span class="line">            | response-header      // 响应首部</span><br><span class="line">            | entity-header )CRLF) // 实体首部</span><br><span class="line">           CRLF</span><br><span class="line">           [ message-body ]</span><br></pre></td></tr></table></figure><p><img src="https://src.wangriyu.wang/images/blog/http/response.png" alt="image"></p><p>response 第一行是状态行，包含状态码 Status-Code，Reason-Phrase 是状态码的简单文本描述 (比如 200 - OK、404 - Not Found)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</span><br></pre></td></tr></table></figure><p>Status-Code:</p><ul><li>1xx: 信息性——收到请求，继续处理</li><li>2xx: 成功性——成功收到、理解并接受行动</li><li>3xx: 重定向——必须采取进一步行动来完成请求</li><li>4xx: 客户端错误——请求包含错误语法或不能完成</li><li>5xx: 服务器错误——服务器没有成功完成显然有效的请求</li></ul><h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><p>HTTP 消息的 message-body（如果存在）用于挟带与请求或响应相关联的 entity-body.<br>message-body 只有在应用了 transfer-coding 时，通过 Transfer-Encoding 头部域指出，与 entity-body 不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message-body = entity-body | &lt;entity-body encoded as per Transfer-Encoding&gt;</span><br></pre></td></tr></table></figure><h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><p>这里只列举了 2616 中提到的头部域，还有很多新添加的头部域，可以自行查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">general-header = Cache-Control      // 控制缓存的行为，比如 `private, max-age=0, no-cache`</span><br><span class="line">                | Connection        // 控制不再转发给代理的首部字段或者管理持久连接 (Keep-Alive 或者 close)</span><br><span class="line">                | Date              // 表明创建 HTTP 报文的日期和时间</span><br><span class="line">                | Pragma            // 唯一字段 `no-cache`，用于兼容 HTTP/1.1 之前的版本，客户端会要求所有的中间服务器不返回缓存的资源</span><br><span class="line">                | Trailer           // 事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码</span><br><span class="line">                | Transfer-Encoding // 规定了传输报文主体时采用的编码方式，比如 `chunked`</span><br><span class="line">                | Upgrade           // 检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade</span><br><span class="line">                | Via               // 追踪客户端与服务器之间的请求和响应报文 的传输路径</span><br><span class="line">                | Warning           // 从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告，字段格式:`[警告码][警告的主机: 端口号]“[警告内容]”([日期时间])`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">request-header = Accept               // 通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级（可用权重 q=0~1 来表示相对优先级）。可使用 type/subtype 这种形式，一次指定多种媒体类型，支持通配符。例如 `text/html, text/plain, text/css, image/jpeg, video/mpeg, application/zip` 等</span><br><span class="line">                | Accept-Charset      // 通知服务器用户代理支持的字符集及字符集的相对优先顺序，可一次性指定多种字符集</span><br><span class="line">                | Accept-Encoding     // 告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码，例如: `gzip, compress, deflate, identity`</span><br><span class="line">                | Accept-Language     // 告知服务器用户代理能够处理的自然语言集及优先级顺序，例如: `zh-cn,zh;q=0.7,en-us,en;q=0.3` 优先返回中文版响应</span><br><span class="line">                | Authorization       // 告知服务器，用户代理的认证信息（证书值），例如: `Basic dWVub3NlbjpwYXNzd29yZA==`</span><br><span class="line">                | Expect              // 告知服务器，客户端期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</span><br><span class="line">                | From                // 告知服务器使用用户代理的用户的电子邮件地址</span><br><span class="line">                | Host                // Host 会告知服务器，请求的资源所处的互联网主机名和端口号</span><br><span class="line">                | If-Match            // 只有当 If-Match 的字段值跟资源的 ETag 值匹配一致时，服务器才会接受请求，否则返回状态码 412 Precondition Failed</span><br><span class="line">                | If-Modified-Since   // If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器才会接受请求，否则返回状态码 304 Not Modified</span><br><span class="line">                | If-None-Match       // If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反</span><br><span class="line">                | If-Range            // 告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</span><br><span class="line">                | If-Unmodified-Since // 与 If-Modified-Since 的作用相反</span><br><span class="line">                | Max-Forwards        // 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目，服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，直接返回响应。</span><br><span class="line">                | Proxy-Authorization // 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</span><br><span class="line">                | Range               // 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。例如: `bytes=5001-10000` 表示请求获取从第 5001 字节至第 10000 字节的资源。服务器会在处理请求之后返回 206 Partial Content 的响应。无法处理该范围请求时，则返回 200 OK 的响应及全部资源。</span><br><span class="line">                | Referer             // 告知服务器请求的原始资源的 URI。</span><br><span class="line">                | TE                  // 告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</span><br><span class="line">                | User-Agent          // 将创建请求的浏览器和用户代理名称等信息传达给服务器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response-header = Accept-Ranges      // 告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可处理范围请求时指定其为 bytes，反之则指定其为 none。</span><br><span class="line">                | Age                // 告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</span><br><span class="line">                | ETag               // 告知客户端实体标签 (Entity Tag)。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。有强弱之分，弱 Etag 以 &apos;w/&apos; 开头。</span><br><span class="line">                | Location           // 将响应接收方引导至某个与请求 URI 位置不同的资源。该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</span><br><span class="line">                | Proxy-Authenticate // 由代理服务器所要求的认证信息发送给客户端。</span><br><span class="line">                | Retry-After        // 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数</span><br><span class="line">                | Server             // 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。例如: `Apache/2.2.6 (Unix) PHP/5.2.5`</span><br><span class="line">                | Vary               // 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</span><br><span class="line">                | WWW-Authenticate   // WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entity-header = Allow              // 服务端通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回</span><br><span class="line">                | Content-Encoding // 告知客户端服务器对实体的主体部分选用的内容编码方式，字段值参见 Accept-Encoding</span><br><span class="line">                | Content-Language // 会告知客户端，实体主体使用的自然语言，例如: `zh-CN`</span><br><span class="line">                | Content-Length   // 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段</span><br><span class="line">                | Content-Location // 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</span><br><span class="line">                | Content-MD5      // 客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。无法检测出恶意篡改</span><br><span class="line">                | Content-Range    // 能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。例如: `bytes 5001-10000/10000`</span><br><span class="line">                | Content-Type     // 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。例如: `text/html; charset=UTF-8`</span><br><span class="line">                | Expires          // 将资源失效的日期告知客户端。当首部字段 Cache-Control 有指定 max-age 指令时，Cache-Control 优先级大于 Expires</span><br><span class="line">                | Last-Modified    // 指明资源最终修改的时间</span><br><span class="line">                | extension-header // 允许定义额外的 entity-header 域而不改变协议，但不能假设接收方认识这些域。接收方应该忽略未识别的头域，但透明代理必须转发它</span><br></pre></td></tr></table></figure><h3 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h3><h4 id="浏览器在加载资源的时，先根据-http-header-判断它是否命中强缓存"><a href="#浏览器在加载资源的时，先根据-http-header-判断它是否命中强缓存" class="headerlink" title="浏览器在加载资源的时，先根据 http header 判断它是否命中强缓存."></a>浏览器在加载资源的时，先根据 http header 判断它是否命中强缓存.</h4><ul><li>命中强缓存：浏览器直接从自己缓存中读取资源，不发送请求到服务器</li><li>不命中强缓存：浏览器发送一个请求到服务器，服务器根据资源携带的 http header 验证该资源是否命中协商缓存<ul><li>命中协商缓存：将请求返回，但不是返回该资源的数据，而是告诉浏览器可以直接从缓存中加载这个资源。</li><li>不命中协商缓存：服务器返回该资源数据</li></ul></li></ul><p><img src="https://src.wangriyu.wang/images/blog/http/Intermediaries.png" alt="image"></p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>-【Cache-Control、Expires】: Expires 指定一个过期的时间戳 (绝对时间)，Cache-Control 指定缓存行为 (比如 max-age=604800 代表有效期为七天，是相对时间)。一般用其中一个，如果两个同时出现，Cache-Control 优先级大于 Expires。</p><blockquote><p>Cache-Control 是 http/1.1 弥补 Expires 缺陷新加入的，增加了很多行为</p></blockquote><table><thead><tr><th>Cache-Control</th><th>description</th></tr></thead><tbody><tr><td>public</td><td>资源将被客户端和代理服务器缓存</td></tr><tr><td>private</td><td>资源仅被客户端缓存, 代理服务器不缓存</td></tr><tr><td>no-store</td><td>请求和响应都不缓存 (真正地不缓存)</td></tr><tr><td>no-cache</td><td>do-not-serve-from-cache-without-revalidation，响应实际上可以缓存在本地缓存区，只是在与原服务器进行新鲜度验证之前不能返回给客户端</td></tr><tr><td>max-age</td><td>缓存资源, 但是在指定时间 (单位为秒) 后缓存过期</td></tr><tr><td>s-maxage</td><td>同上, 依赖 public 设置, 覆盖 max-age, 且只在代理服务器上有效</td></tr><tr><td>max-stale</td><td>指定时间内, 即使缓存过时, 资源依然有效</td></tr><tr><td>min-fresh</td><td>缓存的资源至少要保持指定时间的新鲜期</td></tr><tr><td>must-revalidation / proxy-revalidation</td><td>如果缓存失效, 强制重新向服务器 (或代理) 发起验证 (使用 must-revalidate 指令会忽略请求的 max-stale 指令)</td></tr><tr><td>only-if-cached</td><td>仅仅返回已经缓存的资源, 不访问源服务器, 若无缓存则返回 504 Gateway Timeout</td></tr><tr><td>no-transform</td><td>强制要求代理服务器不要对资源进行转换, 禁止代理服务器对 Content-Encoding, Content-Range, Content-Type 字段的修改 (因此代理的 gzip 压缩将不被允许)</td></tr><tr><td>cache-extension token</td><td>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令，如果缓存服务器不能理解这个新指令，就会直接忽略</td></tr></tbody></table><p><img src="https://src.wangriyu.wang/images/blog/http/StrongCache.png" alt="image"></p><p>在控制台中可以查看读取的是本地缓存还是向服务器拉取的资源:</p><p><img src="https://src.wangriyu.wang/images/blog/http/hit%20cache.png" alt="image"></p><p><img src="https://src.wangriyu.wang/images/blog/http/no%20cache.png" alt="image"></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>-【Last-Modified、If-Modified-Since】: If-Modified-Since 就是上次请求返回的 Last-Modified，服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果有变化就正常返回资源内容。如果没有变化，就返回 304 Not Modified，不返回资源内容，不更新 Last-Modified。</p><p>-【ETag、If-None-Match】: 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag（服务器根据当前请求的资源生成的一个唯一标识），这个唯一标识是一个字符串，只要资源有变化这个串就不同，服务器再次收到资源请求时，根据资源生成一个新的 ETag 和浏览器传过来 If-None-Match 比较，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化，返回 304 和 ETag 不返回资源；如果有变化，返回资源。ETag 优先级比 Last-Modified 高</p><blockquote><p>⚠️</p><ul><li>在分布式部署的时候，多台机器的 Last-Modified 必须保持一致，否则协商缓存会出问题。</li><li>分布式部署，不同的机器生成的 ETag 都会不一样， 然后协商缓存就会出问题。【如果没有搞定 ETag 一致，就先关闭掉】</li><li>协商缓存需要配合强缓存使用 【不启动强缓存，协商缓存也就不起作用】</li></ul></blockquote><p><img src="https://src.wangriyu.wang/images/blog/http/NegotiateCache.png" alt="image"></p><blockquote><p>另外浏览器的刷新 (F5 / cmd + r) 和强刷 (Ctrl + F5 / shift + cmd +r / option + cmd + r(safari)):<br>普通刷新会使用协商缓存，忽略强缓存；强刷会忽略浏览器所有缓存（并且请求头会携带 Cache-Control:no-cache 和 Pragma:no-cache，用来通知所有中间节点忽略缓存）。<br>只有从地址栏或收藏夹输入网址、点击链接等情况下，浏览器才会使用强缓存。</p></blockquote><h4 id="强校验和弱校验"><a href="#强校验和弱校验" class="headerlink" title="强校验和弱校验"></a>强校验和弱校验</h4><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP_ETag" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP_ETag</a></p><p>ETag 强校验表明资源的两个版本每个字节都是相同，并且请求头（如 Content-Language）也不能有改变。强校验允许缓存，以及字节请求部分响应合并。</p><p>ETag 弱校验表明资源的两个版本只需要语义上保持一致，忽略细微差别比如修改时间等，这意味着，他们是可以互换的，并且缓存的副本也可以被使用。因为不需要资源版本保持字节程度的相同，所以这种 ETag 不适合字节请求。如果 web 服务器要动态的生成响应，这时弱校验 ETag 比较合适。</p><p>比如使用弱验证类型，一个页面与另外一个页面只是在页脚显示的时间上有所不同，或者是展示的广告不相同，那么就会被认为是相同的。但是在使用强验证的情况下，二者是不同的。</p><p>Last-Modified 存在的问题，也是使用 Etag 的原因:</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变 (仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET</li><li>有些文档可能被修改了，但所做的修改并不重要，不需要让所有缓存都重装数据 (比如对拼写和注释的修改)</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改 (比如实时监控器)，If-Modified-Since 能检查到的粒度是秒级的，对于小于秒级的修改无法判断 (或者说 UNIX 记录 MTIME 只能精确到秒)</li><li>某些服务器不能精确的得到文件的最后修改时间；</li></ul><p>例子:</p><ul><li>强校验</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 05 May 2018 11:28:26 GMT</span><br><span class="line">ETag: &quot;aaa&quot;</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Content-Length: 5</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>若添加了内容编码 <code>Content-Encoding: gzip</code> 后，ETag 便会改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 05 May 2018 11:28:26 GMT</span><br><span class="line">ETag: &quot;bbb&quot;</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Content-Length: 5</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><ul><li>弱检验</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 05 May 2018 11:28:26 GMT</span><br><span class="line">ETag: W/&quot;ccc&quot;</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Content-Type: text/css</span><br><span class="line"></span><br><span class="line">.absolute-center &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 CSS 样式做了 minify，ETag 并不会改变，因为内容并没有发生实际变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 05 May 2018 11:28:26 GMT</span><br><span class="line">ETag: W/&quot;ccc&quot;</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Content-Type: text/css</span><br><span class="line"></span><br><span class="line">.absolute-center&#123;position:absolute;left:50%;top:50%;transform:translate(-50%, -50%)&#125;</span><br></pre></td></tr></table></figure><p>此时客户端发起 <code>If-None-Match</code> 请求，服务端还是会响应 304 Not Modified，客户端继续读取之前未 minify 的缓存</p><h4 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h4><ul><li>Age: 告知客户端，源服务器在多久前创建了响应。若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应已过时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Age:2383321</span><br><span class="line">Date:Wed, 08 Mar 2017 16:12:42 GMT</span><br></pre></td></tr></table></figure></li></ul><p>代理服务器在 2017 年 3 月 8 日 16:12:42 时向源服务器发起了对该资源的请求, 目前已缓存了该资源 2383321 秒</p><ul><li>Vary: 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，必须要从源服务器重新获取资源。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary:Accept-Encoding,User-Agent</span><br></pre></td></tr></table></figure></li></ul><p>代理服务器将针对是否压缩和浏览器类型去缓存资源. 对于同一个 url, 就能针对 PC 和 Mobile 返回不同的缓存内容</p><ul><li>Pragma: <code>Pragma: no-cache</code> 是 http/1.1 之前的遗留版本，作用与 <code>Cache-Control: no-cache</code> 一样</li></ul><h3 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h3><p>CDN 的全称是 Content Delivery Network，即内容分发网络。将网站的内容发布到最接近用户的网络 “ 边缘 “ 的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度</p><p>CDN 缓存，也叫网关缓存、反向代理缓存。浏览器先向 CDN 网关发起 WEB 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上<br>当客户端向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向源站发出回源请求（back to the source request），从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><p>CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。</p><p>CDN 缓存时间会对“回源率”产生直接的影响。若 CDN 缓存时间较短，CDN 边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若 CDN 缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p><p>优点:</p><ul><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li><li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。</li></ul><h2 id="chunked-response"><a href="#chunked-response" class="headerlink" title="chunked response"></a>chunked response</h2><p>HTTP 1.1 默认使用的是持久连接 (Persistent Connection)，当服务器返回一个响应时连接不会关闭，如果未申明 <code>Connection: close</code> 关闭长连接，客户端会一直处于 pending 状态。</p><p>要让客户端知道这个响应到哪里结束主要有两种方式:</p><ol><li><p>在响应头上加上 <code>Content-Length</code> 显示申明实体 body 的长度，此时客户端便知道读到哪里结束，但是如果 <code>Content-Length</code> 长度短于实体长度，则内容会被截取；如果超过实体长度，客户端还是会 pending 等待后续缺省的数据。</p></li><li><p>HTTP 1.1 协议在 header 中引入 <code>Transfer-Encoding</code>，当其值为 <code>chunked</code> 时, 表明采用分块编码方式来进行报文体的传输。基本方法是将大块数据分解成多块小数据，每块都可以自定长度。</p></li></ol><p><strong>分块传输的优点:</strong></p><ul><li>HTTP 分块传输编码允许服务器为动态生成的内容以维持 HTTP 持久链接</li><li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过 HTTP 消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</li><li>HTTP 服务器有时使用压缩 （gzip 或 deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</li></ul><p><strong>格式:</strong></p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个 CRLF，然后是数据本身，最后 CRLF 结束。</p><p>最后一块是单行，由块大小（0），一些可选的填充空格，以及 CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。</p><p>消息最后以 CRLF 结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Chunked-Body   = *chunk</span><br><span class="line">                 last-chunk</span><br><span class="line">                 trailer</span><br><span class="line">                 CRLF</span><br><span class="line"></span><br><span class="line">chunk          = chunk-size [ chunk-extension ] CRLF</span><br><span class="line">                 chunk-data CRLF</span><br><span class="line"></span><br><span class="line">chunk-size     = 1*HEX</span><br><span class="line"></span><br><span class="line">last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF</span><br><span class="line"></span><br><span class="line">chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )</span><br><span class="line">chunk-ext-name = token</span><br><span class="line">chunk-ext-val  = token | quoted-string</span><br><span class="line">chunk-data     = chunk-size(OCTET)</span><br><span class="line"></span><br><span class="line">trailer        = *(entity-header CRLF)</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line"></span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line"></span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is the data in the first chunk\r\n&quot;      (37 字符 =&gt; 十六进制: 0x25)</span><br><span class="line">&quot;and this is the second one\r\n&quot;               (28 字符 =&gt; 十六进制: 0x1C)</span><br><span class="line">&quot;con&quot;                                          (3  字符 =&gt; 十六进制: 0x03)</span><br><span class="line">&quot;sequence&quot;                                     (8  字符 =&gt; 十六进制: 0x08)</span><br></pre></td></tr></table></figure><p>最后以 “0\r\n\r\n” 结束</p><p>解码数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is the data in the first chunk</span><br><span class="line">and this is the second one</span><br><span class="line">consequence</span><br></pre></td></tr></table></figure><p>实际抓包数据:</p><p><img src="https://src.wangriyu.wang/images/blog/http/chunked.png" alt="image"></p><p>首部字段 <code>Trailer</code> 会事先说明在报文主体后记录了哪些首部字段，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 03 Jul 2012 04:40:56 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">...</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Trailer: Expires</span><br><span class="line"></span><br><span class="line">...(报文主体)...</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Expires: Tue, 28 Sep 2004 23:59:59 GMT</span><br></pre></td></tr></table></figure><p>请求首部字段 <code>TE</code> 告知服务器 客户端能够处理响应的传输编码方式及相对优先级</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html" target="_blank" rel="noopener">RFC2616</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener">wikipedia uri</a></li><li>《图解 HTTP》</li><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">Chunked transfer encoding - 分块传输编码 wiki</a></li><li><a href="https://tools.ietf.org/html/rfc2616#section-3.6.1" target="_blank" rel="noopener">RFC 2616 - Chunked Transfer Coding</a></li><li><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">缓存机制</a></li><li><a href="https://notfalse.net/56/http-stale-response" target="_blank" rel="noopener">http cache</a></li><li><a href="http://imweb.io/topic/55c6f9bac222e3af6ce235b9" target="_blank" rel="noopener">缓存策略</a></li></ul>]]></content>
    
    <summary type="html">
    
      了解 request 和 response 的报文结构，以及常见首部的作用和浏览器的缓存机制
    
    </summary>
    
      <category term="http" scheme="https://blog.wangriyu.wang/categories/http/"/>
    
    
      <category term="http 扩展阅读" scheme="https://blog.wangriyu.wang/tags/http-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>更换博客评论系统</title>
    <link href="https://blog.wangriyu.wang/2018/03-valine.html"/>
    <id>https://blog.wangriyu.wang/2018/03-valine.html</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:52.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前使用 Disqus，必须翻墙才能显示，而且 Disqus 会产生大量请求，一直想换个评论系统但是好用的好像都倒了 <em>(:зゝ∠)</em></p><p>最近无意间看到这个 Valine 评论系统，好像很好用，而且简单简洁，试了一下感觉还行，可惜少了嵌套评论。</p><h2 id="Yelee-添加方法"><a href="#Yelee-添加方法" class="headerlink" title="Yelee 添加方法"></a>Yelee 添加方法</h2><p><a href="https://valine.js.org" target="_blank" rel="noopener">Valine 配置官网</a></p><p>使用前还需要注册一个 <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> 账户，然后创建一个应用来存储管理评论内容。</p><ol><li>然后修改 Yelee 主题配置文件 <code>_config.yml</code><br>添加：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  appid: *** # LeanCloud 应用 AppID</span><br><span class="line">  appkey: *** # LeanCloud 应用 AppKey</span><br><span class="line">  verify: false # 验证码</span><br><span class="line">  notify: false # 评论回复邮箱提醒</span><br><span class="line">  avatar: identicon # 评论列表头像样式：&apos;&apos;/mm/identicon/monsterid/wavatar/retro/hide</span><br><span class="line">  placeholder: Just do it ! # 评论框占位符</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 <code>yelee/layout/_partial/article.ejs</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">    &lt;% if (theme.duoshuo.on) &#123; %&gt;</span><br><span class="line">      &lt;%- partial(&apos;comments/duoshuo&apos;, &#123;</span><br><span class="line">          key: post.path,</span><br><span class="line">          title: post.title,</span><br><span class="line">          url: config.url+url_for(post.path),</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">    &lt;% &#125; else if (theme.youyan.on) &#123; %&gt;</span><br><span class="line">        &lt;%- partial(&apos;comments/youyan&apos;) %&gt;</span><br><span class="line">    &lt;% &#125; else if (theme.disqus.on) &#123; %&gt;</span><br><span class="line">        &lt;%- partial(&apos;comments/disqus&apos;, &#123;</span><br><span class="line">            shortname: theme.disqus.shortname</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">    &lt;% &#125; else if (config.disqus_shortname) &#123; %&gt;</span><br><span class="line">        &lt;%- partial(&apos;comments/disqus&apos;, &#123;</span><br><span class="line">            shortname: config.disqus_shortname</span><br><span class="line">          &#125;) %&gt;</span><br><span class="line">+   &lt;% &#125; else if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">+       &lt;%- partial(&apos;comments/valine&apos;, &#123;</span><br><span class="line">+           key: post.slug,</span><br><span class="line">+           title: post.title,</span><br><span class="line">+           url: config.url+url_for(post.path)</span><br><span class="line">+       &#125;) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建 <code>layout/_partial/comments/valine.ejs</code> 文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;section id=&quot;comments&quot; style=&quot;margin: 2em; padding: 2em; background: rgba(255, 255, 255, 0.5)&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var notify = &apos;&lt;%= theme.valine.notify %&gt;&apos; == true ? true : false;</span><br><span class="line">      var verify = &apos;&lt;%= theme.valine.verify %&gt;&apos; == true ? true : false;</span><br><span class="line">      new Valine(&#123;</span><br><span class="line">        el: &apos;#vcomment&apos;,</span><br><span class="line">        notify: notify,</span><br><span class="line">        verify: verify,</span><br><span class="line">        app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;,</span><br><span class="line">        app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;,</span><br><span class="line">        placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;,</span><br><span class="line">        avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 <code>yelee/source/css/_partial/mobile.styl</code> 中添加</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#comments &#123;</span><br><span class="line">    margin: (10/16)rem 10px !important;</span><br><span class="line">    padding: 1rem !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      将原来的 Disqus 更换为 Valine
    
    </summary>
    
      <category term="Web" scheme="https://blog.wangriyu.wang/categories/Web/"/>
    
    
      <category term="Yelee" scheme="https://blog.wangriyu.wang/tags/Yelee/"/>
    
  </entry>
  
  <entry>
    <title>GithubPages 绑定二级域名并开启 HTTPS</title>
    <link href="https://blog.wangriyu.wang/2018/01-githubpage.html"/>
    <id>https://blog.wangriyu.wang/2018/01-githubpage.html</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-创建-github-仓库"><a href="#1-创建-github-仓库" class="headerlink" title="1. 创建 github 仓库"></a>1. 创建 github 仓库</h2><p>通常使用 GithubPages 创建个人主页需要创建一个与用户名同名的 <code>XXX.github.io</code> 仓库</p><p>以我的博客为例，创建一个新仓库 <code>wangriyu.github.io</code>，上传网页文件，然后在仓库设置里开启 GitHub Pages 功能</p><p>此时应该能够在浏览器中输入 <a href="https://wangriyu.github.io" target="_blank" rel="noopener">https://wangriyu.github.io</a> 访问自己的网页了</p><p>而且 GithubPages 默认开启 HTTPS</p><h2 id="2-绑定自定义域名"><a href="#2-绑定自定义域名" class="headerlink" title="2. 绑定自定义域名"></a>2. 绑定自定义域名</h2><p>到 <a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">万网</a> 上买个喜欢的域名，比如我买了 <code>wangriyu.wang</code>(可惜买不到 <code>riyu.wang</code>)</p><p>到上面的仓库目录下添加 <code>CNAME</code> 文件，里面的内容就是我的域名，比如我的就写了二级域名 <code>blog.wangriyu.wang</code></p><p>此时 Github Pages 看起来是这样的</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/githubpages.png" alt="image"></p><p><code>Enforce HTTPS</code> 选项显示 <code>Unavailable for your site because you have a custom domain configured</code></p><p>自定义域名不提供 HTTPS 服务</p><p>此时还无法访问 <a href="http://blog.wangriyu.wang">http://blog.wangriyu.wang</a>, 需要到 DNS 服务商那配置 DNS 解析，比如阿里云的即可</p><h2 id="3-配置-DNS-解析"><a href="#3-配置-DNS-解析" class="headerlink" title="3. 配置 DNS 解析"></a>3. 配置 DNS 解析</h2><p>打开 <a href="https://home.console.aliyun.com/new#/" target="_blank" rel="noopener">阿里云的域名控制台</a>，点击自己域名的解析按钮进入 DNS 设置页，添加解析:</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/DNS.png" alt="image"></p><ul><li>记录类型中 A 类填的是 IP 地址，CNAME 类填的是域名，我们需要把 wangriyu.github.io 转向 blog.wangriyu.wang, 所以填 CNAME</li><li>主机记录填二级域名即可，‘@’ 值代表一级域名，更多选项见阿里云说明</li><li>解析路线填默认即可，如果分国内国外需要另外选择使其能够根据国内外 IP 解析到不同地址</li><li>记录值就是我们的原域名 wangriyu.github.io，如果记录类型是 A 类这里需要填 IP 地址 (可以 PING 一下得到)</li></ul><p>等待 DNS 生效即可通过 <a href="http://blog.wangriyu.wang">http://blog.wangriyu.wang</a> 访问自己的网页了，而且原本的 <a href="https://wangriyu.github.io" target="_blank" rel="noopener">https://wangriyu.github.io</a><br>也会重定向到自定义域名上</p><p>DNS 解析这里我用了二级域名 blog 访问博客，还可以添加别的二级域名，比如我用了 home 访问我的另一个仓库 <a href="https://github.com/wangriyu/homepage" target="_blank" rel="noopener">https://github.com/wangriyu/homepage</a></p><p>只要在新的仓库根目录下添加 <code>CNAME</code> 文件并写入添加的有效二级域名 (home.wangriyu.wang), 再开启 GithubPages 功能即可访问另一个主页</p><h2 id="4-实现自定义域名-HTTPS"><a href="#4-实现自定义域名-HTTPS" class="headerlink" title="4. 实现自定义域名 HTTPS"></a>4. 实现自定义域名 HTTPS</h2><h3 id="到-CloudFlare-注册一个账号，注册成功后在返回的页面中添加域名-一级域名-wangriyu-wang-，点击扫描-DNS-记录"><a href="#到-CloudFlare-注册一个账号，注册成功后在返回的页面中添加域名-一级域名-wangriyu-wang-，点击扫描-DNS-记录" class="headerlink" title="到 CloudFlare 注册一个账号，注册成功后在返回的页面中添加域名 (一级域名 wangriyu.wang)，点击扫描 DNS 记录"></a>到 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">CloudFlare</a> 注册一个账号，注册成功后在返回的页面中添加域名 (一级域名 wangriyu.wang)，点击扫描 DNS 记录</h3><p><img src="https://zhouhao.me/img/https_20170721_3.png" alt="image"></p><h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>如果 DNS 扫描不到你的解析记录，可以手动添加，与上面的添加方法类似</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/cloundflare.png" alt="image"></p><h3 id="修改域名服务器"><a href="#修改域名服务器" class="headerlink" title="修改域名服务器"></a>修改域名服务器</h3><p>我用的是万网的 DNS，所以现在要在万网的域名控制台将 DNS 服务器修改至 CloudFlare 提供的域名服务器</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/nameserver.png" alt="image"></p><p>进入万网的域名控制台，点击域名的管理按钮，修改域名 DNS 为 CloudFlare 提供的</p><p><img src="https://zhouhao.me/img/https_20170721_6.png" alt="image"></p><h3 id="回到-CloudFlare-页面，设置-SSL-为-Flexible"><a href="#回到-CloudFlare-页面，设置-SSL-为-Flexible" class="headerlink" title="回到 CloudFlare 页面，设置 SSL 为 Flexible"></a>回到 CloudFlare 页面，设置 SSL 为 Flexible</h3><p><img src="https://zhouhao.me/img/https_20170721_7.png" alt="image"></p><h3 id="添加路由重定向规则"><a href="#添加路由重定向规则" class="headerlink" title="添加路由重定向规则"></a>添加路由重定向规则</h3><p>在 <code>Page Rules</code> 里使用通配符将路由重定向到 HTTPS 的链接</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/pagerules.png" alt="image"></p><p>待设置生效后再访问 <a href="http://blog.wangriyu.wang">http://blog.wangriyu.wang</a> 就会变成 https 了</p><p>具体原理如图，cloundflare 访问原网址的服务器获取储存原网页文件，用户再访问 cloundflare 的加密连接<br>如果在控制台中 Ping 一下 CloudFlare 代理前后的网址就会发现博客 ip 变了</p><p><img src="https://src.wangriyu.wang/images/blog/githubpages/FlexibleSSL.png" alt="image"></p><p>除此之外，在 CloudFlare 控制台中还提供了很多服务，比如 js、html 等静态文件压缩，设置浏览器缓存过期时间，<br>清空 CloudFlare 服务器缓存 (强制刷新资源，避免原网页更新用户访问的还是旧资源) 等等</p><p>更多技巧见文章: <a href="https://wzfou.com/cloudflare/" target="_blank" rel="noopener">十个你可能不知道的 CloudFlare 免费 CDN 加速技巧 -SSL\DDOS\Cache</a></p><p>cloundflare 的服务很适合博客这样的静态网页，也弥补了 GithubPages 的不足</p>]]></content>
    
    <summary type="html">
    
       本文介绍如何将多个 github 项目绑定到自定义域名下，并借助 cloudflare 的服务实现自定义域名开启 https
    
    </summary>
    
      <category term="Web" scheme="https://blog.wangriyu.wang/categories/Web/"/>
    
    
      <category term="Yelee" scheme="https://blog.wangriyu.wang/tags/Yelee/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 V</title>
    <link href="https://blog.wangriyu.wang/2017/12-Dart%20V.html"/>
    <id>https://blog.wangriyu.wang/2017/12-Dart V.html</id>
    <published>2017-12-28T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分离-Isolates"><a href="#分离-Isolates" class="headerlink" title="分离 Isolates"></a>分离 Isolates</h2><p>现在的网页浏览器，甚至是移动平台上的，运行在多核 CPU 之上。为了充分利用多核心的优势，开发人员通常对共享内存的线程采取并行策略。然而，在共享状态下使用并发容易出错并且会使代码复杂化。<br>Dart 在代码中使用 isolates 来替代线程。每个 isolate 有自己的内存堆，以确保 isolate 的状态不能被其他任何 isolate 访问。</p><hr><h2 id="类型定义-Typedefs"><a href="#类型定义-Typedefs" class="headerlink" title="类型定义 Typedefs"></a>类型定义 Typedefs</h2><p>在 Dart 中，方法是对象，就像字符串和数字也是对象。typedef , 又被称作函数类型别名，让你可以为函数类型命名，并且该命名可以在声明字段和返回类型的时候使用。当一种函数类型被分配给一个变量的时候，typedef 会记录原本的类型信息。<br>考虑下面的代码，哪一个没有使用 typedef：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initial, broken implementation.</span></span><br><span class="line"> <span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  SortedCollection coll = <span class="keyword">new</span> SortedCollection(sort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// All we know is that compare is a function,</span></span><br><span class="line">  <span class="comment">// but what type of function?</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 f 分配到 compare 的时候类型信息丢失了。f 的类型是 (Object, Object) → int(→ 意味着返回的)，然而 compare 的类型是方法。如果我们使用显式的名字更改代码并保留类型信息，则开发者和工具都可以使用这些信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initial, broken implementation.</span></span><br><span class="line"> <span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  SortedCollection coll = <span class="keyword">new</span> SortedCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>目前 typedefs 仅限于函数类型，以后可能会有所改变。</p></blockquote><p>typedefs 是简单的别名，所以它提供了一种方法来检查任何函数的类型。比如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare); <span class="comment">// True</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h2><p>使用元数据来给你的代码提供附加信息。<br>元数据注解以 @ 字符开头，后面跟一个编译时的常量引用（例如 deprecated）或者调用常量构造器的语句。<br>所有的 Dart 代码中支持三个注解：@deprecated，@override 和 @proxy。@override 和 @proxy 的用法示例，请查看 <a href="https://www.dartlang.org/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">类的继承</a>。以下是 @deprecated 用法的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Deprecated: Use [turnOn] instead</span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Turns the TV's power on.</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'on!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以定义你自己的元数据注解。下面的例子定义了一个有两个参数的 @todo 注解：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用 @todo 注解的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'todo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@todo</span>(<span class="string">'seth'</span>, <span class="string">'make this do something'</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'do something'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元数据可以出现在库、类、typedef、类型参数、构造器、工厂、函数、属性、参数、变量声明、import 或 export 指令之前。你可以在运行时通过反射来取回元数据。</p><hr><h2 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释 Comments"></a>注释 Comments</h2><p>Dart 支持单行注释、多行注释和文档注释。</p><ul><li><p>单行注释由 // 开始</p></li><li><p>多行注释由 /<em> 开始，由 </em>/ 结束，多行注释可以嵌套</p></li><li><p>文档注释是由 /// 或 /** 开始的多行或单行注释<br>在连续的行上使用 /// 的效果等同于多行注释。<br>在一段文档注释中，Dart 编译器忽略所有除括号内的文本。你可以使用括号来引用类、方法、属性、顶级变量、函数和参数。括号中的名字会在被文档化程序元素的词法范围内解析。<br>下面是一个引用了其它类和参数的文档注释的例子：</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A domesticated South American camelid (Lama glama).</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Andean cultures have used llamas as meat and pack</span></span><br><span class="line"><span class="comment">/// animals since pre-Hispanic times.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Llama</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Feeds your llama [Food].</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// The typical llama eats one bale of hay per week.</span></span><br><span class="line">  <span class="keyword">void</span> feed(Food food) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Exercises your llama with an [activity] for</span></span><br><span class="line">  <span class="comment">/// [timeLimit] minutes.</span></span><br><span class="line">  <span class="keyword">void</span> exercise(Activity activity, <span class="built_in">int</span> timeLimit) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成的文档中， [food] 变成了指向 Food 类的 API 文档连接。</p><hr><p><strong>更多内容</strong></p><ul><li><a href="https://www.dartlang.org/articles" target="_blank" rel="noopener">文章</a></li><li><a href="https://www.dartlang.org/dart-vm/dart-by-example" target="_blank" rel="noopener">代码用法示例</a></li><li><a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart 核心库</a></li><li><a href="https://www.dartlang.org/guides/language/effective-dart" target="_blank" rel="noopener">Effective Dart</a></li><li><a href="https://www.dartlang.org/tutorials/language/futures" target="_blank" rel="noopener">Futures 教程</a></li><li><a href="https://www.dartlang.org/docs/tutorials/streams" target="_blank" rel="noopener">Streams 教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>极具性价比的 Mac 存储扩展方案</title>
    <link href="https://blog.wangriyu.wang/2017/12-MacStorageExpansion.html"/>
    <id>https://blog.wangriyu.wang/2017/12-MacStorageExpansion.html</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见-Mac-扩容方案"><a href="#常见-Mac-扩容方案" class="headerlink" title="常见 Mac 扩容方案"></a>常见 Mac 扩容方案</h2><ul><li>直接更换大容量 SSD：效果最好，速度最快，成本最高，需要专业人士操刀</li><li>外接移动硬盘：容量大速度也挺快，还算便捷但是不方便，而且占用一个 usb</li><li>外接小尺寸 U 盘：像三星这个 <a href="https://item.jd.com/2154209.html" target="_blank" rel="noopener">https://item.jd.com/2154209.html</a> ，占用空间小，速度也还行，但会占用一个 usb</li><li>利用 SD 卡槽扩展：比如创见的 <a href="https://item.jd.com/1212838.html" target="_blank" rel="noopener">JetDrive Lite</a> 扩展卡，专为 Mac 设计，速度也还可以，但是性价比一般</li><li>本文同样利用 SD 卡槽扩展但性价比远超 JetDrive Lite</li></ul><h2 id="准备物品"><a href="#准备物品" class="headerlink" title="准备物品"></a>准备物品</h2><ul><li>三星 Evo Plus UHS 高速 MicroSD 卡 - 128G，某东上活动价 249，速度和稳定性比较好，选择其他类似的 tf 卡也可以</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/SamsungEvoPlus.png" width="50%"></p><ul><li>适配 Mac SD 卡槽的卡套，某宝上几块钱一个，这东西只是转接作用，不影响速度，主要是长度问题，普通卡套插上 Mac 会突出一部分影响体验，而且需要注意不同 Mac 版本 SD 卡槽深度不一，买前请留意</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_214833.jpg" width="50%"><br><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_214954.jpg" width="50%"></p><ul><li>四合一读卡器，这个可有可无，我只是推荐一下，配合这个读卡器可以在需要转储文件时很方便的连接安卓、苹果、电脑等</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_214714.jpg" width="50%"></p><h2 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h2><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171231_210739.jpg" width="50%"></p><p>全套工具<br><img src="https://src.wangriyu.wang/images/blog/MacStorage/IMG_20171224_224139.jpg" width="50%"></p><p>速度测试，读写基本稳定几十 M 每秒，普通使用足矣<br><img src="https://src.wangriyu.wang/images/blog/MacStorage/SpeedTest.png" width="50%"></p><h2 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h2><ul><li>SD 卡在速度上可靠性上不如前面那些方案，适合存储一些图片视频音乐的文件，但像系统或者比较细碎的文件经常反复读写的文件不建议存 SD 卡里</li><li>SD 卡的常见格式有 exFat、Fat32、NTFS，像我这样会在多设备间转储的，包括 Mac、Windows、Android、ios 等，SD 卡格式最好的选择是 exFat，基本都支持此格式而且支持 4g 以上的单文件，而 Fat32 兼容性最好但不支持 4g 以上的单文件</li><li>exFat 格式的 SD 卡在部分安卓设备上无法识别，我的手机就识别不了，以下方法 (没有 root 的情况) 可以通过第三方软件实现读取<br>详细步骤见视频：<br><a href="https://www.youtube.com/watch?v=Daaydbsc5_c" target="_blank" rel="noopener">How to Mount NTFS/EXFat in your Android device without root</a><br>相关软件：<ul><li>Total Commender <a href="https://play.google.com/store/apps/details?id=com.ghisler.android.TotalCommander&amp;hl=en" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.ghisler.android.TotalCommander&amp;hl=en</a></li><li>USB-Stick Plugin <a href="https://play.google.com/store/apps/details?id=de.hechler.tcplugins.usbstick&amp;hl=en" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=de.hechler.tcplugins.usbstick&amp;hl=en</a></li><li>exFat/NTFS for USB <a href="https://play.google.com/store/apps/details?id=com.paragon.tcplugins_ntfs_ro&amp;hl=en" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.paragon.tcplugins_ntfs_ro&amp;hl=en</a></li></ul></li><li>最好在 Finder 中添加一个外接 SD 设备的替身，避免点击到弹出按钮</li></ul><p><img src="https://src.wangriyu.wang/images/blog/MacStorage/finder.gif" width="50%"></p>]]></content>
    
    <summary type="html">
    
      本文通过 Mac 的 SD 卡槽扩展存储空间，方便美观而且花销相对其他方式会小很多
    
    </summary>
    
      <category term="Mac" scheme="https://blog.wangriyu.wang/categories/Mac/"/>
    
    
      <category term="Mac 存储扩展" scheme="https://blog.wangriyu.wang/tags/Mac-%E5%AD%98%E5%82%A8%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>UEFI + GPT + Win10 + Ubuntu + rEFInd</title>
    <link href="https://blog.wangriyu.wang/2017/12-Win+Ubuntu.html"/>
    <id>https://blog.wangriyu.wang/2017/12-Win+Ubuntu.html</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚好赶上 win10 更新 1709 和 Ubuntu 更新 17.10，心血来潮给我的 Windows 笔记本重装一下系统并加上 Ubuntu，这里记录一下过程，以留备用。我的配置是 256G SSD+1T HHD，两个系统都装在固态盘，如果需要把 Ubuntu 装在机械硬盘里，可能还需要额外做一下引导：<a href="https://www.zhihu.com/question/33461827" target="_blank" rel="noopener">https://www.zhihu.com/question/33461827</a></p><hr><h2 id="安装-win10"><a href="#安装-win10" class="headerlink" title="安装 win10"></a>安装 win10</h2><h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><ul><li>4G 以上 U 盘</li><li>win10 镜像: <a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a> MSDN-&gt; 操作系统 -&gt;Windows10,Version1709</li><li>启动盘制作工具 Rufus:<a href="http://rufus.akeo.ie/?locale=zh_CN" target="_blank" rel="noopener">http://rufus.akeo.ie/?locale=zh_CN</a></li></ul><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><ol><li>打开 rufus，选择 U 盘</li><li><code>分区方案和目标系统类型</code> 选择 <code>用于 UEFI 计算机的 GPT 分区方案</code></li><li>文件系统默认 fat32(这个不能改，uefi 只识别这个格式)</li><li>下面的 <code>创建一个启动盘使用</code> 默认选中的即是 <code>ISO 镜像</code>，然后点击右侧的磁盘图标在电脑中找到下载好的 Win10 正式版 ISO 镜像</li><li>最后点击 “开始” 按钮即可开始制作支持 UEFI 启动的 Win10 系统安装 U 盘</li></ol><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><ol><li>插上 U 盘重启电脑，进入 BIOS 选择开机启动项为自己做好的的 <code>uefi U 盘</code>，保存重启</li><li>能进入 win10 安装界面则成功了一半，如果进不去需要检查一下之前 U 盘是否写入成功，还有 bios 的 uefi 是否打开</li><li>进入 win10 安装界面，选择安装，提示输入密钥，可以先跳过</li><li>接受许可条款后，提示选择 <code>安装类型</code>，点击自定义安装进入分区界面</li></ol><p><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/partition.png" alt="iamge"></p><p>这里网上找的图，实际情况按自身需求处理，我的是驱动器 0 代表固态，1 代表机械，然后我把固态的分区全删除，在未分配的空间上新建分区，给 win10 系统盘 C 盘分配 80GB(uefi 会在系统盘的基础上自动多创建几个分区用于 uefi 引导)，再划分 100GB 做 D 盘，留 50GB 未分配的空间 (之后安装 Ubuntu)，分完区 <code>注意选中你要安装系统的盘即第一个分的 C 盘</code>，再点下一步进入正式安装</p><p>⚠️如果这里点新建，如果新建不了可能是硬盘格式不对，mbr 格式的磁盘需要先全部删除才能转成 GPT 格式，然后再新建</p><ol start="5"><li>安装完正常会自动进入系统，如果没有进去，可能得进 BIOS 把开机启动项改回系统，并退出 U 盘</li><li>进入系统，刚开始没有桌面图标可以到主题设置里找，我的电脑没有硬盘可以右键 <code>系统菜单</code> 或者 <code>我的电脑</code> 选择并进入磁盘管理给分区分配盘符，联网后系统更新会自动下载安装电脑驱动，分享一些我常年收藏的工具：<a href="https://mega.nz/#F!AOwwyaZY!iR2HEt15jl2chNbEfs6_Nw" target="_blank" rel="noopener">https://mega.nz/#F!AOwwyaZY!iR2HEt15jl2chNbEfs6_Nw</a></li></ol><hr><h2 id="安装-Ubuntu"><a href="#安装-Ubuntu" class="headerlink" title="安装 Ubuntu"></a>安装 Ubuntu</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>2G 以上的 U 盘</li><li>Ubuntu 镜像：<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">https://www.ubuntu.com/download/desktop</a></li><li>启动盘制作工具 Rufus</li><li>同样打开 Rufus，步骤同上，制作好启动盘</li></ul><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><ol><li>还是插上 U 盘改启动项进入 Ubuntu 安装界面，一样的套路</li><li>刚开始会选择 <code>try Ubuntu</code> 或者 <code>install Ubuntu</code>，那个都可以，try 就是先尝试一下然后再安装</li><li>正式进入安装程序后，出现 <code>为图形或无线硬件安装第三方软件</code> 不勾选，直接继续，避免安装过程下载东西</li><li>出现 <code>已安装 Windows10，准备如何安装 Ubuntu</code>，选择 <code>其他选项</code></li><li>出现选择分区时，选中之前留下来的 50GB 未分配的空闲空间，千万别选错了。选中后点 + 号新建分区，分区可以按下图示例 (盗的图) 进行分，/ 是 linux 根目录的空间大小、交换空间 swap 是虚拟内存大小 (按个人需求调整大小)、/boot 是启动引导的分区 (一般 200MB 足够)、/home 是给 home 目录分配独立分区并分配一定大小，也可以不分把所有空间放到根目录下<br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/2.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/3.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/4.png" alt="image"><br>⚠️分好区后 <code>安装启动引导器的设备</code> 时要选中 / boot 分区所在的设备</li><li>点安装下一步确认改动，等待安装完成</li><li>安装完退出 U 盘重启，可以选择启动项，点 Ubuntu 进 linux，点 Windows boot manager 进 win10，但这个 grub 引导界面太丑，下面会使用 rEFInd 引导</li><li>进入 Ubuntu 后一些基础设置可以参考这篇文章：<a href="http://www.jianshu.com/p/62d947731401" target="_blank" rel="noopener">http://www.jianshu.com/p/62d947731401</a></li></ol><hr><h2 id="rEFInd-引导"><a href="#rEFInd-引导" class="headerlink" title="rEFInd 引导"></a><a href="http://www.rodsbooks.com/refind/" title=" 点击访问官网 " target="_blank" rel="noopener">rEFInd</a> 引导</h2><h3 id="安装-rEFInd"><a href="#安装-rEFInd" class="headerlink" title="安装 rEFInd"></a>安装 rEFInd</h3><p>这是官网的安装简介：<br><strong>Ubuntu—Two Ubuntu-specific methods of installing rEFInd in this distribution exist:</strong></p><ul><li>Ubuntu 17.04 (“Zesty Zapus”) includes rEFInd 0.10.4. Note that, like the Debian package, this one is not signed for use with Secure Boot, but if your system includes the sbsigntool package, the installer will generate a local key for this purpose. If you want a more recent version, you can use my PPA or install my Debian package.</li><li>I’ve created a rEFInd PPA for Ubuntu. To use it, open a Terminal window and type the following commands:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-add-repository ppa:rodsmith/refind</span><br><span class="line"><span class="meta">$</span> sudo apt-get update</span><br><span class="line"><span class="meta">$</span> sudo apt-get install refind</span><br></pre></td></tr></table></figure></li></ul><p>You’ll be asked whether to install rEFInd to the ESP when you first install it. Thereafter, the rEFInd version will update along with your other software. This package is built with GNU-EFI and is not signed with a Secure Boot key; however, the install script should sign the binary with a locally-generated key if it detects that your system uses Secure Boot. Thus, if you’ve previously installed one of my binaries on a Secure Boot system and added its key as a MOK, you’ll have to add your local key when you reboot.</p><p>对于 Ubuntu 而言就是关掉 BIOS 里的 <code>Secure Boot</code> 选项（最好关掉），运行上述三条命令即可安装。</p><p>安装好后，文件目录默认是 <code>/boot/efi/efi/refind</code>，我的是这样，安装方式不同可能目录也不一样。之后要修改这里面的配置文件</p><h3 id="更换引导主题"><a href="#更换引导主题" class="headerlink" title="更换引导主题"></a>更换引导主题</h3><p>找到自己想要的主题：<a href="http://www.rodsbooks.com/refind/themes.html" target="_blank" rel="noopener">http://www.rodsbooks.com/refind/themes.html</a><br>比如我用的就是 <a href="https://github.com/EvanPurkhiser/rEFInd-minimal" target="_blank" rel="noopener">Minimal theme</a></p><ol><li>找到 refind 安装目录，比如 [/boot/efi/efi/refind]</li><li>如果不存在 <code>themes</code> 则创建一个 <code>themes</code> 文件夹</li><li>在 themes 目录下创建 <code>minimal</code> 文件夹，把克隆或下载下来的主题文件拷进来</li><li>修改 refind 目录下的 refind.conf 文件，修改配置。注释里有介绍，也可以找官网的介绍，或者其他例子：<a href="https://tieba.baidu.com/p/4459857693" target="_blank" rel="noopener">https://tieba.baidu.com/p/4459857693</a></li></ol><p>我的配置是这样的，可供参考：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># Minimal refind theme</span><br><span class="line"></span><br><span class="line"># Hide user interface elements for personal preference or to increase</span><br><span class="line"># security:</span><br><span class="line">#  banner      - the rEFInd title banner (built-in or loaded via &quot;banner&quot;)</span><br><span class="line">#  label       - boot option text label in the menu</span><br><span class="line">#  singleuser  - remove the submenu options to boot Mac OS X in single-user</span><br><span class="line">#                or verbose modes; affects ONLY MacOS X</span><br><span class="line">#  safemode    - remove the submenu option to boot Mac OS X in &quot;safe mode&quot;</span><br><span class="line">#  hwtest      - the submenu option to run Apple&apos;s hardware test</span><br><span class="line">#  arrows      - scroll arrows on the OS selection tag line</span><br><span class="line">#  hints       - brief command summary in the menu</span><br><span class="line">#  editor      - the options editor (+, F2, or Insert on boot options menu)</span><br><span class="line">#  all         - all of the above</span><br><span class="line"># Default is none of these (all elements active)</span><br><span class="line">#</span><br><span class="line">hideui singleuser,hints,arrows,badges</span><br><span class="line"></span><br><span class="line"># Set the name of a subdirectory in which icons are stored. Icons must</span><br><span class="line"># have the same names they have in the standard directory. The directory</span><br><span class="line"># name is specified relative to the main rEFInd binary&apos;s directory. If</span><br><span class="line"># an icon can&apos;t be found in the specified directory, an attempt is made</span><br><span class="line"># to load it from the default directory; thus, you can replace just some</span><br><span class="line"># icons in your own directory and rely on the default for others.</span><br><span class="line"># Default is &quot;icons&quot;.</span><br><span class="line">#</span><br><span class="line">icons_dir themes/minimal/icons</span><br><span class="line"></span><br><span class="line"># Use a custom title banner instead of the rEFInd icon and name. The file</span><br><span class="line"># path is relative to the directory where refind.efi is located. The color</span><br><span class="line"># in the top left corner of the image is used as the background color</span><br><span class="line"># for the menu screens. Currently uncompressed BMP images with color</span><br><span class="line"># depths of 24, 8, 4 or 1 bits are supported, as well as PNG images.</span><br><span class="line">#</span><br><span class="line">banner themes/minimal/background.png</span><br><span class="line"></span><br><span class="line"># Tells rEFInd whether to display banner images pixel-for-pixel (noscale)</span><br><span class="line"># or to scale banner images to fill the screen (fillscreen). The former is</span><br><span class="line"># the default.</span><br><span class="line">#</span><br><span class="line">banner_scale fillscreen</span><br><span class="line"></span><br><span class="line"># Custom images for the selection background. There is a big one (144 x 144)</span><br><span class="line"># for the OS icons, and a small one (64 x 64) for the function icons in the</span><br><span class="line"># second row. If only a small image is given, that one is also used for</span><br><span class="line"># the big icons by stretching it in the middle. If only a big one is given,</span><br><span class="line"># the built-in default will be used for the small icons.</span><br><span class="line">#</span><br><span class="line"># Like the banner option above, these options take a filename of an</span><br><span class="line"># uncompressed BMP image file with a color depth of 24, 8, 4, or 1 bits,</span><br><span class="line"># or a PNG image. The PNG format is required if you need transparency</span><br><span class="line"># support (to let you &quot;see through&quot; to a full-screen banner).</span><br><span class="line">#</span><br><span class="line">selection_big   themes/rEFInd-minimal/selection_big.png</span><br><span class="line">selection_small themes/rEFInd-minimal/selection_small.png</span><br><span class="line"></span><br><span class="line"># Which non-bootloader tools to show on the tools line, and in what</span><br><span class="line"># order to display them:</span><br><span class="line">#  shell           - the EFI shell (requires external program; see rEFInd</span><br><span class="line">#                    documentation for details)</span><br><span class="line">#  gptsync         - the (dangerous) gptsync.efi utility (requires external</span><br><span class="line">#                    program; see rEFInd documentation for details)</span><br><span class="line">#  apple_recovery  - boots the Apple Recovery HD partition, if present</span><br><span class="line">#  mok_tool        - makes available the Machine Owner Key (MOK) maintenance</span><br><span class="line">#                    tool, MokManager.efi, used on Secure Boot systems</span><br><span class="line">#  about           - an &quot;about this program&quot; option</span><br><span class="line">#  exit            - a tag to exit from rEFInd</span><br><span class="line">#  shutdown        - shuts down the computer (a bug causes this to reboot</span><br><span class="line">#                    EFI systems)</span><br><span class="line">#  reboot          - a tag to reboot the computer</span><br><span class="line">#  firmware        - a tag to reboot the computer into the firmware&apos;s</span><br><span class="line">#                    user interface (ignored on older computers)</span><br><span class="line"># Default is shell,apple_recovery,mok_tool,about,shutdown,reboot,firmware</span><br><span class="line">#</span><br><span class="line">showtools shutdown,reboot</span><br></pre></td></tr></table></figure><p></p><p>最终效果：<br><img src="https://src.wangriyu.wang/images/blog/win10&amp;ubuntu/refind.jpg" alt="image"></p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p>Ubuntu 16.04 与 Win10 双系统双硬盘安装图解 <a href="http://blog.csdn.net/fesdgasdgasdg/article/details/54183577" target="_blank" rel="noopener">http://blog.csdn.net/fesdgasdgasdg/article/details/54183577</a></p></li><li><p>最新版 Ubuntu 17.10 与 Windows 双系统安装、配置与美化教程 <a href="http://www.jianshu.com/p/62d947731401" target="_blank" rel="noopener">http://www.jianshu.com/p/62d947731401</a></p></li><li><p>rEFInd 引导教程 - refind 吧 <a href="https://tieba.baidu.com/p/4383185951?red_tag=2713770601" target="_blank" rel="noopener">https://tieba.baidu.com/p/4383185951?red_tag=2713770601</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      win10、Ubuntu 双系统安装教程，外加 rEFInd 引导美化 
    
    </summary>
    
      <category term="Computer" scheme="https://blog.wangriyu.wang/categories/Computer/"/>
    
    
      <category term="UEFI&amp;GPT" scheme="https://blog.wangriyu.wang/tags/UEFI-GPT/"/>
    
      <category term="win10&amp;Ubuntu 双系统" scheme="https://blog.wangriyu.wang/tags/win10-Ubuntu-%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="rEFInd 引导美化" scheme="https://blog.wangriyu.wang/tags/rEFInd-%E5%BC%95%E5%AF%BC%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 IV</title>
    <link href="https://blog.wangriyu.wang/2017/12-Dart%20IV.html"/>
    <id>https://blog.wangriyu.wang/2017/12-Dart IV.html</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h2><p>如果你在 API 文档寻找基本数组类型或者 List 类型，你将会看到该类型实际上为 List<e>, 其中&lt;…&gt;标记表示此表为一个泛型类型（或为参数化结构）—— 一种含有正规类型参数的类型。按照惯例，类型变量通常为单字符名称，例如 E, T, S, K 以及 V。</e></p><h3 id="为何要使用泛型？"><a href="#为何要使用泛型？" class="headerlink" title="为何要使用泛型？"></a>为何要使用泛型？</h3><p>因为在 Dart 中类型是可选的，你不一定要使用泛型。或许你想用，可是，因为一些相同的原因你会想在代码中使用其他的类型：这些类型（泛型或者其他类型）可以记录并注释你的代码，使你的意图更加清晰。</p><p>比如，如果你打算使用一个仅仅包含字符串的 List，你可以声明它为 List<string>（可理解为“字符串类型组成的 List”），通过这种方式，你的程序员同事，以及你的工具（比如 Dart 编辑器和调试模式下的 Dart 虚拟机）能检测到将一个非字符串的变量分配到 List 中很可能是错误的，这里给出一个样例：</string></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 在调试模式中失败 (在生产模式中成功)</span></span><br></pre></td></tr></table></figure><p>另外一个使用泛型的原因是为了减少代码的重复。泛型可以让你能共享多个类型的一个接口和实现方式，它在调试模式以及静态分析的错误预警中仍然很有优势。举个例子，当你在创建一个接口来缓存一个对象时：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span></span>&#123;</span><br><span class="line">  object getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key,<span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现你想要一个字符串专用的接口，所以你创建了另外一个接口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span></span>&#123;</span><br><span class="line">  string getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key,<span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想要一个这种接口的数字专用的接口，又要创建不同类型的接口。<br>泛型类型可以减少你创建这些接口的麻烦。取而代之的是，你只需要创建一个带有一个类型参数的接口即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key,T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，T 是一个替代类型，即占位符，你可以将他视为后续被开发者定义的类型。</p><h3 id="使用集合常量"><a href="#使用集合常量" class="headerlink" title="使用集合常量"></a>使用集合常量</h3><p>Lis 常量以及 map 常量都能被参数化，参数常量就像你已经见过的常量那样，除非你在左 方括号之前添加<type>(对于 List）或者&lt;keyType,valuetype&gt;(对于 map）。当你需要避免调试模式下的类型警告，你或许可以使用参数常量。这里有一个使用常量类型的例子：</type></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>];</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">'index.html'</span>: <span class="string">'Homepage'</span>,</span><br><span class="line">  <span class="string">'robots.txt'</span>: <span class="string">'Hints for web robots'</span>,</span><br><span class="line">  <span class="string">'humans.txt'</span>: <span class="string">'We are people, not machines'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用带构造器的参数化类型"><a href="#使用带构造器的参数化类型" class="headerlink" title="使用带构造器的参数化类型"></a>使用带构造器的参数化类型</h3><p>为了在使用构造器时详细说明一个或多个类型，将类型放入类名后的三角括号（&lt;…&gt;）中，举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([‘Seth’, ‘Kathy’ , ‘Lars’]);</span><br><span class="line"><span class="keyword">var</span> nameSet = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure><p>下列代码创建了一个含有整型的键以及值为 View 的 map：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> views = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>,view&gt;();</span><br></pre></td></tr></table></figure><h3 id="泛型集合及其包含的类型"><a href="#泛型集合及其包含的类型" class="headerlink" title="泛型集合及其包含的类型"></a>泛型集合及其包含的类型</h3><p>Dart 泛型类型是被具体化的，意思就是它们在整个运行时间中都携带着类型信息。举个例子，你可以测试一个集合中的类型甚至是在生产模式中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>然而，is 表达式检查的仅仅是集合中的类型并不是其中的对象。在生产模式下，一个 List<string>中可能含有一些非字符项，解决方法可以是逐项检查其类型或者在异常处理程序中加入数据项操作代码 (参见 <a href="">异常</a>)。</string></p><blockquote><p>相比之下，Java 中的泛型使用擦除，这意味着通用类型参数在运行时被删除。在 Java 中，您可以测试对象是否为 List，但是不能测试它是否为 List<string></string></p></blockquote><h3 id="限制参数化类型"><a href="#限制参数化类型" class="headerlink" title="限制参数化类型"></a>限制参数化类型</h3><p>实现通用类型时，可能需要限制其参数的类型。你可以使用 extends 来做到这一点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 必须是某个类或者类的后代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main () &#123;</span><br><span class="line">  <span class="comment">// 在&lt;&gt;中使用某个类或者其子类都可以</span></span><br><span class="line">  <span class="keyword">var</span> someBaseClassFoo = <span class="keyword">new</span> Foo&lt;SomeBaseClass&gt;();</span><br><span class="line">  <span class="keyword">var</span> extenderFoo = <span class="keyword">new</span> Foo&lt;Extender&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不使用&lt;&gt;也可以</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定任何非 SomeBaseClass 类型会导致警告（检查模式中是运行时错误 runtime error）</span></span><br><span class="line">  <span class="comment">// var objectFoo = new Foo&lt;Object&gt;();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h3><p>最初，Dart 的泛型支持仅限于类。一种较新的语法（称为泛型方法，SDK1.21 之后）允许在方法和函数上使用类型参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ... 一些初始化工作或者错误检查...</span></span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ... 做一些额外的检查或处理...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型参数（<t>）允许你在多个位置使用类型参数 T：</t></p><ul><li>函数的返回类型 (T)</li><li>参数类型 (List<t>)</t></li><li>局部变量类型 (T tmp)<br>更多关于泛型函数，详见 <a href="https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md" target="_blank" rel="noopener">泛型方法</a></li></ul><hr><h2 id="库和可见性-Libraries-and-visibility"><a href="#库和可见性-Libraries-and-visibility" class="headerlink" title="库和可见性 Libraries and visibility"></a>库和可见性 Libraries and visibility</h2><p>import，library 指令可以帮助创建一个模块化的，可共享的代码库。库不仅提供了 API，还提供隐私单元：以下划线 ( _ ) 开头的标识符只对内部库可见。每个 Dartapp 就是一个库，即使它不使用库指令。</p><p>库可以分布式使用包。见 <a href="https://www.dartlang.org/tools/pub" target="_blank" rel="noopener">Pub Package and Asset Manager</a> 中有关 pub(SDK 中的一个包管理器）。</p><h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>使用 import 来指定如何从一个库命名空间用于其他库的范围。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>; <span class="comment">// Dart Web 应用一般采用这个库 dart:html</span></span><br></pre></td></tr></table></figure><p>唯一需要 import 的参数是一个指向库的 URI。对于内置库，URI 中具有特殊 dart: scheme。对于其他库，你可以使用文件系统路径或 package: scheme。包 package：scheme 指定由程序包管理器（如 pub 工具）提供的库。例如:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:mylib/mylib.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:utils/utils.dart'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：URI 代表统一资源标识符。网址（统一资源定位器）是一种常见的 URI 的。</p></blockquote><h3 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h3><p>如果导入两个库是有冲突的标识符，那么你可以指定一个或两个库的前缀。例如，如果 library1 和 library2 都有一个元素类，那么你可能有这样的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>(); <span class="comment">// 使用 lib1 里的元素</span></span><br><span class="line"><span class="keyword">var</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>();       <span class="comment">// 使用 lib2 里的元素</span></span><br></pre></td></tr></table></figure><h3 id="导入部分库"><a href="#导入部分库" class="headerlink" title="导入部分库"></a>导入部分库</h3><p>如果想使用的库一部分，你可以选择性导入库。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入 foo 库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入所有除了 foo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure><h3 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h3><p>延迟 (deferred) 加载（也称为懒 (lazy) 加载）允许应用程序按需加载库。下面是当你可能会使用延迟加载某些情况：</p><ul><li>为了减少应用程序的初始启动时间</li><li>例如，要执行 A / B 测试 ( A/B testing) - 尝试算法的替代实现</li><li>加载很少使用的功能，例如可选的屏幕和对话框</li></ul><p>为了延迟加载一个库，你必须使用 deferred as 先导入它:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:deferred/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure><p>当需要库时，使用该库的调用标识符调用 LoadLibrary（）:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，await 关键字将暂停执行，直到库被加载。更多关于 async 和 await 详见 <a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p>您可以在库中多次调用 loadLibrary( )。该库仅加载一次。<br>当您使用延迟加载，要注意一下几点：</p><ul><li>延迟库的常量在其作为导入文件时不是常量。记住，这些常量不存在，直到迟库被加载完成。</li><li>你不能在导入文件中使用延迟库常量的类型。相反，考虑将接口类型移到同时由延迟库和导入文件导入的库。</li><li>Dart 隐式地将 loadLibrary（）插入到使用 deferred 作为命名空间定义的命名空间中。调用 LoadLibrary（）函数返回一个 Future 对象（类似于 JS 的 promise 对象）。</li></ul><h3 id="库的实现"><a href="#库的实现" class="headerlink" title="库的实现"></a>库的实现</h3><p>详见 <a href="https://www.dartlang.org/guides/libraries/create-library-packages" target="_blank" rel="noopener">创建库文件包</a></p><hr><h2 id="异步的支持-Asynchrony-support"><a href="#异步的支持-Asynchrony-support" class="headerlink" title="异步的支持 Asynchrony support"></a>异步的支持 Asynchrony support</h2><p>Dart 添加了一些新的语言特性用于支持异步编程。最通常使用的特性是 async 方法和 await 表达式。Dart 库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成。</p><p>当你需要使用 Future 来表示一个值时，你有两个选择：</p><ul><li>使用 async 和 await</li><li>使用 <a href="https://www.dartlang.org/guides/libraries/library-tour#future" target="_blank" rel="noopener">Future API</a></li></ul><p>同样的，当你需要从 Stream 获取值的时候，你有两个选择:</p><ul><li>使用 async 和一个异步的 for 循环 (await for)</li><li>使用 <a href="https://www.dartlang.org/guides/libraries/library-tour#stream" target="_blank" rel="noopener">Stream API</a></li></ul><p>要使用 await，代码必须用 async 标记函数:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="keyword">if</span> (version == expectedVersion) &#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something else.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 try, catch, 和 finally 来处理错误并清理使用了 await 的代码:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  server = <span class="keyword">await</span> HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, <span class="number">4044</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 响应无法绑定到端口...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h3><p>一个异步函数是一个由 async 修饰符标记的函数。虽然一个异步函数可能在操作上比较耗时，但是它可以在任何方法体执行之前立即返回。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lookUpVersion() <span class="keyword">async</span> =&gt; <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure><p>在函数中添加关键字 async 使得它返回一个 Future 对象。<br>比如，考虑一下这个同步函数，它将返回一个字符串：<br>String lookUpVersionSync() =&gt; ‘1.0.0’;<br>更改它成为异步方法 - 因为在之后的实现中将会非常耗时 - 它的返回值是一个 Future 对象：<br>Future<string>lookUpVersion() async =&gt; ‘1.0.0’;<br>请注意函数体不需要使用 Future API，如果必要的话 Dart 将会自己创建 Future 对象。</string></p><h3 id="使用带-future-的-await-表达式"><a href="#使用带-future-的-await-表达式" class="headerlink" title="使用带 future 的 await 表达式"></a>使用带 future 的 await 表达式</h3><p>在异步方法中你可以使用 await 多次。比如，下列代码为了得到函数的结果一共等待了三次：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure><p>在 await 表达式中， 表达式 的值通常是一个 Future 对象；如果不是，那么这个值会自动转为 Future。这个 Future 对象表明了表达式应该返回一个对象。await 表达式 的值就是返回的一个对象。在对象可用之前，await 表达式将会一直处于暂停状态。</p><p>如果 await 没有起作用，请确认它是一个异步方法。比如，在你的 main() 函数里面使用 await，main() 的函数体必须被 async 标记:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In main: version is <span class="subst">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结合-streams-使用异步循环"><a href="#结合-streams-使用异步循环" class="headerlink" title="结合 streams 使用异步循环"></a>结合 streams 使用异步循环</h3><p>一个异步循环具有以下形式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (variable declaration <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// 每次 stream 发出一个值时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式 的值 the value of expression 必须有 Stream 类型（流类型）。执行过程如下：</p><ul><li>在 stream 发出一个值之前等待</li><li>执行 for 循环的主体，把变量设置为发出的值</li><li>重复 1 和 2，直到 Stream 关闭</li></ul><p>如果要停止监听 stream ，你可以使用 break 或者 return 语句，跳出循环并取消来自 stream 的订阅 。<br>如果一个异步 for 循环没有正常运行，请确认它是一个异步方法。 比如，在应用的 main() 方法中使用异步的 for 循环时，main() 的方法体必须被 async 标记：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于异步编程的信息，请看 <a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming" target="_blank" rel="noopener">dart:async</a> 库的介绍。<br>也可以看文章 <a href="https://www.dartlang.org/articles/language/await-async" target="_blank" rel="noopener">Dart Language Asynchrony Support: Phase 1</a> 和 <a href="https://www.dartlang.org/articles/language/beyond-async" target="_blank" rel="noopener">Dart Language Asynchrony Support: Phase 2</a> 和 <a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">the Dart language specification</a>。</p><hr><h2 id="可调用类-Callable-classes"><a href="#可调用类-Callable-classes" class="headerlink" title="可调用类 Callable classes"></a>可调用类 Callable classes</h2><p>为了允许你的 Dart 类可以像函数一样被调用，实现了 call（）方法。<br>在下面的例子中，WannabeFunction 类定义了一个 call（）函数，它需要三个字符串并用空格串联它们，并加上感叹号：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'$a $b $c!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'$out'</span>);  <span class="comment">// Hi there, gang!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于类函数，详见 <a href="https://www.dartlang.org/articles/language/emulating-functions" target="_blank" rel="noopener">将类用作函数</a>。</p>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>masm for mac</title>
    <link href="https://blog.wangriyu.wang/2017/11-masm.html"/>
    <id>https://blog.wangriyu.wang/2017/11-masm.html</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mac 推荐使用的汇编语法是 nasm，但学校实验用的是 masm，Windows 上有专门的 masm 编辑器，Mac 上想要编写 masm 会麻烦一点，需要用到 DOSBox 和一些编译链接文件，下面就是折腾的过程</p><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="到用户目录克隆文件"><a href="#到用户目录克隆文件" class="headerlink" title="到用户目录克隆文件"></a>到用户目录克隆文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/wangriyu/masm-for-mac.git</span><br></pre></td></tr></table></figure><p><code>~/masm-for-mac</code> 目录下应有以下文件，masm5 是主要的编译链接文件，DOSBox.app 提供沙盒环境，src 中有一些事例代码</p><p><img src="https://src.wangriyu.wang/images/blog/masm/files.png" alt="image"></p><h3 id="打开-DOSBox，输入-mount-指令挂载虚拟磁盘，盘符为-c，目录是克隆下来的-masm5-文件夹路径，挂载成功后输入-c-进入虚拟磁盘，再输入-dir-列出目录文件，输入-HELP-查看帮助，与-Dos-环境的命令一致"><a href="#打开-DOSBox，输入-mount-指令挂载虚拟磁盘，盘符为-c，目录是克隆下来的-masm5-文件夹路径，挂载成功后输入-c-进入虚拟磁盘，再输入-dir-列出目录文件，输入-HELP-查看帮助，与-Dos-环境的命令一致" class="headerlink" title="打开 DOSBox，输入 mount 指令挂载虚拟磁盘，盘符为 c，目录是克隆下来的 masm5 文件夹路径，挂载成功后输入 c: 进入虚拟磁盘，再输入 dir 列出目录文件，输入 HELP 查看帮助，与 Dos 环境的命令一致"></a>打开 DOSBox，输入 mount 指令挂载虚拟磁盘，盘符为 c，目录是克隆下来的 masm5 文件夹路径，挂载成功后输入 c: 进入虚拟磁盘，再输入 dir 列出目录文件，输入 HELP 查看帮助，与 Dos 环境的命令一致</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mount c ~/masm-for-mac/masm5</span><br><span class="line"></span><br><span class="line">$ c:</span><br><span class="line"></span><br><span class="line">$ dir</span><br></pre></td></tr></table></figure><p><img src="https://src.wangriyu.wang/images/blog/masm/mount.png" alt="image"></p><h3 id="用自己常用的文本编辑器，比如-VSCode-打开文件目录，在-masm5-下新建-asm-文件-src-中有一些事例-，用-masm-语法编写汇编代码，然后通过-masm-汇编、link-链接后就可以运行输出"><a href="#用自己常用的文本编辑器，比如-VSCode-打开文件目录，在-masm5-下新建-asm-文件-src-中有一些事例-，用-masm-语法编写汇编代码，然后通过-masm-汇编、link-链接后就可以运行输出" class="headerlink" title="用自己常用的文本编辑器，比如 VSCode 打开文件目录，在 masm5 下新建 asm 文件 (src 中有一些事例)，用 masm 语法编写汇编代码，然后通过 masm 汇编、link 链接后就可以运行输出"></a>用自己常用的文本编辑器，比如 VSCode 打开文件目录，在 masm5 下新建 asm 文件 (src 中有一些事例)，用 masm 语法编写汇编代码，然后通过 masm 汇编、link 链接后就可以运行输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ masm hello.asm</span><br><span class="line">// 连按三次回车</span><br><span class="line">$ link hello.obj</span><br><span class="line">// 连按三次回车</span><br><span class="line">$ hello.exe</span><br></pre></td></tr></table></figure><p><img src="https://src.wangriyu.wang/images/blog/masm/hello.png" alt="image"></p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><h3 id="平均数计算，连续输入十个-10-以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留-3-位小数"><a href="#平均数计算，连续输入十个-10-以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留-3-位小数" class="headerlink" title="平均数计算，连续输入十个 10 以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留 3 位小数"></a>平均数计算，连续输入十个 10 以下的数，程序计算去掉一个最小数，去掉一个最大数后八个数的平均值，从显示器显示出来，结果保留 3 位小数</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/average.png" alt="average"></p><h3 id="按-15-行-X16-列的表格显示表示-ASCII-码为-10H—100H-的所有字符，即以行为主的顺序及-ASCII-码递增的次序一次显示对应的字符，每-16-个字符为一行，每行中的相邻的字符之间用空白（ASCII-为-0）隔开"><a href="#按-15-行-X16-列的表格显示表示-ASCII-码为-10H—100H-的所有字符，即以行为主的顺序及-ASCII-码递增的次序一次显示对应的字符，每-16-个字符为一行，每行中的相邻的字符之间用空白（ASCII-为-0）隔开" class="headerlink" title="按 15 行 X16 列的表格显示表示 ASCII 码为 10H—100H 的所有字符，即以行为主的顺序及 ASCII 码递增的次序一次显示对应的字符，每 16 个字符为一行，每行中的相邻的字符之间用空白（ASCII 为 0）隔开"></a>按 15 行 X16 列的表格显示表示 ASCII 码为 10H—100H 的所有字符，即以行为主的顺序及 ASCII 码递增的次序一次显示对应的字符，每 16 个字符为一行，每行中的相邻的字符之间用空白（ASCII 为 0）隔开</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test1.png" alt="test1"></p><h3 id="程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示-“No-match-”；如果句子中包含关键字则显示-“match-”，且把该字在句子中的位置用十六进制数显示出来"><a href="#程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示-“No-match-”；如果句子中包含关键字则显示-“match-”，且把该字在句子中的位置用十六进制数显示出来" class="headerlink" title="程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示 “No match!”；如果句子中包含关键字则显示 “match!”，且把该字在句子中的位置用十六进制数显示出来"></a>程序接受用户键入的一个关键字以及一个句子，如果句子中不包含关键字则显示 “No match!”；如果句子中包含关键字则显示 “match!”，且把该字在句子中的位置用十六进制数显示出来</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test2.png" alt="test2"></p><h3 id="程序接受用户键入一行字符（字符个数不超过-80-个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以-letter、digit-和-other-为名的存储单元中"><a href="#程序接受用户键入一行字符（字符个数不超过-80-个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以-letter、digit-和-other-为名的存储单元中" class="headerlink" title="程序接受用户键入一行字符（字符个数不超过 80 个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以 letter、digit 和 other 为名的存储单元中"></a>程序接受用户键入一行字符（字符个数不超过 80 个，该字符串用回车符结束），并按字母、数字、其它字符分类计数，然后将结果存入以 letter、digit 和 other 为名的存储单元中</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test3.png" alt="test3"></p><h3 id="添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码"><a href="#添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码" class="headerlink" title="添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码"></a>添加查找电话号码本，程序可接受输入人名及相应的电话号码，并把它们加入电话号码表中，程序可按人名对电话号码表重新排序，程序可接受需要查询电话号码的人名，并从电话号码表中查出其电话号码</h3><p><img src="https://src.wangriyu.wang/images/blog/masm/test4.png" alt="test4"></p><h2 id="DOSBox-进阶玩法"><a href="#DOSBox-进阶玩法" class="headerlink" title="DOSBox 进阶玩法"></a>DOSBox 进阶玩法</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>在 DOSBox 输入 <code>intro special</code> 可以查看热键，比如 alt(option) + enter(return) 切换全屏，但有些键在 mac 上好像没用</p><h3 id="运行-Dos-游戏和旧应用"><a href="#运行-Dos-游戏和旧应用" class="headerlink" title="运行 Dos 游戏和旧应用"></a>运行 Dos 游戏和旧应用</h3><p>在 DOSBox 中可以运行 exe 文件，一些很老的 Dos 游戏和旧应用也可以运行，网上有很多经典游戏的资源，可以用 DOSBox 尝试下</p>]]></content>
    
    <summary type="html">
    
      mac 系统如何编写 masm 汇编 
    
    </summary>
    
      <category term="Mac" scheme="https://blog.wangriyu.wang/categories/Mac/"/>
    
    
      <category term="masm" scheme="https://blog.wangriyu.wang/tags/masm/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 III</title>
    <link href="https://blog.wangriyu.wang/2017/11-Dart%20III.html"/>
    <id>https://blog.wangriyu.wang/2017/11-Dart III.html</id>
    <published>2017-11-04T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h2><p>Dart 是一种面向对象语言，包含类和基于 mixin 的继承两部分。每个对象是一个类的实例，并且 Object 是所有类的父类。基于 mixin 的继承指的是每个类（除了 Object ）都只有一个父类，类体还可以在多个类继承中被重用。</p><p>要创建一个对象，你可以使用 new 关键词并在其后跟上一个构造函数。构造函数可以写成&lt;类名&gt;或者&lt;类名. 标识符&gt;形式。例如:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = JSON.decode(<span class="string">'&#123;"x":1, "y":2&#125;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 Point() 创建一个点。</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 Point().fromJson() 创建一个点。</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(jsonData);</span><br></pre></td></tr></table></figure><p>对象的成员分为函数和数据两类（各自的方法和实例变量）。当你调用一个方法时，通过一个对象来调用它的：该方法可访问该对象的方法和数据。用 . 指向对象的方法和数据成员:<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 y 赋值。</span></span><br><span class="line">p.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 y 的值。</span></span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 p 对象调用 distanceTo() 。</span></span><br><span class="line"><span class="built_in">num</span> distance = p.distanceTo(<span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用?. 代替. 来避免操作对象为 null 时产生的异常</span></span><br><span class="line">p?.y = <span class="number">4</span>; <span class="comment">// 如果 p 不为空则设置 p.y 等于 4</span></span><br></pre></td></tr></table></figure><p></p><p>当你想对一个对象的成员进行一系列操作时，用级联操作（ cascade ）：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#button'</span>) <span class="comment">// 获取一个对象。</span></span><br><span class="line">    ..text = <span class="string">'Confirm'</span>   <span class="comment">// 调用他的成员。</span></span><br><span class="line">    ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">    ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure><p></p><p>一些类提供常量构造函数，要创建一个编译时常量构造函数，使用 const 关键字代替 new ：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(identical(a, b)); <span class="comment">// 他们是相同的实例！</span></span><br></pre></td></tr></table></figure><p></p><p>如果想在运行时获取对象的类型，可以使用 runtimeType 属性：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'The type of a is <span class="subst">$&#123;a.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>声明实例变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x; <span class="comment">// 声明实例变量 x ，默认值为 null 。</span></span><br><span class="line">  <span class="built_in">num</span> y; <span class="comment">// 声明实例变量 y ，默认值为 null 。</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// 声明实例变量 z ，初始化为 0 。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的实例变量会自动生成一个隐式的 getter 方法。 Non-final 实例变量也会自动生成一个隐式的 setter 方法。有关详细信息，参见 <a href="https://www.dartlang.org/guides/language/language-tour#getters-and-setters" target="_blank" rel="noopener">getter&amp;setter</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">  point.x = <span class="number">4</span>;          <span class="comment">// 用 setter 方法得到 x 。</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>); <span class="comment">// 用 getter 方法得到 x 。</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>); <span class="comment">// 值为 null 。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>要声明一个构造函数，只需创建一个与类同名的方法（或者加上一个额外的标识符命名构造函数的描述）。构造函数最常见的形式，就是自动生成的构造函数，下面创建一个类的新实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有个更好的方法来实现。用语法糖来设置 x，y: Point(this.x, this.y)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>默认构造函数: 如果你不声明一个构造函数，系统会提供默认构造函数。默认构造函数没有参数，它将调用父类的无参数构造函数。</p></li><li><p>子类不继承父类的构造函数。子类只有默认构造函数。（无参数，没有名字的构造函数）</p></li><li><p>命名构造函数。使用命名构造函数可以为一个类声明多个构造函数，或者说是提供额外的声明</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">'x'</span>];</span><br><span class="line">    y = json[<span class="string">'y'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用非默认的父类的构造函数。默认情况下，在子类的构造函数将会调用父类的无参数默认构造函数。如果父类没有构造函数，则必须手动调用父类的构造函数中的一个。在冒号（：）之后、构造函数之前指定父类的构造函数（如果有的话）。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Person'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Person 没有默认构造函数，子类必需调用 super.&lt;命名构造函数&gt;</span></span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Employee'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class="line">  <span class="comment">// 输出:</span></span><br><span class="line">  <span class="comment">// in Person</span></span><br><span class="line">  <span class="comment">// in Employee</span></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123; <span class="comment">// 类型检查</span></span><br><span class="line">    emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用父类构造函数前会检测参数，这个参数可以是一个表达式作为函数调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(findDefaultData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️警告：父类构造函数的参数不能访问 this 。例如，参数可调用静态方法但是不能调用实例方法。</p><hr><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>除了调用父类构造函数，你也可以在构造函数体运行之前初始化实例变量。用逗号隔开使其分别初始化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化列表在构造函数运行前设置实例变量。</span></span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> jsonMap)</span><br><span class="line">      : x = jsonMap[<span class="string">'x'</span>],</span><br><span class="line">        y = jsonMap[<span class="string">'y'</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'In Point.fromJson(): ($x, $y)'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️警告：右手边的初始化程序无法访问 this 关键字</p><p>以下示例在初始化程序列表中初始化三个 final 字段<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">      : x = x,</span><br><span class="line">        y = y,</span><br><span class="line">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>,  <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);  <span class="comment">// 输出 3.605551275463989</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h3><p>有时一个构造函数的目的只是重定向到同一个类中的另一个构造函数。如果一个重定向的构造函数的主体为空，那么调用这个构造函数的时候，直接在冒号后面调用这个构造函数即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主构造函数</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主函数的委派</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>如果你的类产生的对象永远不会改变，你可以让这些对象成为编译时常量。为此，需要定义一个 const 构造函数并确保所有的实例变量都是 final 的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h3><p>当实现一个使用 factory 关键词修饰的构造函数时，这个构造函数不必创建类的新实例。例如，工厂构造函数可能从缓存返回实例，或者它可能返回子类型的实例。 下面的示例演示一个工厂构造函数从缓存返回的对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;; <span class="comment">//  _cache 是一个私有库，因为名字前有个 _</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger (<span class="built_in">String</span> name)  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="keyword">void</span> log (<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) &#123;</span><br><span class="line">      <span class="built_in">print</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️注：工厂构造函数不能用 this。</p><p>调用一个工厂构造函数，你需要使用 new 关键字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> Logger(<span class="string">'UI'</span>);</span><br><span class="line">logger.log(<span class="string">'Button clicked'</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法就是为对象提供行为的函数。</p><ul><li>实例方法<br>对象的实例方法可以访问实例变量和 this 。以下示例中的 distanceTo() 方法是实例方法的一个例子：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> distanceTo (Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setters 和 Getters: 是一种提供对方法属性读和写的特殊方法。每个实例变量都有一个隐式的 getter 方法，如果合适的话可以加上 setter 方法。你可以通过实现 getters 和 setters 来创建附加属性，也就是直接使用 get 和 set 关键词：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义两个计算属性: right and bottom</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助于 getter 和 setter，你可以直接使用实例变量，并且在不改变客户代码的情况下把他们包装成方法。</p><p>⚠️注：不论是否显式地定义了一个 getter，类似增量（++）的操作符，都能以预期的方式工作。为了避免产生任何向着不期望的方向的影响，操作符一旦调用 getter ，就会把他的值存在临时变量里。</p><ul><li>抽象方法<br>Instance，getter 和 setter 方法可以是抽象的，也就是定义一个接口，但是把实现交给其他的类。要创建一个抽象方法，使用分号 (;) 代替方法体：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 定义实例变量和方法...</span></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// 定义一个抽象方法，没有 body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// ... 提供一个实现，所以这里的方法不是抽象的...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用抽象方法会导致运行时错误。</p><hr><h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>你可以重写在下表中列出的操作符。例如，如果你定义了一个向量类，你可以定义一个 + 方法来加两个向量。</p><table><thead><tr><th style="text-align:center">&lt;</th><th style="text-align:center">+</th><th style="text-align:center">I</th><th style="text-align:center">[ ]</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">/</td><td style="text-align:center">^</td><td style="text-align:center">[ ]=</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">~/</td><td style="text-align:center">&amp;</td><td style="text-align:center">~</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">*</td><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">==</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">%</td><td style="text-align:center">&gt;&gt;</td></tr></tbody></table><p>以下是一个类中重写 + 和 - 操作符的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="keyword">const</span> Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写 + (a + b).</span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x + v.x, y + v.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写 - (a - b).</span></span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x - v.x, y - v.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="keyword">final</span> v = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v == (2, 3)</span></span><br><span class="line">  <span class="keyword">assert</span>(v.x == <span class="number">2</span> &amp;&amp; v.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v + w == (4, 5)</span></span><br><span class="line">  <span class="keyword">assert</span>((v + w).x == <span class="number">4</span> &amp;&amp; (v + w).y == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v - w == (0, 1)</span></span><br><span class="line">  <span class="keyword">assert</span>((v - w).x == <span class="number">0</span> &amp;&amp; (v - w).y == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dart 中的每个对象自动提供一个整数哈希码，因此可以用作 map 的一个键。但是，你可以重写 hashCode getter 来生成自定义哈希码。如果你这样做，你可能也想重写 == 运算符。相等的（通过 ==）的对象必须具有相同的哈希码。哈希码不一定是唯一的，但是它具有良好的分布性。<br>重写 == 和 hashCode 例子:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> firstName, lastName;</span><br><span class="line"></span><br><span class="line">  Person(<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 Effective Java 中的策略重写 hashCode</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode &#123;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">37</span> * result + firstName.hashCode;</span><br><span class="line">    result = <span class="number">37</span> * result + lastName.hashCode;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果重写了 hashCode，一般也要实现‘==''</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">is</span>! Person) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Person person = other;</span><br><span class="line">    <span class="keyword">return</span> (person.firstName == firstName &amp;&amp; person.lastName == lastName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'bob'</span>, <span class="string">'smith'</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'bob'</span>, <span class="string">'smith'</span>);</span><br><span class="line">  <span class="keyword">var</span> p3 = <span class="string">'not a person'</span>;</span><br><span class="line">  <span class="keyword">assert</span>(p1.hashCode == p2.hashCode);</span><br><span class="line">  <span class="keyword">assert</span>(p1 == p2);</span><br><span class="line">  <span class="keyword">assert</span>(p1 != p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于重载的信息，详见 <a href="https://www.dartlang.org/guides/language/language-tour#extending-a-class" target="_blank" rel="noopener">扩展一个类</a></p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用 abstract 修饰符来定义一个抽象类，该类不能被实例化。抽象类在定义接口的时候非常有用，实际上抽象中也包含一些实现。如果你想让你的抽象类被实例化，请定义一个 工厂构造函数。</p><p>抽象类通常包含 抽象方法。下面是声明一个含有抽象方法的抽象类的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类是抽象类，因此不能被实例化。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 定义构造函数，域，方法...</span></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的类不是抽象类，因此它可以被实例化，即使定义了一个抽象方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecializedContainer</span> <span class="keyword">extends</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 定义更多构造函数，域，方法...</span></span><br><span class="line">  <span class="keyword">void</span> updateChildren() &#123;</span><br><span class="line">    <span class="comment">// ... 实现 updateChildren()...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法造成一个警告，但是不会阻止实例化。</span></span><br><span class="line">  <span class="keyword">void</span> doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类隐式的定义了一个接口，含有类的所有实例和它实现的所有接口。如果你想创建一个支持类 B 的 API 的类 A，但又不想继承类 B ，那么，类 A 应该实现类 B 的接口。<br>一个类实现一个或更多接口通过用 implements 子句声明，然后提供 API 接口要求。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 person 类 ，包含 greet() 的隐式接口。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在这个接口中，只有库中可见。</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不在接口中，因为这是个构造函数。</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这个接口中。</span></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hello, $who. I am $_name.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Person 接口的一个实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 我们不得不定义它，但不用它。</span></span><br><span class="line">  <span class="keyword">final</span> _name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hi $who. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Person(<span class="string">'kathy'</span>)));  <span class="comment">// Hello, bob. I am kathy.</span></span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Imposter()));  <span class="comment">// Hi bob. Do you know who I am?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类实现多个接口的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="扩展一个类"><a href="#扩展一个类" class="headerlink" title="扩展一个类"></a>扩展一个类</h3><p>使用 extends 创建一个子类，同时 supper 将指向父类：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="重写成员"><a href="#重写成员" class="headerlink" title="重写成员"></a>重写成员</h3><p>子类可以重载实例方法，getters 方法，setters 方法。可以使用 @override 注释来显示地表明你要重写的成员：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 covariant 关键字来缩小类型安全代码中方法参数或实例变量的类型范围。<br>在一些（很少见到）的编码模式中使用子类型重写一个参数类型来缩小类型范围，这在强模式 Dart 中是非法的。在这种情况下，您可以使用协变关键字 covariant 告诉分析器您正在进行此操作。这将删除静态错误，而在运行时检查无效的参数类型。<br>下面是使用 covariant 的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:meta/meta.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(Animal x) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> chase(covariant Mouse x) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>covariant 关键字可以放置在父类或子类方法中, 通常，父类方法是放置它的最佳方法。covariant 关键字适用于单个参数，并且支持 setters 和 fields。</p><hr><h3 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h3><p>当代码试图用不存在的方法或实例变量时，这个方法会被调用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  <span class="comment">// 如果你不重写 noSuchMethod 方法，就用一个不存在的成员，会导致 NoSuchMethodError 错误。</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod (Invocation mirror) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'You tried to use a non-existent member:'</span> +</span><br><span class="line">          <span class="string">'<span class="subst">$&#123;mirror.memberName&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用 noSuchMethod() 实现每一个可能的 getter 方法，setter 方法和类的方法，那么你可以使用 @proxy 标注来避免警告。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@proxy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation mirror) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于注释 annotations，详见 <a href="https://www.dartlang.org/guides/language/language-tour#metadata" target="_blank" rel="noopener">元数据 MetaData</a></p><hr><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型，通常被称为 enumerations 或 enums ，是一种用来代表一个固定数量的常量的特殊类。</p><ul><li>使用枚举<br>声明一个枚举类型需要使用关键字 enum ：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在枚举中每个值都有一个 index getter 方法，它返回一个在枚举声明中从 0 开始的位置。例如，第一个值索引值为 0，第二个值索引值为 1。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.green.index == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.blue.index == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要得到枚举列表的所有值，可使用枚举的 values 常量</span></span><br><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p>你可以在 switch 语句 中使用枚举。如果 e 在 switch (e) 是显式类型的枚举，那么如果你不处理所有的枚举值将会弹出警告：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Color aColor = Color.blue;</span><br><span class="line"><span class="keyword">switch</span> (aColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> Color.red:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Red as roses!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Color.green:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Green as grass!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 如果没有这个分句，将会弹出警告</span></span><br><span class="line">    <span class="built_in">print</span>(aColor);  <span class="comment">// 'Color.blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型有以下限制</p><ol><li>你不能在子类中混合或实现一个枚举</li><li>你不能显式实例化一个枚举</li></ol><hr><h3 id="为类添加特征：mixins"><a href="#为类添加特征：mixins" class="headerlink" title="为类添加特征：mixins"></a>为类添加特征：mixins</h3><p>mixins 是一种多类层次结构的类的代码重用。<br>要使用 mixins ，在 with 关键字后面跟一个或多个 mixin 的名字。下面的例子显示了两个使用 mixins 的类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现 mixin ，就创建一个继承 Object 类的子类，不声明任何构造函数，不调用 super。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Playing piano'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Waving hands'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Humming to self'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从 1.13 起，Dart VM 已经取消了对 mixin 的两个限制：</p><blockquote><ol><li>Mixins 允许继承自类 class，不局限于 Object</li><li>Mixins 可以调用 super（）<br>“super mixins” 在 dart2js 不受支持，并且需要在 dartanalyzer 中使用 –supermixin 标签。更多关于 mixins，详见 <a href="https://www.dartlang.org/articles/language/mixins" target="_blank" rel="noopener">Mixins in Dart</a></li></ol></blockquote></blockquote><h3 id="类的变量和方法"><a href="#类的变量和方法" class="headerlink" title="类的变量和方法"></a>类的变量和方法</h3><p>使用 static 关键字来实现类变量和类方法。</p><ul><li>静态变量<br>静态变量（类变量）对于类状态和常数是有用的：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> red = <span class="keyword">const</span> Color(<span class="string">'red'</span>);  <span class="comment">// 一个恒定的静态变量</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;      <span class="comment">// 一个实例变量。</span></span><br><span class="line">  <span class="keyword">const</span> Color(<span class="keyword">this</span>.name);  <span class="comment">// 一个恒定的构造函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Color.red.name == <span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当静态变量被调用时才被初始化。</p><ul><li>静态方法<br>静态方法（类方法）不在一个实例上进行操作，因而不必访问 this 。例如：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(distance &lt; <span class="number">2.9</span> &amp;&amp; distance &gt; <span class="number">2.8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将静态方法作为编译时常量。例如，你可以把静态方法作为一个参数传递给静态构造函数。</p>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法入门 II</title>
    <link href="https://blog.wangriyu.wang/2017/10-Dart%20II.html"/>
    <id>https://blog.wangriyu.wang/2017/10-Dart II.html</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2018-05-18T16:12:53.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h2><p>Dart 是一门面向对象的语言，即使函数也是对象也有类型。这意味着函数可以分配给变量或者当作参数传给其他函数。也可以像函数一样调用一个类的实例，比如 <a href="https://www.dartlang.org/guides/language/language-tour#callable-classes" target="_blank" rel="noopener">可调用的 Classes</a>。<br>下面是定义了一个函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123; <span class="comment">// 不指定函数返回类型也可以执行，但不推荐这样做</span></span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用箭头语法描述单个表达式，但不能使用多行的语句，比如 if statement，可以用条件表达式 (?:) 代替 if else</span></span><br><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="函数的参数有两种类型：required-和-optional"><a href="#函数的参数有两种类型：required-和-optional" class="headerlink" title="函数的参数有两种类型：required 和 optional"></a>函数的参数有两种类型：required 和 optional</h3><p>首先列出所有必需的参数，再跟上可选的参数。</p><p>可选参数有两种指定方式：可选命名参数 named 和可选位置参数 positional</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数时用&#123;param1, param2, …&#125;的形式指定 named 参数</span></span><br><span class="line">enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数时可以使用 paramName: value 的方式</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>用 [ ] 包裹可选参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数时用 [param1, param2, …] 的形式指定 positional 参数</span></span><br><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'$from says $msg'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'$result with a $device'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>) == <span class="string">'Bob says Howdy'</span>);</span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>) ==</span><br><span class="line">    <span class="string">'Bob says Howdy with a smoke signal'</span>);</span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>在函数定义时可以用 = 给参数指定默认值，这个默认值必须是编译时常量，如果没有指定默认值则为 null。</p><p>下面是给 named 参数设置默认值的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bold will be true; hidden will be false.</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>下面是给 positional 参数设置默认值的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">'carrier pigeon'</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'$from says $msg'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'$result with a $device'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'$result (in a $mood mood)'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>) ==</span><br><span class="line">    <span class="string">'Bob says Howdy with a carrier pigeon'</span>);</span><br></pre></td></tr></table></figure><p>也可以传递 lists 或者 maps 作为默认值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'paper'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'cotton'</span>,</span><br><span class="line">      <span class="string">'third'</span>: <span class="string">'leather'</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list:  $list'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'gifts: $gifts'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Main-函数"><a href="#Main-函数" class="headerlink" title="Main() 函数"></a>Main() 函数</h3><p>每个 app 都必需有一个 main() 函数，main() 返回 void 而且有一个可选的 List<string>字符参数列表。</string></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">"#sample_text_id"</span>)</span><br><span class="line">    ..text = <span class="string">"Click me!"</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .. 是级联 (cascade) 操作符，可以对单个对象执行多个操作</span></span><br></pre></td></tr></table></figure><p>给 main() 传入参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行 app 时传入参数：dart args.dart 1 test</span></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arguments);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(arguments.length == <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">int</span>.parse(arguments[<span class="number">0</span>]) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">assert</span>(arguments[<span class="number">1</span>] == <span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数作为参数传给其他函数或者赋给变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">printElement(element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">list.forEach(printElement);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">'!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!'</span>; <span class="comment">// 一个匿名函数</span></span><br><span class="line"><span class="keyword">assert</span>(loudify(<span class="string">'hello'</span>) == <span class="string">'!!! HELLO !!!'</span>);</span><br></pre></td></tr></table></figure><h3 id="词法作用域-Lexical-scope"><a href="#词法作用域-Lexical-scope" class="headerlink" title="词法作用域 Lexical scope"></a>词法作用域 Lexical scope</h3><p>Dart 时一门词法作用域的语言，即变量的作用域是静态地决定的，由代码的布局决定的。<br>词法作用域的函数遇到既不是形参也不是函数内部定义的局部变量的变量时，会去函数定义时的环境中查询。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> topLevel = <span class="number">1</span>; <span class="comment">// 如果去掉这一行，getLevel 报错“No top-level getter 'topLevel' declared”</span></span><br><span class="line"><span class="keyword">void</span> getLevel() &#123;</span><br><span class="line">  <span class="built_in">print</span>(topLevel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="keyword">var</span> topLevel = <span class="number">2</span>;</span><br><span class="line">  getLevel(); <span class="comment">// 输出 1，因为 getsome() 定义时 topLevel=1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h3><p>指的是一个函数可以访问其语法作用域内的变量，即使这个函数是在变量本身的作用域之外被调用的。<br>下面的例子中 makeAdder() 捕获了变量 addBy，不管返回的函数在哪里被调用，它都可以使用 addBy：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的等价性测试"><a href="#函数的等价性测试" class="headerlink" title="函数的等价性测试"></a>函数的等价性测试</h3><p>下面是关于顶层函数、静态方法和实例方法的等价性测试</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125; <span class="comment">// 一个顶层函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> bar() &#123;&#125; <span class="comment">// 一个静态方法</span></span><br><span class="line">  <span class="keyword">void</span> baz() &#123;&#125; <span class="comment">// 一个实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较顶级函数</span></span><br><span class="line">  x = foo;</span><br><span class="line">  <span class="keyword">assert</span>(foo == x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较静态方法</span></span><br><span class="line">  x = SomeClass.bar;</span><br><span class="line">  <span class="keyword">assert</span>(SomeClass.bar == x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较实例方法</span></span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">new</span> SomeClass(); <span class="comment">// SomeClass 的实例 1</span></span><br><span class="line">  <span class="keyword">var</span> w = <span class="keyword">new</span> SomeClass(); <span class="comment">// SomeClass 的实例 2</span></span><br><span class="line">  <span class="keyword">var</span> y = w;</span><br><span class="line">  x = w.baz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这些闭包引用了相同的示例对象（A 的实例 2），所以它们是等价的</span></span><br><span class="line">  <span class="keyword">assert</span>(y.baz == x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这些闭包引用的是不同实例，所以它们不等价</span></span><br><span class="line">  <span class="keyword">assert</span>(v.baz != w.baz); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>所有函数都会返回一个值，如果没有指定返回值，函数将会在函数体末尾隐式地添加“return null”</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> baz() &#123;&#125;</span><br><span class="line">main () &#123;</span><br><span class="line">  <span class="built_in">print</span>(baz()); <span class="comment">// 输出 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="操作符-Operators"><a href="#操作符-Operators" class="headerlink" title="操作符 Operators"></a>操作符 Operators</h2><p>Dart 定义了以下操作符，你可以 <a href="https://www.dartlang.org/guides/language/language-tour#overridable-operators" target="_blank" rel="noopener">重写这些操作符</a>。</p><table><thead><tr><th style="text-align:center">介绍</th><th style="text-align:left">符号</th></tr></thead><tbody><tr><td style="text-align:center">一元后缀符</td><td style="text-align:left">expr++ 、 expr– 、 () 、 [] 、 . 、 ?.</td></tr><tr><td style="text-align:center">一元前缀符</td><td style="text-align:left">-expr 、 !expr 、 ~expr 、 ++expr 、 —expr</td></tr><tr><td style="text-align:center">乘法类型</td><td style="text-align:left">* 、 / 、 % 、 ~/</td></tr><tr><td style="text-align:center">加法类型</td><td style="text-align:left">+ 、 -</td></tr><tr><td style="text-align:center">位操作符</td><td style="text-align:left">&lt;&lt; 、 &gt;&gt;</td></tr><tr><td style="text-align:center">按位与</td><td style="text-align:left">&amp;</td></tr><tr><td style="text-align:center">按位异或</td><td style="text-align:left">^</td></tr><tr><td style="text-align:center">按为或</td><td style="text-align:left">I</td></tr><tr><td style="text-align:center">比较和类型测试</td><td style="text-align:left">&gt;= 、 &gt; 、 &lt;= 、 &lt; 、 as 、 is 、 is!</td></tr><tr><td style="text-align:center">等价</td><td style="text-align:left">== 、 !=</td></tr><tr><td style="text-align:center">逻辑与</td><td style="text-align:left">&amp;&amp;</td></tr><tr><td style="text-align:center">逻辑或</td><td style="text-align:left">II</td></tr><tr><td style="text-align:center">null 分配符</td><td style="text-align:left">??</td></tr><tr><td style="text-align:center">条件运算符</td><td style="text-align:left">expr1 ? expr2 : expr3</td></tr><tr><td style="text-align:center">级联运算符</td><td style="text-align:left">..</td></tr><tr><td style="text-align:center">赋值</td><td style="text-align:left">= 、 *= 、 /= 、 ~/= 、 %= 、 += 、 -= 、 &lt;&lt;= 、 &gt;&gt;= 、 &amp;= 、 ^=</td></tr></tbody></table><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>／ 返回 double 型，～／ 返回整型的除数，% 返回除法的余数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> / <span class="number">2</span> == <span class="number">2.5</span>); <span class="comment">// 结果是 double 类型</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> ~/ <span class="number">2</span> == <span class="number">2</span>); <span class="comment">// 结果是一个整数</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="number">5</span> % <span class="number">2</span> == <span class="number">1</span>); <span class="comment">// 余数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'5/2 = <span class="subst">$&#123;<span class="number">5</span>~/<span class="number">2</span>&#125;</span> 余 <span class="subst">$&#123;<span class="number">5</span>%<span class="number">2</span>&#125;</span>'</span>); <span class="comment">// 5/2 = 2 余 1</span></span><br></pre></td></tr></table></figure><h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = ++a; <span class="comment">// 在 b 获得其值前先自增 a</span></span><br><span class="line"><span class="keyword">assert</span>(a == b); <span class="comment">// 1 == 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a++; <span class="comment">// 在 b 获得其值后自增 a</span></span><br><span class="line"><span class="keyword">assert</span>(a != b); <span class="comment">// 1 != 0</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = --a; <span class="comment">// 在 b 获得其值前自减 a</span></span><br><span class="line"><span class="keyword">assert</span>(a == b); <span class="comment">// -1 == -1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a--; <span class="comment">// 在 b 获得其值后自减 a</span></span><br><span class="line"><span class="keyword">assert</span>(a != b); <span class="comment">// -1 != 0</span></span><br></pre></td></tr></table></figure><h3 id="类型测试操作符"><a href="#类型测试操作符" class="headerlink" title="类型测试操作符"></a>类型测试操作符</h3><ul><li>as 类型转换</li><li>is 当对象是相应类型时返回 true</li><li>is！当对象不是相应类型时返回 true<br>如果 obj 实现了 T 所定义的借口，那么 obj is T 将返回 true。比如，obj is Object 必然返回 true。<br>使用 as 操作符可以把一个对象转换为特定类型。一般来说，如果在 is 测试之后还有一些关于对象的表达式，你可以把 as 当做是 is 测试的一种简写:</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123; <span class="comment">// 类型检查</span></span><br><span class="line">  emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// as 化简代码</span></span><br><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>上面两段代码并不相等。如果 emp 的值为 null 或者不是 Person 的一个对象，第一段代码不会做任何事情，第二段代码将会报错 。</p><h3 id="分配符"><a href="#分配符" class="headerlink" title="分配符"></a>分配符</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = value;   <span class="comment">// 将 value 赋给 a</span></span><br><span class="line">b ??= value; <span class="comment">// 如果 b 为 null 将 value 赋给 b，否则 b 值不变</span></span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><ul><li>condition ? expr1 : expr2 条件为真返回表达式 1，否则返回表达式 2</li><li>expr1 ?? expr2 表达式 1 为 null 则返回表达式 2，否则返回表达式 1</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> toString() =&gt; msg ?? <span class="keyword">super</span>.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">String</span> toString() =&gt; msg == <span class="keyword">null</span> ? <span class="keyword">super</span>.toString() : msg;</span><br></pre></td></tr></table></figure><h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>允许你在单个对象的成员上执行多个操作</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#button'</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">'Confirm'</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">'#button'</span>);</span><br><span class="line">button.text = <span class="string">'Confirm'</span>;</span><br><span class="line">button.classes.add(<span class="string">'important'</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></figure><p>级联操作符可以嵌套</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (</span><br><span class="line">  <span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">  ..name = <span class="string">'jenny'</span></span><br><span class="line">  ..email = <span class="string">'jenny@example.com'</span></span><br><span class="line">  ..phone = (</span><br><span class="line">    <span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">    ..number = <span class="string">'415-555-0100'</span></span><br><span class="line">    ..label = <span class="string">'home'</span></span><br><span class="line">  ).build()</span><br><span class="line">).build();</span><br></pre></td></tr></table></figure><p>在返回对象的函数上使用级联要格外注意，下面的例子中 sb.write() 返回 void，不能在 void 上构建级联</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line">sb.write(<span class="string">'foo'</span>)..write(<span class="string">'bar'</span>); <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure><p>严格意义上讲，级联操作符 .. 不算一个操作符，它属于 Dart 语法的一部分，应该算作一个语法</p><h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><ul><li>一个点. 代表成员访问，比如 foo.bar 从 foo 中选择了 bar 属性</li><li>问号加上一个点 ?. 代表条件成员访问，?. 之前的操作数可以为空，比如 foo?.bar 从 foo 中选择属性 bar，当 foo 为空时则不访问 bar</li></ul><hr><h2 id="控制流语句-Control-flow-statements"><a href="#控制流语句-Control-flow-statements" class="headerlink" title="控制流语句 Control flow statements"></a>控制流语句 Control flow statements</h2><ul><li>if else</li><li>for 循环</li><li>while 和 do while 循环</li><li>break 和 continue</li><li>switch case</li><li>assert</li></ul><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>Dart 的 for 循环闭包中可以获取 index 的值，就像下面的例子输出下标 0，1，2；而在 javaScript 中，下面的例子输出 3，3，3，如果想输出 0，1，2 需要把 var 改成 let</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Dart</span></span><br><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c()); <span class="comment">// 输出 0，1，2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in javaScript</span></span><br><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 改成 let 输出 0，1，2</span></span><br><span class="line">  callbacks.push(() =&gt; console.log(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c()); <span class="comment">// 输出 3，3，3</span></span><br></pre></td></tr></table></figure><p>可迭代的元素可以用 forEach() 方法遍历，也可以用 for-in</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p>用 break 退出循环，循环结束</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shutDownRequested()) <span class="keyword">break</span>;</span><br><span class="line">  processIncomingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 continue 跳出这一次循环，循环不结束</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> candidate = candidates[i];</span><br><span class="line">  <span class="keyword">if</span> (candidate.yearsExperience &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  candidate.interview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过迭代可以简化上述代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidates.where((c) =&gt; c.yearsExperience &gt;= <span class="number">5</span>).forEach((c) =&gt; c.interview());</span><br></pre></td></tr></table></figure><h3 id="转换语句"><a href="#转换语句" class="headerlink" title="转换语句"></a>转换语句</h3><p>可以使用 continue 和标签来跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'CLOSED'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">continue</span> nowClosed;</span><br><span class="line">nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'NOW_CLOSED'</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 case 分句可以含有局部变量，该局部变量仅仅只在此分句范围内可见</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>如果一个布尔条件值为 false，使用 assert 语句来中断正常执行的代码。在 assert 语句后面的括号中，你可以加入任何表示布尔值或者函数的表达式。如果表达式的值或者函数返回值 true，则 assert 语句成功并继续执行代码。如果值为 false，则 assert 语句失败并抛出一个异常 (an AssertionError)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保这个变量不为空值.</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保这个变量小于 100.</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保它是一个 https 协议类型的 URL.</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(‘https’));</span><br></pre></td></tr></table></figure><p>⚠️注意：assert 语句仅仅只能在调试模式下使用，在生产模式下没有任何作用。</p><p>要将消息附加到断言，添加一个字符串作为第二个参数，当第一个参数为 false 时第二个参数会随错误一起抛出</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">'https'</span>), <span class="string">'URL ($urlString) should start with "https".'</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常 Exception"></a>异常 Exception</h2><h3 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h3><p>抛出了一个异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FormatException(<span class="string">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></figure><p>也可以将任意对象作为异常抛出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">'Out of llamas!'</span>;</span><br></pre></td></tr></table></figure><p>因为抛出异常的语句是个表达式，所以可以写在箭头函数里：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distanceTo(Point other) =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> UnimplementedError();</span><br></pre></td></tr></table></figure><h3 id="on-catch-语句"><a href="#on-catch-语句" class="headerlink" title="on catch 语句"></a>on catch 语句</h3><p>捕获一个异常:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了处理含有多种类型异常的代码，你可以选择多个 catch 子句。第一个匹配抛出对象类型的 catch 子句将会处理这个异常。如果 catch 子句未说明所捕获的异常类型，这个子句就可处理任何被抛出的对象:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// 一个具体异常</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 任意一个异常</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: $e'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e，s) &#123;</span><br><span class="line">  <span class="comment">// 非具体类型</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Exception details:\n $e'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Stack trace:\n $s'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch() 可以带两个参数，第二个参数代表堆栈跟踪 <a href="https://api.dartlang.org/stable/dart-core/StackTrace-class.html" target="_blank" rel="noopener">stack trace</a>。</p><p>要处理部分异常，同时允许它传播，可以使用 rethrow 关键字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> foo = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo = <span class="string">"You can't change a final variable's value."</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'main() finished handling <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子输出两条 print 语句，如果去掉 rethrow 则只输出第一个 print 语句</p><h3 id="finally-语句"><a href="#finally-语句" class="headerlink" title="finally 语句"></a>finally 语句</h3><p>如果没有 catch 匹配子句的异常， finally 子句运行以后异常将被传播：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 即使抛出一个异常时也会进行清理</span></span><br><span class="line">  cleanLlamaStalls();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Error: $e'</span>);  <span class="comment">// 先处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanLlamaStalls();  <span class="comment">// 然后清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      A Tour of the Dart Language
    
    </summary>
    
      <category term="Dart" scheme="https://blog.wangriyu.wang/categories/Dart/"/>
    
    
      <category term="dart" scheme="https://blog.wangriyu.wang/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Mac 快速入门操作指南</title>
    <link href="https://blog.wangriyu.wang/2017/10-MacSkills.html"/>
    <id>https://blog.wangriyu.wang/2017/10-MacSkills.html</id>
    <published>2017-10-14T16:00:00.000Z</published>
    <updated>2018-05-22T02:48:08.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OS X 测试版本 Mac Sierra 10.12.4，测试机型 Mac Air</p></blockquote><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>键盘符号说明<br><img alt="image" src="https://src.wangriyu.wang/images/blog/mac/mac_keyboard.jpg" width="650px" height="900px"></p><p>系统设置 <code>system preferences &gt; keyboard &gt; shortcuts</code> 下有很多自定义快捷键设置，每个人都可以根据自己的喜好修改，熟悉以下的操作将会大大提高生产力，提升效率</p><h3 id="修改输入法切换的快捷方式"><a href="#修改输入法切换的快捷方式" class="headerlink" title="修改输入法切换的快捷方式"></a>修改输入法切换的快捷方式</h3><p>依次打开系统设置 <code>system preferences &gt; keyboard &gt; shortcuts &gt; input sources</code>，然后勾选其中的 select next source in input menu 选项，然后输入你想要的快捷键组合，这就是输入法切换快捷键了。我的是 <code>option + space</code> 切换输入法，cmd + space 用来打开 Alfred。</p><h3 id="关闭-spotlight"><a href="#关闭-spotlight" class="headerlink" title="关闭 spotlight"></a>关闭 spotlight</h3><p>推荐用 Alfred 代替自带的 spotlight 应用，所以可以把 spotlight 关掉然后把 cmd + space 快捷键设置成 Alfred<br>进入 <code>system preferences &gt; keyboard &gt; shortcuts &gt; spotlight</code> 取消 spotlight 选项</p><h3 id="删除字符的快捷方式"><a href="#删除字符的快捷方式" class="headerlink" title="删除字符的快捷方式"></a>删除字符的快捷方式</h3><p>这个和 windows 有点不同，windows 中是用 backspace 键来删除光标左侧字符，用 delete 键来删除光标右侧字符。而在 Mac 中，是用 delete 键来删除光标左侧字符。如果要删除光标右侧字符的话，则需要使用 fn + delete。在 Mac 中，可以使用 CMD + delete 来删除光标左侧的整行文字。</p><h3 id="光标和翻页的快捷方式"><a href="#光标和翻页的快捷方式" class="headerlink" title="光标和翻页的快捷方式"></a>光标和翻页的快捷方式</h3><p>以下快捷键加上 Shift 键可以选中文字：</p><ul><li>CMD + 下箭头，可以快速定位到一篇文章的末尾，在浏览器中可以快速拉到底部</li><li>CMD + 上箭头，可以快速定位到一篇文章的开头，在浏览器中可以快速回到顶部</li><li>CMD + 左箭头（也可以 Control + A 或者 Option + 上箭头），可以快速定位到一行的行首</li><li>CMD + 右箭头（也可以 Control + E 或者 Option + 下箭头），可以快速定位到一行的行末</li><li>Option + 左箭头，跳到当前单词的开头</li><li>Option + 右箭头，跳到当前单词的末尾</li><li>Control + N，跳至下一行</li><li>Control + P，跳至上一行</li></ul><p>文本编辑中的光标移动，也适用于命令行</p><ul><li>Control + F (Forward): 光标右移</li><li>Control + B (Backward): 光标左移</li><li>Control + P (Previous): 光标上移</li><li>Control + N (Next): 光标下移</li><li>Control + A : 光标移至段落头部（Move to the Beginning of the Paragraph）</li><li>Control + E (End): 光标移至段落尾部（Move to the End of the Paragraph）</li></ul><p>文本编辑</p><ul><li>Control + H : 移除光标左一字符</li><li>Control + D (Delete): 移除光标右一字符</li><li>Control + K : 移除光标右侧内容，至段落结束（Delete to the End of the Paragraph）</li><li>Control + O : 在光标处换行，相当于回车键（Split the Current Line）</li><li>Control + T (Transpose): 交换光标前后一字符位置（Transpose Letters）</li></ul><p>组合按键</p><ul><li>Control + AK: 移除光标所在行（Clear Current Line）</li><li>Control + EK: 与后一行合并（Join Lines）</li></ul><h3 id="程序相关的快捷键"><a href="#程序相关的快捷键" class="headerlink" title="程序相关的快捷键"></a>程序相关的快捷键</h3><ul><li>CMD + q，快速退出程序进程</li><li>CMD + w，关闭当前页面，相当于按窗口左上角的红色叉，但是该程序的进程并没有退出</li><li>CMD + tab，可以在当前打开进程的程序中进行切换</li><li>CMD + h，可以隐藏当前的应用程序</li><li>CMD + 逗号， 可以打开当前应用程序的偏好设置</li></ul><h3 id="强制退出的快捷键"><a href="#强制退出的快捷键" class="headerlink" title="强制退出的快捷键"></a>强制退出的快捷键</h3><p>如果 Mac 中的某个程序运行出现异常，需要强制退出，可以按下的快捷键 Option + CMD + ESC，这时系统会弹出一个 force quit application 的窗口，选中需要强制退出的程序，点击 force quit 键即可。也可以在 Dock 栏右键要关闭的程序，再长按 option 键会出现 <code>force quit</code> 和 <code>hide others</code> 选项</p><h3 id="窗口相关的快捷键"><a href="#窗口相关的快捷键" class="headerlink" title="窗口相关的快捷键"></a>窗口相关的快捷键</h3><ul><li>CMD + n，建立一个新窗口</li><li>CMD + `(反引号，数字 1 旁边)，在打开的程序窗口之间进行切换</li><li>CMD + m，可以最小化当前窗口</li><li>CMD + t，建立一个新签标</li><li>control + 左右方向键（←→）切换桌面</li><li>Option + cmd + 左右方向键（←→）在浏览器中切换标签</li><li>control + ↑：mission control</li><li>control + ↓：application control</li><li>F11：显示桌面，mac air 要 fn + F11</li></ul><h3 id="手动整理状态栏图标"><a href="#手动整理状态栏图标" class="headerlink" title="手动整理状态栏图标"></a>手动整理状态栏图标</h3><p>按住 ‘⌘’ 键左右拖动状态栏图标</p><h3 id="截图相关的快捷键"><a href="#截图相关的快捷键" class="headerlink" title="截图相关的快捷键"></a>截图相关的快捷键</h3><p>可以在 <code>system preferences &gt; keyboard &gt; shortcuts &gt; screen shots</code> 中修改</p><ul><li>CMD + Shift + 3，对整个屏幕进行截图，并且保存在桌面</li><li>CMD + Shift + 4，用鼠标划定一个范围，会对该范围进行截图并且保存在桌面</li><li>CMD + Shift + 4，鼠标不动，按空格键，会对当前操作的窗口进行截图并且保存在桌面</li><li>CMD + Shift + Control + 4，类似于以上 CMD + Shift + 4 的两类操作，只不过其截图是保存在剪切板上，不在桌面上，可以后续将其贴在 page 等文档中</li></ul><h3 id="声音相关的快捷键"><a href="#声音相关的快捷键" class="headerlink" title="声音相关的快捷键"></a>声音相关的快捷键</h3><ul><li>Mac 自带了多种的系统语音，可以分别识别各国的语言，发出各国的语音。</li></ul><p>在 <code>system preferences &gt; accessibility &gt; speech &gt; system voice</code> 中可以选择各国的语音了。</p><p>在弹出框到最下方，有一个 speak selected text when the key is pressed 的选项，这就表示当你选中某个文本的时候，以下的快捷键可以实现对该文本的发音。默认的快捷键是：Option + esc。</p><ul><li>按住「⌥ + ⇧」，再按功能键调节音量可以实现四分之一为单位调整</li></ul><h3 id="隐藏-Dock-栏的快捷键"><a href="#隐藏-Dock-栏的快捷键" class="headerlink" title="隐藏 Dock 栏的快捷键"></a>隐藏 Dock 栏的快捷键</h3><p>按下 <code>Option + CMD + d</code>，可以隐藏 dock 栏，此时如果把鼠标移动到 dock 栏原先所在位置，dock 栏会重新出现在下方，待鼠标移走后，dock 栏又重新隐藏。再次按下 Option + CMD + d，dock 栏重新恢复到正常的显示状态。</p><h3 id="Option-妙用"><a href="#Option-妙用" class="headerlink" title="Option 妙用"></a>Option 妙用</h3><p>Option 和其他一些按键同时作用时，常常发挥出很多神奇的作用</p><ul><li>Option + CMD + h，如果当前桌面上同时打开了好多个程序，这个快捷键可以隐藏当前应用程序外的其他应用程序。如果只是 Option + h 只隐藏当前程序</li><li>Option + CMD + v，可以实现对一个已复制文件的移动，类似于 windows 中对文件的剪切黏贴效果</li><li>Option + CMD + w，可以关闭 safari 下除当前 tab 外的所有其他 tab，或者关闭某 app 相关的所有窗口。比如当你选中一批文件，按下 CMD + i 后，会弹出所有选中文件的 info 窗口，这时候就可以按 Option + CMD + w 将全部 info 窗口关闭</li><li>Option + CMD + i，可以用于选中好几个文件的场合，来看所有文件整合的 info 消息及所有文件占据空间的大小总和</li><li>打开 launchpad，按下 Option 键，所有 app 都会颤抖，和 iphone 中的状况是一样的。这时候按颤抖 app 上的✖️，即可卸载该 app。仅适用于 app store 上下载的 app 的卸载</li><li>选择 dock 栏上打开的程序，按下右键弹出菜单后，再按下 Option 键，这时就发现菜单栏倒数两项分别从 hide，quit 变化为 hide others 和 force quit</li><li>在 safari 中，如果按下 CMD + Option + q 退出 safari，那么再次打开 Safari 的话，会发现之前打开的网址全部被保留了下来。但是如果是以 CMD + q 的方式退出 safari，就没有这个保留网址的效果了</li><li>Option + 点击 Dock 上的图标，可打开此程序或文件夹所在的目录。</li></ul><h3 id="屏幕取词"><a href="#屏幕取词" class="headerlink" title="屏幕取词"></a>屏幕取词</h3><p>可以用 Control + CMD + d 来实现屏幕取词的功能。作用与三指点击取词的手势操作一样。</p><h3 id="Finder-快捷键"><a href="#Finder-快捷键" class="headerlink" title="Finder 快捷键"></a>Finder 快捷键</h3><p><img src="https://src.wangriyu.wang/images/blog/mac/finder.png" alt="image"></p><ul><li>CMD(⌘) + Delete 将选择的文件删除到垃圾箱</li><li>CMD + z 撤销操作，包括复制粘贴删除</li><li>选中文件再按空格键 打开快速查看窗口</li><li>选中文件再回车 重命名</li><li>CMD(⌘) + N 新打开一个 Finder 窗口</li><li>CMD(⌘) + Shift(⇧) + N 新建一个文件夹</li><li>CMD(⌘) + I 显示文件 / 文件夹简介</li><li>CMD(⌘) + A 全选</li><li>CMD(⌘) + Option(⌥) + A 取消全选</li><li>CMD + Shift + 句号 (.)<code>可以显示隐藏文件、文件夹</code>，再按一次，恢复隐藏</li><li>CMD + Shift + G，可以跳转指定路径</li><li>CMD + Shift + C，可以复制当前文件路径</li><li>CMD + Shift + P，可以打开预览窗口</li><li>CMD + Shift + T，可以打开导航栏，跟浏览器一样</li><li>CMD + /，可以打开底部状态栏</li><li>Option + CMD + P，可以打开底部路径栏</li><li>Option + CMD + S，可以隐藏左侧栏</li><li>CMD + 上下键跳转父子目录</li><li>按住 CMD+ Option+ 拖动文件，可快速“制作替身”</li><li>Option + 双击文件夹，强制本窗口打开文件夹</li><li>CMD + 双击文件夹，强制新窗口打开文件夹</li></ul><h3 id="快速切换目录"><a href="#快速切换目录" class="headerlink" title="快速切换目录"></a>快速切换目录</h3><p>在 OS X 下，可以在终端中以 cd ~ 的方式进入用户目录。</p><p>如果是在 Finder 里，可以按 CMD + Shift + h，快速切换到用户目录。<br>CMD + Shift + d，快速切换到桌面目录。<br>CMD + Shift + o，快速切换到 Documents 目录。</p><p>其他的快速切换在菜单栏 Go 中</p><h3 id="在-MAC-中输入特殊字符"><a href="#在-MAC-中输入特殊字符" class="headerlink" title="在 MAC 中输入特殊字符"></a>在 MAC 中输入特殊字符</h3><p>option + 各个键都有特定的一个字符，option + shift + 各个键也有特殊的字符</p><p>苹果标志 （Shift + Option + K）<br>Copyright © (Option + G)<br>美元 $ (Shift + 4)<br>美分 ￠ (Option + 4)<br>英镑 ￡ （Option + 3)<br>日元 ￥(Option + Y)<br>欧元 €（Shift + Option + 2)<br>破折号 –(Option + -)<br>约等于 ≈（Option + X)<br>度 °(Shift + Option + 8)<br>除号 ÷（Option + /)<br>循环 ∞（Option + 5）<br>小于等于≤（Option + ,)<br>大于等于≥（Option + .)<br>不等于≠（Option + =）<br>Pi π（Option + P）<br>正负号 ±(Shift + Option + =)<br>平方根√（Option + V)<br>求和 ∑（option + w）<br>产品标识 ™（Option + 2)<br>®(Option + r)</p><p>快捷键 <code>control + cmd + space</code> 打开系统自带的符号面板，可以选择特殊字符输入，比如 cmd⌘、option⌥、control⌃、shift⇧、caps lock⇪、delete⌫、arrow↑→↓←等</p><h3 id="Finder-设置"><a href="#Finder-设置" class="headerlink" title="Finder 设置"></a>Finder 设置</h3><ul><li>显示隐藏文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder</span><br></pre></td></tr></table></figure><p>将 true 改为 false 恢复隐藏</p><ul><li>在顶部显示绝对路径，右键绝对路径前的图标可以切换父目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES</span><br></pre></td></tr></table></figure><p>将 yes 换为 no 还原</p><ul><li>底部地址栏从用户开始，默认是显示“MacHD/Users/clown/Downloads”，修改后显示“clown/Downloads”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder PathBarRootAtHome -bool TRUE;killall Finder</span><br></pre></td></tr></table></figure><p>将 true 改为 false 还原</p><h3 id="Terminal-常用命令"><a href="#Terminal-常用命令" class="headerlink" title="Terminal 常用命令"></a>Terminal 常用命令</h3><ul><li><p><code>pwd</code> 显示当前路径</p></li><li><p><code>which 库名</code> 查看安装目录，比如 <code>which go</code> 输出 /usr/local/go/bin/go</p></li><li><p><code>cd 路径</code> 跳转，支持绝对路径和相对路径 ./ 和 ../</p></li><li><p><code>mkdir 文件名</code> 新建文件夹</p></li><li><p><code>rmdir 文件名</code> 删除目录</p></li><li><p><code>mvdir</code> 移动目录</p></li><li><p><code>cat + 文件</code> 预览文件</p></li><li><p><code>ls 参数 路径</code> 列出文件，<code>ls -l -A -h</code> 显示当前路径详细信息文件列表</p></li><li><p><code>cp 参数 源文件 目标文件</code> 拷贝文件，<code>cp -R ./Downloads/* ~/Desktop</code> 表示将 Downloads 下所有文件拷贝到桌面，-R 表示递归操作，源文件是文件夹时需要</p></li><li><p><code>rm 参数 文件</code> 删除文件，参数－rf 表示递归和强制，文件夹需要 -r 参数，-i 参数表示删除前要确认</p></li><li><p><code>mv 文件 路径</code> 移动文件</p></li><li><p><code>file 文件</code> 显示文件类型</p></li><li><p><code>open 文件</code> 用默认工具打开文件</p></li><li><p><code>touch 文件名</code> 更改文件的时间信息（可以用 <code>stat 文件</code> 查看），如果文件不存在会创建一个新的空文件，常用于创建新文件</p></li><li><p><code>vi 文件名</code> 编辑文件，如果文件不存在就新建一个并打开文件，在 vi 编辑器中输入“:wq”保存更改并退出，推荐用 vim 代替 vi</p></li><li><p><code>find</code> 查询文件，<code>find 目录 -type f|wc -l</code> 统计文件数，<code>find 目录 -type d|wc -l</code> 统计目录数，<code>find . -name &quot;*.js&quot; -print</code> 查询 js 格式的文件</p></li><li><p><code>date</code> 显示系统时间</p></li><li><p><code>cal</code> 显示日历</p></li><li><p><code>time 程序</code> 统计程序的执行时间，比如 time a.out</p></li><li><p><code>telnet</code> 远程登录</p></li><li><p><code>clear</code> 清除窗口内容</p></li><li><p><code>env</code> 显示当前所有设置过的环境变量</p></li><li><p><code>du</code> 查询磁盘使用情况，<code>du -sh 目录</code> 统计目录大小</p></li><li><p><code>df</code> 显示文件系统的总空间和可用空间, <code>df -h /</code> 显示硬盘使用情况</p></li><li><p><code>history</code> 列出最近执行过的 几条命令及编号</p></li><li><p><code>alias</code> 给某个命令定义别名，比如 <code>alias del=rm -i</code></p></li><li><p><code>top</code> 显示进程信息</p></li><li><p><code>kill 进程</code> 终止进程<br>……</p></li></ul><p>更多参看：[mac 终端命令大全介绍]<a href="https://www.douban.com/note/75797151/" target="_blank" rel="noopener">https://www.douban.com/note/75797151/</a></p><h3 id="介绍-Alfred"><a href="#介绍-Alfred" class="headerlink" title="介绍 Alfred"></a>介绍 Alfred</h3><p>前面提到了 Alfred，现在介绍一下如何使用它，使用教程网上都有，我就不赘述了，这里贴上一篇 <a href="http://wellsnake.com/jekyll/update/2014/06/15/001/" target="_blank" rel="noopener">丢掉鼠标－Mac 神软 Alfred 使用手册</a></p><p>我的设置如下</p><ul><li>热键：我设置的热键是 <code>cmd + space</code>，刚好代替系统自带的 spotlight</li><li>Default Results：勾上书签，支持搜索 Safari 的书签，但我用的是 Chrome，可以把书签导入到 Safari 中即可；Search Scope 设置 Alfred 查询时会遍历的文件夹，在这里可以自己添加经常访问的和删除不必要文件夹</li><li>Web Search：经常用到的功能，把自己常用的网站设置快捷键，像 google 搜索只要在 Alfred 中输入 <code>gg 搜索的内容</code> 即可，给自己的博客添加快捷键 blog 等等<br><img src="https://src.wangriyu.wang/images/blog/artifact/websearch.png" alt="images"></li><li>关联 terminal，直接在 Alfred 中输入 <code>&gt; 命令</code> 执行</li><li>workflow：我用的有 Chrome Bookmarks、Dash 和有道词典翻译，功能分别是搜索 Chrome 书签、<code>Dash 搜索内容</code> 打开 Dash 中的 API 介绍，<code>yd 待翻译内容</code> 显示翻译，其他 workflow 可以到网站 <a href="http://www.packal.org" target="_blank" rel="noopener">http://www.packal.org</a> 和 <a href="https://www.alfredapp.com/workflows" target="_blank" rel="noopener">https://www.alfredapp.com/workflows</a> 上看看</li><li>remote：远程控制电脑<br><img src="https://src.wangriyu.wang/images/blog/mac/bookmarks.png" alt="image"></li></ul><p>完成设置后，之后几乎所有事都可以快捷键 cmd + space 打开 Alfred 解决，打开应用、搜索文件、执行命令、跳转网页、翻译、计算等等</p><h2 id="手势操作"><a href="#手势操作" class="headerlink" title="手势操作"></a>手势操作</h2><p>如果只是快捷键的话，windows 也有，没什么很特别的，mac 的优势之一就是它的触控板了，所以接下来介绍如何用好手势操作</p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>打开系统设置 <code>system preferences &gt; Trackpad</code>，看介绍选择自己喜欢的操作，<br>我推荐把四指切换桌面选上，平时切换桌面会方便很多；<br>还有三指上划显示 Mission Control 选上，方便切换任务、整理桌面</p><h3 id="设置-Hot-Corner"><a href="#设置-Hot-Corner" class="headerlink" title="设置 Hot Corner"></a>设置 Hot Corner</h3><p>打开 <code>system preferences &gt; Mission Control</code>，点击底部 Hot Corner，设置鼠标移入四个角时的操作，比如我的<br><img src="https://src.wangriyu.wang/images/blog/mac/hotcorner.png" alt="image"></p><p>鼠标移入右下角息屏，右上角显示桌面，很方便，是我使用很多的功能</p><h3 id="添加手势扩展"><a href="#添加手势扩展" class="headerlink" title="添加手势扩展"></a>添加手势扩展</h3><p>推荐两个软件：<a href="http://www.jitouch.com/" target="_blank" rel="noopener">Jitouch</a> 和 <a href="https://www.boastr.net/" target="_blank" rel="noopener">BetterTouchTool</a></p><p>bettertouch 比 jitouch 更强大，支持的东西更多，但收费而且设置也会更复杂一点，对我来说 jitouch 已经够用，如果你喜欢折腾就去试下 bettertouch</p><p>安装好后设置自己喜欢的手势，比如我的<br><img src="https://src.wangriyu.wang/images/blog/artifact/jitouch1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/artifact/jitouch2.png" alt="image"></p><p>使用手势时要注意两指的距离，设置里可以调，但不要太近，太近容易跟滚动冲突，我推荐用食指和无名指划字。</p><p>我也试了下 buttertouch，它支持自定义手势，可选择的 action 也比 jitouch 多很多，但要注意一点，设置手势后还要设置一个快捷键选择 record gesture，然后每次操作先按这个快捷键出现可划动区域再划手势，其实这点没有 jitouch 好用。</p><h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h2><p>这节主要跟 terminal 有关，terminal 这也是 mac 另一大优势</p><p>推荐安装 oh my zsh 和 iTerm2，提升 terminal 的使用效率和逼格指数</p><h3 id="Oh-My-ZSH"><a href="#Oh-My-ZSH" class="headerlink" title="Oh My ZSH"></a>Oh My ZSH</h3><p><a href="http://ohmyz.sh/" title=" 点击访问 " target="_blank" rel="noopener">oh my zsh</a> is an open source, community-driven framework for managing your ZSH configuration. It comes bundled with a ton of helpful functions, helpers, plugins, themes, and a few things that make you shout…</p><ul><li>安装 oh my zsh 后默认 bash 改为 zsh，配置文件变为 <code>~/.zshrc</code>，通过 oh my zsh 可以很方便地安装主题、安装插件等。</li><li>zsh 的命令补全功能非常强大，可以补齐路径，补齐命令，补齐参数等。按下 tab 键显示出所有待选项后，再按一次 tab 键，即进入选择模式，进入选择模式后，按 tab 切向下一个选项，按 shift+tab 键切向上一个选项，ctrl+f/b/n/p 可以向前后左右切换。</li><li>之前杀进程是 <code>ps aux | grep xxx</code> 查进程的 PID，然后 kill -9 PID。在 zsh 中直接 kill xxx 然后按下 tab 键即可。也可以直接 <code>kill 空格 tab 键</code> 列出所有进程</li><li>建议加个主题再换个字体，设置一下颜色，逼格立马提高<br><img src="https://src.wangriyu.wang/images/blog/mac/terminal3.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/mac/terminal7.png" alt="image"></li><li>推荐插件 zsh-syntax-highlighting(指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮)、z、git 等等，查看官方插件地址 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins</a></li><li>zsh 的目录跳转更为智能，你无需输入 cd，直接输入路径即可。.. 表示后退一级目录，../../ 表示后退两级，依次类推。<br>输入 d，将列出当前 session 访问过的所有目录，再按提示的数字即可进入相应目录。</li><li>zsh 的历史记录跨 session，可以共享。历史记录支持受限查找。比如，输入 git，再按向上箭头，会搜索用过的所有 git 命令。</li><li>通配符搜索: <code>ls *.png</code> 查找当前目录下所有 png 文件，<code>ls **/*.png</code> 递归查找，作用与 <code>find . -name &quot;*.png&quot; -print</code> 一样</li><li>递归操作：<code>**/*</code> ，比如 <code>ls **/*</code></li></ul><h3 id="VIM-快捷鍵"><a href="#VIM-快捷鍵" class="headerlink" title="VIM 快捷鍵"></a>VIM 快捷鍵</h3><ol><li>按 ESC 进入普通模式:</li></ol><ul><li>k 将光标上移一行</li><li>j 将光标下移一行</li><li>h 将光标左移一个字母</li><li>l 将光标右移一个字母</li><li>w 将光标右移至下一个单词或符号的开头（字母和数字组成的词）</li><li>W 将光标右移至下一个单词或符号的开头（以空格分隔的词）</li><li>b 将光标左移至当前单词或符号的开头（字母和数字组成的词）</li><li>B 将光标左移至当前单词或符号的开头（以空格分隔的词）</li><li>e 将光标左移至当前单词或符号的结尾（字母和数字组成的词）</li><li>E 将光标左移至当前单词或符号的结尾（以空格分隔的词）</li></ul><blockquote><p>数字加 jkhlwb 可以移动多行或字母，比如 nk 上移 n 行</p></blockquote><ul><li>J 合并当前行和下一行 (也可以加数字操作多行)</li><li>H 将光标移至当前可视范围的第一行</li><li>L 将光标移至当前可视范围的最后一行</li><li>0 将光标移至该行行首</li><li>$ 将光标移至该行行尾</li><li>nG 将光标移至第 n 行</li><li>G 将光标移至文件的最后一行</li><li>gg 将光标移至文件的第一行</li><li>{ 将光标移至上一段</li><li>} 将光标移至下一段</li><li>[[ 将光标移至文件首行</li><li>]] 将光标移至文件尾行</li></ul><p><strong>删除:</strong></p><ul><li>dd 删除光标所在的整行内容 (可以加数字删除多行)</li><li>d$ 删除从光标所在位置直到行尾</li><li>d^ 删除从光标所在位置直到行首</li><li>d) 删除从光标所在位置直到句尾</li><li>d0 删除从光标所在位置直到行首</li><li>dw 删除从光标所在位置直到下一个词开始的所有内容</li><li>x 删除光标后一字符</li><li>X 删除光标前一字符</li><li>dgg 删至文件开头</li><li>dG 删至文件末尾</li></ul><p><strong>复制粘贴:</strong></p><ul><li>yy 复制当前行 (可以加数字复制多行)</li><li>p 在光标之后粘贴复制行</li><li>P 在光标之前粘贴复制行</li></ul><p><strong>替换:</strong></p><ul><li>r{text} 将光标处的字符替换成 {text}</li><li>R 进入覆写模式 (REPLACE)，输入的字符将替换原有的字符</li></ul><p><strong>撤销:</strong></p><ul><li>u 撤销一个操作 (可以加数字撤销多个操作)</li><li>Ctrl+r 恢复上一步被撤销的操作 (取消撤销)</li></ul><p><strong>搜索:</strong></p><ul><li>:/{search_text} 检索文档，搜索光标之后出现的 {search_text}</li><li>?{search_text} 检索文档，搜索光标之前出现的 {search_text}</li><li>n 向后移动检索结果</li><li>N 向前移动检索结果</li><li>:%s/original/replacement 检索第一个 “original” 字符串并将其替换成 “replacement”</li><li>:%s/original/replacement/g 检索并将所有的 “original” 替换为 “replacement”</li><li>:%s/original/replacement/gc 检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换</li></ul><ol start="2"><li>从普通模式进入编辑模式 (INSERT):</li></ol><ul><li>i 在当前光标位置之前插入内容</li><li>I 在光标所在行的行首插入内容</li><li>a 在当前光标位置之后插入内容</li><li>A 在光标所在行的行尾插入内容</li><li>o 在当前光标所在行之后添加一行</li><li>O 在当前光标所在行之前添加一行</li></ul><ol start="3"><li>从普通模式进入视图模式 (VISUAL):</li></ol><ul><li>v 进入逐字可视模式</li><li>V 进入逐行可视模式</li></ul><p><strong>在视图模式中:</strong></p><ul><li>移动光标 (←↑↓→) 选中操作范围</li><li>~ 切换大小写</li><li>d 剪切选中字符</li><li>y 复制选中字符</li></ul><ol start="4"><li>窗口操作:</li></ol><ul><li>:split 水平方向分割出一个窗口</li><li>:split otherfile 新建窗口打开另一个文件</li><li>:sview filename 以只读的方式水平分割打开一个新窗口</li><li>:vsplit 垂直方向分割出一个窗口</li><li>:close 关闭窗口</li><li>ctrl + w + w 切换窗口</li></ul><ol start="5"><li>退出 vim</li></ol><ul><li>:q 退出 Vim，如果文件已被修改，将退出失败</li><li>:w 保存文件</li><li>:w new_name 用 new_name 作为文件名保存为新文件 (原文件仍在)</li><li>:wq 保存文件并退出 Vim</li><li>:q! 退出 Vim，不保存文件改动</li><li>ZZ 退出 Vim，如果文件被改动过，保存改动内容</li><li>ZQ 与 :q! 相同，退出 Vim，不保存文件改动</li></ul><p>在线演示 vim 操作: <a href="http://www.openvim.com/" target="_blank" rel="noopener">http://www.openvim.com/</a></p><h3 id="VIM-配置"><a href="#VIM-配置" class="headerlink" title="VIM 配置"></a>VIM 配置</h3><p>编辑 <code>~/.vimrc</code> 文件，添加相应项开启相应功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&quot; 显示行号</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 在状态行上显示光标所在位置的行号和列号</span><br><span class="line">set ruler</span><br><span class="line">set rulerformat=%20(%2*%&lt;%f%=\ %m%r\ %3l\ %c\ %p%%%)</span><br><span class="line"></span><br><span class="line">&quot; 允许折叠</span><br><span class="line">set foldenable</span><br><span class="line"></span><br><span class="line">&quot; 手动折叠</span><br><span class="line">set foldmethod=manual</span><br><span class="line"></span><br><span class="line">&quot; 命令行（在状态行下）的高度，默认为 1，这里是 2</span><br><span class="line">set cmdheight=2</span><br><span class="line"></span><br><span class="line">&quot; 使回格键（backspace）正常处理 indent, eol, start 等</span><br><span class="line">set backspace=2</span><br><span class="line"></span><br><span class="line">&quot; 通过使用: commands 命令，告诉我们文件的哪一行被改变过</span><br><span class="line">set report=0</span><br><span class="line"></span><br><span class="line">&quot; 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line"></span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line"></span><br><span class="line">&quot; 不让 vim 发出讨厌的滴滴声</span><br><span class="line">set noerrorbells</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 在搜索的时候忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 在搜索时，输入的词句的逐字符高亮（类似 firefox 的搜索）</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 继承前一行的缩进方式，特别适用于多行注释</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 制表符为 4</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 统一缩进为 4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot; 不要换行</span><br><span class="line">set nowrap</span><br></pre></td></tr></table></figure><p>推荐一个很好的 vim 配置库: <a href="https://github.com/spf13/spf13-vim" target="_blank" rel="noopener">https://github.com/spf13/spf13-vim</a></p><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p><a href="http://www.iterm2.com/" title=" 点击访问 " target="_blank" rel="noopener">iTerm2</a> 是代替原本的 terminal 工具，支持更多操作，<a href="http://wulfric.me/2015/08/iterm2/" target="_blank" rel="noopener">设置教程</a></p><ul><li><p>主题配色可以去 <a href="http://iterm2colorschemes.com/" target="_blank" rel="noopener">iterm2colorschemes.com</a> 找，我用的是 <code>idleToes</code></p></li><li><p>快捷键：<br><code>⌘ + Click</code>：可以打开文件，文件夹和链接<br><code>⌘ + n</code>：新建窗口<br><code>⌘ + t</code>：新建标签页<br><code>⌘ + w</code>：关闭当前页<br><code>⌘ + 数字 &amp; ⌘ + 方向键</code>：切换标签页<br><code>⌥⌘ + 数字</code>：切换窗口<br><code>⌘ + enter</code>：切换全屏<br><code>⌘ + d</code>：左右分屏<br><code>⇧⌘ + d</code>：上下分屏<br><code>⌘ + ;</code>：自动补全历史记录<br><code>⇧⌘ + h</code>：自动补全剪贴板历史<br><code>⌥⌘ + e</code>：查找所有来定位某个标签页<br><code>⌘ + r &amp; ⌃ + l</code>：清屏 (等同于输入 <code>clear</code> 命令和 <code>⌘ + K</code>)<br><code>⌘ + /</code>：显示光标位置<br><code>⌥⌘ + b</code>：历史回放<br><code>⌘ + f</code>：查找，然后用 tab 和 ⇧ + tab 可以向右和向左补全，补全之后的内容会被自动复制，还可以用 ⌥ + enter 将查找结果输入终端选中即复制，鼠标中键粘贴</p></li><li><p>命令行快捷键<br><code>⌃ + u</code>：清空当前行<br><code>⌃ + a</code>：移动到行首<br><code>⌃ + e</code>：移动到行尾<br><code>⌃ + r</code>：搜索历史命令<br><code>⌃ + y</code>：召回最近用命令删除的文字<br><code>⌃ + h</code>：删除光标之前的字符<br><code>⌃ + d</code>：删除光标所指的字符<br><code>⌃ + w</code>：删除光标之前的单词<br><code>⌃ + k</code>：删除从光标到行尾的内容<br><code>⌃ + t</code>：交换光标和之前的字符</p></li><li><p>iTerm2 参考设置<br><img src="https://src.wangriyu.wang/images/blog/mac/terminal4.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/mac/terminal5.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/mac/terminal6.png" alt="image"></p></li><li><p>关闭向上滚动到头时的提示音：<code>Preferences/Profiles/Terminal/Notifications</code> 选中 <code>Silence bell</code></p></li></ul><p><img src="https://src.wangriyu.wang/images/blog/mac/terminal1.png" alt="image"><br><img src="https://src.wangriyu.wang/images/blog/mac/terminal2.png" alt="image"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>命令行设置大全：<a href="https://github.com/herrbischoff/awesome-osx-command-line" target="_blank" rel="noopener">https://github.com/herrbischoff/awesome-osx-command-line</a></p></li><li><p>允许安装任何来源的软件。从网上下载的安装包安装的应用一般是打不开的，macOS Sierra 之后的版本把“安全性与隐私”中的允许“任何来源”的选项去除了。<br>若要安装第三方软件需要恢复该选项：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo spctl --master-disable</span><br></pre></td></tr></table></figure><ul><li>替换 vi 为 vim</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install vim --with-lua --with-override-system-vi</span><br></pre></td></tr></table></figure><p>更新 vim</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew upgrade vim</span><br></pre></td></tr></table></figure><p>查看 vim 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew info vim</span><br></pre></td></tr></table></figure><p>使用还是 <code>vi</code> 加文件名</p><ul><li>txt 中文乱码</li></ul><p>打开系统文本编辑器 TextEditor 的设置界面，修改 <code>Plain Text File Encoding</code> 的 <code>Opening files</code> 选项，选择 <code>Chinese(GB 18030)</code><br><img src="https://src.wangriyu.wang/images/blog/mac/texteditor.png" alt="image"></p><ul><li>在 Dock 中显示最近打开的应用（Recent Applications）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock persistent-others -array-add &apos;&#123;&quot;tile-data&quot; = &#123;&quot;list-type&quot; = 1;&#125;; &quot;tile-type&quot; = &quot;recents-tile&quot;; &#125;&apos;</span><br><span class="line"></span><br><span class="line">killall -KILL Dock</span><br></pre></td></tr></table></figure><ul><li>Launchpad 里放下更多图标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-columns -int 8; defaults write com.apple.dock springboard-rows -int 7; defaults write com.apple.dock ResetLaunchPad -bool TRUE; killall Dock</span><br></pre></td></tr></table></figure><p>命令中有两个数字 8 和 7，它们分别代表的是布局中的列数和行数</p><ul><li>Launchpad 背景透明度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-blur-radius -int 100; killall Dock</span><br></pre></td></tr></table></figure><p>其中数字 100 代表的背景模糊的程度，你可以在 0 ~ 255 的范围内选择</p><ul><li>homebrew 用法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 支持搜索，提供多种结果，如果只是单个应用名，你可以用 `brew install 命令行应用 ` 直接安装 (一般是命令行工具)</span><br><span class="line">// 名字前带着 cask 的代表 app 应用也就是平时使用的有图形化界面的应用，它们需要换个命令来安装 `brew cask install GUI 应用 `</span><br><span class="line">$ brew search 应用名（一般需英文名）</span><br><span class="line"></span><br><span class="line">// 查看是否由更新</span><br><span class="line">$ brew outdated</span><br><span class="line"></span><br><span class="line">// 更新所有，可以使用 `brew upgrade 应用名 ` 更新单个应用</span><br><span class="line">$ brew upgrade</span><br><span class="line"></span><br><span class="line">// 更新完后删除旧版和缓存，`brew cleanup -n` 只查看有哪些条目但不删除，`brew cleanup 应用名 ` 清除单应用</span><br><span class="line">$ brew cleanup</span><br><span class="line"></span><br><span class="line">// 访问应用官网，`brew cask home sketch` 访问 app 应用类的官网</span><br><span class="line">$ brew home 应用名</span><br></pre></td></tr></table></figure><ul><li>增强文件预览</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook suspicious-package quicklookase qlvideo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      熟悉这些操作可以大大提高效率，解放双手
    
    </summary>
    
      <category term="Mac" scheme="https://blog.wangriyu.wang/categories/Mac/"/>
    
    
      <category term="分享" scheme="https://blog.wangriyu.wang/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="技巧" scheme="https://blog.wangriyu.wang/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
