<!DOCTYPE html><html lang="zh-Hans"><head><!--[if IE]><style>body{display:none;}</style><script>alert('IE浏览器下无法展示效果，请更换浏览器！');var headNode=document.getElementsByTagName('head')[0];var refresh=document.createElement('meta');refresh.setAttribute('http-equiv','Refresh');refresh.setAttribute('Content','0; url=http://outdatedbrowser.com/');headNode.appendChild(refresh);</script><![endif]--><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="鱼乐"><meta name="shenma-site-verification" content="cd3048846de29809263b063b8e307624_1527169631"><meta name="360-site-verification" content="2d95e707197a9f8b2936ef16f299d4ee"><meta name="sogou_site_verification" content="ZdMIkaFR8c"><meta name="description" content="秉着 WTF(What the hell is That, Find the answers!) 原则探究 HTTP2，结合理论与实践，广度与深度并存"><meta name="keywords" content="http 扩展阅读,网络"><meta property="og:type" content="article"><meta property="og:title" content="HTTP2 详解"><meta property="og:url" content="https://blog.wangriyu.wang/2018/05-HTTP2.html"><meta property="og:site_name" content="Wangriyu’s Blog"><meta property="og:description" content="秉着 WTF(What the hell is That, Find the answers!) 原则探究 HTTP2，结合理论与实践，广度与深度并存"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:image" content="https://blog.wangriyu.wang/img/loading.gif"><meta property="og:updated_time" content="2018-12-22T05:31:45.468Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="HTTP2 详解"><meta name="twitter:description" content="秉着 WTF(What the hell is That, Find the answers!) 原则探究 HTTP2，结合理论与实践，广度与深度并存"><meta name="twitter:image" content="https://blog.wangriyu.wang/img/loading.gif"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="shortcut icon" href="/favicon.ico"><link href="//src.wangriyu.wang/lib/fancybox/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><title>HTTP2 详解 | Wangriyu’s Blog</title><script src="//src.wangriyu.wang/lib/jquery/jquery.min.js"></script><link href="//src.wangriyu.wang/lib/font-awesome/css/font-awesome.min.css" rel="stylesheet"><script src="//src.wangriyu.wang/lib/aos/aos.js"></script><script>var yiliaConfig={fancybox:!0,isHome:!1,isPost:!0,isArchive:!1,isTag:!1,isCategory:!1,fancybox_js:"//src.wangriyu.wang/lib/fancybox/jquery.fancybox.min.js",search:!0}</script><script>yiliaConfig.jquery_ui=[!1]</script><script>yiliaConfig.rootUrl="/"</script><link rel="stylesheet" href="/css/prism-a11y-dark.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-a11y-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head></html><body><div id="container"><div class="left-col"><div class="backImg"><img src="//src.wangriyu.wang/images/blog/yule.jpg" width="312" height="330px"></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="//src.wangriyu.wang/images/blog/avatar.jpg"></a><hgroup><h1 class="header-author"><a href="/">鱼乐</a></h1></hgroup><p class="header-subtitle">子非鱼，安知鱼之乐也！</p><form id="search-form"><input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <i class="fa fa-times" onclick="resetSearch()"></i></form><div id="local-search-result"></div><p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p><div id="switch-btn" class="switch-btn"><div class="icon"><div class="icon-ctn"><div class="icon-wrap icon-house" data-idx="0"><div class="birdhouse"></div><div class="birdhouse_holes"></div></div><div class="icon-wrap icon-ribbon hide" data-idx="1"><div class="ribbon"></div></div><div class="icon-wrap icon-link hide" data-idx="2"><div class="loopback_l"></div><div class="loopback_r"></div></div><div class="icon-wrap icon-me hide" data-idx="3"><div class="user"></div><div class="shoulder"></div></div></div></div><div class="tips-box hide"><div class="tips-arrow"></div><ul class="tips-inner"><li>菜单</li><li>标签</li><li>友情链接</li><li>目标</li></ul></div></div><div id="switch-area" class="switch-area"><div class="switch-wrap"><section class="switch-part switch-part1"><nav class="header-menu"><ul><li><a href="//home.wangriyu.wang">主页</a></li><li><a href="/archives/">归档</a></li><li><a href="/pages/waterFallAlbum">相册</a></li><li><a href="/about/">简历</a></li><li><a href="/tags/">标签云</a></li></ul></nav><nav class="header-nav"><ul class="social"><a class="fa 掘金" href="https://juejin.im/user/58c3744bda2f605609683d66" title="掘金"></a> <a class="fa GitHub" href="https://github.com/wangriyu" title="GitHub"></a> <a class="fa RSS" href="/atom.xml" title="RSS"></a> <a class="fa 知乎" href="https://www.zhihu.com/people/clownduo/activities" title="知乎"></a> <a class="fa 网易云音乐" href="https://music.163.com/#/user/home?id=102244407" title="网易云音乐"></a> <a class="fa jianshu" href="https://www.jianshu.com/u/7a8c5ba0b316" title="jianshu"></a> <a class="fa Facebook" href="https://www.facebook.com/riyu.wang.7" title="Facebook"></a> <a class="fa Twitter" href="https://twitter.com/wangriyu" title="Twitter"></a></ul><ul class="social"><div style="position:absolute;top:95%;left:50%;margin-left:-28px"><p style="display:block"><a class="donateIcon" href="javascript:void(0)" onmouseout='var qr=document.getElementById("donate");qr.style.display="none"' onmouseenter='var qr=document.getElementById("donate");qr.style.display="block"'>赏</a></p><div id="donate"><img id="multipay" src="//src.wangriyu.wang/images/blog/multipay.png" width="250px" alt="鱼乐 Multipay"><div class="triangle"></div></div></div></ul></nav></section><section class="switch-part switch-part2"><div class="widget tagcloud" id="js-tagcloud"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aplayer/">Aplayer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CGO/">CGO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Copy/">Copy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ELK/">ELK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Log/">Log</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-存储扩展/">Mac 存储扩展</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UEFI-GPT/">UEFI&GPT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yelee/">Yelee</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dart/">dart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-源码/">go 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-扩展阅读/">http 扩展阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaScript/">javaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libc/">libc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/masm/">masm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextcloud/">nextcloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rEFInd-引导美化/">rEFInd 引导美化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/root/">root</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/win10-Ubuntu-双系统/">win10&Ubuntu 双系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/三阶段提交/">三阶段提交</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/两阶段提交/">两阶段提交</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人网盘/">个人网盘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分享/">分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式理论/">分布式理论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/刷机/">刷机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈希/">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/应用/">应用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧/">技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树/">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器本地存储/">浏览器本地存储</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入理解计算机/">深入理解计算机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li></ul></div></section><section class="switch-part switch-part3"><div id="js-friends"><a class="main-nav-link switch-friends-link" href="https://github.com/TechCatsLab">TechCatsLab</a> <a class="main-nav-link switch-friends-link" href="https://yangchenglong11.github.io">YangChengLong</a> <a class="main-nav-link switch-friends-link" href="https://jsharkc.github.io">LiuJiaChang</a> <a class="main-nav-link switch-friends-link" href="http://blog.yusank.space">YusanKurban</a> <a class="main-nav-link switch-friends-link" href="https://blog.lizebang.top">Lizebang</a> <a class="main-nav-link switch-friends-link" href="https://github.com/sunanxiang">SunAnXiang</a> <a class="main-nav-link switch-friends-link" href="https://github.com/DoubleWoodH">LinHao</a> <a class="main-nav-link switch-friends-link" href="https://blog.littlechao.top">ShiChao</a> <a class="main-nav-link switch-friends-link" href="https://github.com/Txiaozhe">TangXiaoJi</a> <a class="main-nav-link switch-friends-link" href="https://github.com/LLLeon">JiaChenHui</a></div></section><section class="switch-part switch-part4"><div id="js-aboutme">不悲不喜，不卑不亢，努力成为一个更好的程序猿！</div></section></div></div></header></div></div><div class="hide-left-col" title="隐藏侧栏"><i class="fa fa-angle-double-left"></i></div><div class="mid-col"><nav id="mobile-nav"><div class="overlay"><div class="slider-trigger"></div><h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">鱼乐</a></h1></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="//src.wangriyu.wang/images/blog/avatar.jpg"></a><hgroup><h1 class="header-author"><a href="/" title="回到主页">鱼乐</a></h1></hgroup><p class="header-subtitle">子非鱼，安知鱼之乐也！</p><nav class="header-menu"><ul><li><a href="//home.wangriyu.wang">主页</a></li><li><a href="/archives/">归档</a></li><li><a href="/pages/waterFallAlbum">相册</a></li><li><a href="/about/">简历</a></li><li><a href="/tags/">标签云</a></li><div class="clearfix"></div></ul></nav><nav class="header-nav"><ul class="social"><a class="fa 掘金" target="_blank" href="https://juejin.im/user/58c3744bda2f605609683d66" title="掘金"></a> <a class="fa GitHub" target="_blank" href="https://github.com/wangriyu" title="GitHub"></a> <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a> <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/clownduo/activities" title="知乎"></a> <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=102244407" title="网易云音乐"></a> <a class="fa jianshu" target="_blank" href="https://www.jianshu.com/u/7a8c5ba0b316" title="jianshu"></a> <a class="fa Facebook" target="_blank" href="https://www.facebook.com/riyu.wang.7" title="Facebook"></a> <a class="fa Twitter" target="_blank" href="https://twitter.com/wangriyu" title="Twitter"></a></ul></nav></header></div><link class="menu-list" tags="标签" friends="友情链接" about="目标"></nav><div class="body-wrap"><article id="post-HTTP2" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/05-HTTP2.html" class="article-date"><time class="published" datetime="2018-05-18T16:00:00.000Z" itemprop="datePublished">2018-05-19 发布</time> <time class="updated" datetime="2018-12-22T05:31:45.468Z" itemprop="dateUpdated">2018-12-22 更新</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 class="article-title" itemprop="name">HTTP2 详解</h1></header><div class="article-info article-info-post"><div class="article-count"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/http/">http</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http-扩展阅读/">http 扩展阅读</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul></div><span class="post-count">总字数19,149</span> <span class="post-count">预计阅读72分钟</span></div><div class="clearfix"></div></div><div class="article-entry" itemprop="articleBody"><p>维基百科关于 HTTP/2 的介绍，可以看下定义和发展历史:</p><p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">Wiki</a></p><p>RFC 7540 定义了 HTTP/2 的协议规范和细节，本文的细节主要来自此文档，建议先看一遍本文，再回过头来照着协议大致过一遍 RFC，如果想深入某些细节再仔细翻看 RFC</p><p><a href="https://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">RFC7540</a></p><h2 id="Why-use-it"><a href="#Why-use-it" class="headerlink" title="Why use it ?"></a>Why use it ?</h2><h3 id="HTTP-1-1-存在的问题"><a href="#HTTP-1-1-存在的问题" class="headerlink" title="HTTP/1.1 存在的问题:"></a>HTTP/1.1 存在的问题:</h3><p>1、<strong>TCP 连接数限制</strong></p><p>对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接 (不同浏览器不一样)。为了解决数量限制，出现了 <code>域名分片</code> 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)，这样就可以针对不同域名创建连接并请求，以一种讨巧的方式突破限制，但是滥用此技术也会造成很多问题，比如每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存，对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等，对于移动端来说问题更明显，可以参考这篇文章: <a href="http://dev.mobify.com/blog/domain-sharding-bad-news-mobile-performance/" target="_blank" rel="noopener">Why Domain Sharding is Bad News for Mobile Performance and Users</a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/HOLB-1.png" title="image" data-fancybox="images" data-caption="HOLB-1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/HOLB-1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/HOLB-2.png" title="image" data-fancybox="images" data-caption="HOLB-2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/HOLB-2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>在图中可以看到新建了六个 TCP 连接，每次新建连接 DNS 解析需要时间(几 ms 到几百 ms 不等)、TCP 慢启动也需要时间、TLS 握手又要时间，而且后续请求都要等待队列调度</p><p>2、<strong><a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">线头阻塞 (Head Of Line Blocking)</a> 问题</strong></p><p>每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。为了解决此问题，出现了 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">管线化 - pipelining</a> 技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化</p><p>3、Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</p><p>4、为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</p><p>5、明文传输不安全</p><h3 id="HTTP2-的优势"><a href="#HTTP2-的优势" class="headerlink" title="HTTP2 的优势:"></a>HTTP2 的优势:</h3><h4 id="1、二进制分帧层-Binary-Framing-Layer"><a href="#1、二进制分帧层-Binary-Framing-Layer" class="headerlink" title="1、二进制分帧层 (Binary Framing Layer)"></a>1、二进制分帧层 (Binary Framing Layer)</h4><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/http2-frame.png" title="image" data-fancybox="images" data-caption="http2-frame.png"><img data-original="https://src.wangriyu.wang/images/blog/http/http2-frame.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>h1 和 h2 的报文对比:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/h1-message.png" title="image" data-fancybox="images" data-caption="h1-message.png"><img data-original="https://src.wangriyu.wang/images/blog/http/h1-message.png" src="/img/loading.gif" title="image" alt="image"></a><br><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/h2-message.png" title="image" data-fancybox="images" data-caption="h2-message.png"><img data-original="https://src.wangriyu.wang/images/blog/http/h2-message.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>图中 h2 的报文是重组解析过后的，可以发现一些头字段发生了变化，而且所有头字段均小写</p><blockquote><p><code>strict-transport-security: max-age=63072000; includeSubdomains</code> 字段是服务器开启 <a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">HSTS 策略</a>，让浏览器强制使用 HTTPS 进行通信，可以减少重定向造成的额外请求和会话劫持的风险</p></blockquote><blockquote><p>服务器开启 HSTS 的方法是: 以 nginx 为例，在相应站点的 server 模块中添加 <code>add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains&quot; always;</code> 即可</p></blockquote><blockquote><p>在 Chrome 中可以打开 <code>chrome://net-internals/#hsts</code> 进入浏览器的 HSTS 管理界面，可以增加 / 删除 / 查询 HSTS 记录，比如下图:</p></blockquote><blockquote><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/HSTS.png" title="image" data-fancybox="images" data-caption="HSTS.png"><img data-original="https://src.wangriyu.wang/images/blog/http/HSTS.png" src="/img/loading.gif" title="image" alt="image"></a></p></blockquote><blockquote><p>在 HSTS 有效期内且 TLS 证书仍有效，浏览器访问 blog.wangriyu.wang 会自动加上 https:// ，而不需要做一次查询重定向到 https</p></blockquote><p>关于帧详见: <a href="#帧-Frame">How does it work ？- 帧</a></p><h4 id="2、多路复用-MultiPlexing"><a href="#2、多路复用-MultiPlexing" class="headerlink" title="2、多路复用 (MultiPlexing)"></a>2、多路复用 (MultiPlexing)</h4><p>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。<br>把 HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP/2 中的多路复用。</p><p>流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题</p><p>所以 http2 对于同一域名只需要创建一个连接，而不是像 http/1.1 那样创建 6~8 个连接:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/ConnectionView-h1.png" title="image" data-fancybox="images" data-caption="ConnectionView-h1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/ConnectionView-h1.png" src="/img/loading.gif" title="image" alt="image"></a><br><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/ConnectionView-h2.png" title="image" data-fancybox="images" data-caption="ConnectionView-h2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/ConnectionView-h2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>关于流详见: <a href="#流-Stream">How does it work ？- 流</a></p><h4 id="3、服务端推送-Server-Push"><a href="#3、服务端推送-Server-Push" class="headerlink" title="3、服务端推送 (Server Push)"></a>3、服务端推送 (Server Push)</h4><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p><p>Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul><p>关于服务端推送详见: <a href="#Server-Push">How does it work ？- Server-Push</a></p><h4 id="4、Header-压缩-HPACK"><a href="#4、Header-压缩-HPACK" class="headerlink" title="4、Header 压缩 (HPACK)"></a>4、Header 压缩 (HPACK)</h4><p>使用 <a href="https://httpwg.org/specs/rfc7541.html" target="_blank" rel="noopener">HPACK</a> 算法来压缩首部内容</p><p>关于 HPACK 详见: <a href="#HPACK-算法">How does it work ？- HPACK</a></p><h4 id="5、应用层的重置连接"><a href="#5、应用层的重置连接" class="headerlink" title="5、应用层的重置连接"></a>5、应用层的重置连接</h4><p>对于 HTTP/1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p><h4 id="6、请求优先级设置"><a href="#6、请求优先级设置" class="headerlink" title="6、请求优先级设置"></a>6、请求优先级设置</h4><p>HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p><h4 id="7、流量控制"><a href="#7、流量控制" class="headerlink" title="7、流量控制"></a>7、流量控制</h4><p>每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p><p>关于流量控制详见: <a href="#流量控制">How does it work ？- 流量控制</a></p><h4 id="8、HTTP-1-的几种优化可以弃用"><a href="#8、HTTP-1-的几种优化可以弃用" class="headerlink" title="8、HTTP/1 的几种优化可以弃用"></a>8、HTTP/1 的几种优化可以弃用</h4><p>合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多</p><h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work ?"></a>How does it work ?</h2><h3 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧 - Frame"></a>帧 - Frame</h3><h4 id="帧的结构"><a href="#帧的结构" class="headerlink" title="帧的结构"></a>帧的结构</h4><p>所有帧都是一个固定的 9 字节头部 (payload 之前) 跟一个指定长度的负载 (payload):</p><pre class="line-numbers language-http"><code class="language-http">+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Length</code> 代表整个 frame 的长度，用一个 24 位无符号整数表示。除非接收者在 SETTINGS_MAX_FRAME_SIZE 设置了更大的值 (大小可以是 2^14(16384) 字节到 2^24-1(16777215) 字节之间的任意值)，否则数据长度不应超过 2^14(16384) 字节。头部的 9 字节不算在这个长度里</li><li><code>Type</code> 定义 frame 的类型，用 8 bits 表示。帧类型决定了帧主体的格式和语义，如果 type 为 unknown 应该忽略或抛弃。</li><li><code>Flags</code> 是为帧类型相关而预留的布尔标识。标识对于不同的帧类型赋予了不同的语义。如果该标识对于某种帧类型没有定义语义，则它必须被忽略且发送的时候应该赋值为 (0x0)</li><li><code>R</code> 是一个保留的比特位。这个比特的语义没有定义，发送时它必须被设置为 (0x0), 接收时需要忽略。</li><li><a href="https://httpwg.org/specs/rfc7540.html#StreamIdentifiers" target="_blank" rel="noopener">Stream Identifier</a> 用作流控制，用 31 位无符号整数表示。客户端建立的 sid 必须为奇数，服务端建立的 sid 必须为偶数，值 (0x0) 保留给与整个连接相关联的帧 (连接控制消息)，而不是单个流</li><li><code>Frame Payload</code> 是主体内容，由帧类型决定</li></ul><p>共分为十种类型的帧:</p><ul><li><code>HEADERS</code>: 报头帧 (type=0x1)，用来打开一个流或者携带一个首部块片段</li><li><code>DATA</code>: 数据帧 (type=0x0)，装填主体信息，可以用一个或多个 DATA 帧来返回一个请求的响应主体</li><li><code>PRIORITY</code>: 优先级帧 (type=0x2)，指定发送者建议的流优先级，可以在任何流状态下发送 PRIORITY 帧，包括空闲 (idle) 和关闭 (closed) 的流</li><li><code>RST_STREAM</code>: 流终止帧 (type=0x3)，用来请求取消一个流，或者表示发生了一个错误，payload 带有一个 32 位无符号整数的错误码 (<a href="https://httpwg.org/specs/rfc7540.html#ErrorCodes" target="_blank" rel="noopener">Error Codes</a>)，不能在处于空闲 (idle) 状态的流上发送 RST_STREAM 帧</li><li><code>SETTINGS</code>: 设置帧 (type=0x4)，设置此 <code>连接</code> 的参数，作用于整个连接</li><li><code>PUSH_PROMISE</code>: 推送帧 (type=0x5)，服务端推送，客户端可以返回一个 RST_STREAM 帧来选择拒绝推送的流</li><li><code>PING</code>: PING 帧 (type=0x6)，判断一个空闲的连接是否仍然可用，也可以测量最小往返时间 (RTT)</li><li><code>GOAWAY</code>: GOWAY 帧 (type=0x7)，用于发起关闭连接的请求，或者警示严重错误。GOAWAY 会停止接收新流，并且关闭连接前会处理完先前建立的流</li><li><code>WINDOW_UPDATE</code>: 窗口更新帧 (type=0x8)，用于执行流量控制功能，可以作用在单独某个流上 (指定具体 Stream Identifier) 也可以作用整个连接 (Stream Identifier 为 0x0)，只有 DATA 帧受流量控制影响。初始化流量窗口后，发送多少负载，流量窗口就减少多少，如果流量窗口不足就无法发送，WINDOW_UPDATE 帧可以增加流量窗口大小</li><li><code>CONTINUATION</code>: 延续帧 (type=0x9)，用于继续传送首部块片段序列，见 <a href="#首部的压缩与解压缩">首部的压缩与解压缩</a></li></ul><h4 id="DATA-帧格式"><a href="#DATA-帧格式" class="headerlink" title="DATA 帧格式"></a>DATA 帧格式</h4><pre class="line-numbers language-http"><code class="language-http"> +---------------+
 |Pad Length? (8)|
 +---------------+-----------------------------------------------+
 |                            Data (*)                         ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Pad Length</code>: ? 表示此字段的出现时有条件的，需要设置相应标识 (set flag)，指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>Data</code>: 传递的数据，其长度上限等于帧的 payload 长度减去其他出现的字段长度</li><li><code>Padding</code>: 填充字节，没有具体语义，发送时必须设为 0，作用是混淆报文长度，与 TLS 中 CBC 块加密类似，详见 <a href="https://httpwg.org/specs/rfc7540.html#padding" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html#padding</a></li></ul><p>DATA 帧有如下标识 (flags):</p><ul><li>END_STREAM: bit 0 设为 1 代表当前流的最后一帧</li><li>PADDED: bit 3 设为 1 代表存在 Padding</li></ul><p>例子:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/DATA-Frame1.png" title="image" data-fancybox="images" data-caption="DATA-Frame1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/DATA-Frame1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/DATA-Frame2.png" title="image" data-fancybox="images" data-caption="DATA-Frame2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/DATA-Frame2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/DATA-Frame3.png" title="image" data-fancybox="images" data-caption="DATA-Frame3.png"><img data-original="https://src.wangriyu.wang/images/blog/http/DATA-Frame3.png" src="/img/loading.gif" title="image" alt="image"></a></p><h4 id="HEADERS-帧格式"><a href="#HEADERS-帧格式" class="headerlink" title="HEADERS 帧格式"></a>HEADERS 帧格式</h4><pre class="line-numbers language-http"><code class="language-http"> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |E|                 Stream Dependency? (31)                     |
 +-+-------------+-----------------------------------------------+
 |  Weight? (8)  |
 +-+-------------+-----------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>E</code>: 一个比特位声明流的依赖性是否是排他的，存在则代表 PRIORITY flag 被设置</li><li><code>Stream Dependency</code>: 指定一个 stream identifier，代表当前流所依赖的流的 id，存在则代表 PRIORITY flag 被设置</li><li><code>Weight</code>: 一个无符号 8 为整数，代表当前流的优先级权重值 (1~256)，存在则代表 PRIORITY flag 被设置</li><li><code>Header Block Fragment</code>: header 块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul><p>HEADERS 帧有以下标识 (flags):</p><ul><li>END_STREAM: bit 0 设为 1 代表当前 header 块是发送的最后一块，但是带有 END_STREAM 标识的 HEADERS 帧后面还可以跟 CONTINUATION 帧 (这里可以把 CONTINUATION 看作 HEADERS 的一部分)</li><li>END_HEADERS: bit 2 设为 1 代表 header 块结束</li><li>PADDED: bit 3 设为 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li><li>PRIORITY: bit 5 设为 1 表示存在 Exclusive Flag (E), Stream Dependency, 和 Weight</li></ul><p>例子:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/HEADERS-Frame.png" title="image" data-fancybox="images" data-caption="HEADERS-Frame.png"><img data-original="https://src.wangriyu.wang/images/blog/http/HEADERS-Frame.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/HEADERS-Response.png" title="image" data-fancybox="images" data-caption="HEADERS-Response.png"><img data-original="https://src.wangriyu.wang/images/blog/http/HEADERS-Response.png" src="/img/loading.gif" title="image" alt="image"></a></p><h4 id="首部的压缩与解压缩"><a href="#首部的压缩与解压缩" class="headerlink" title="首部的压缩与解压缩"></a>首部的压缩与解压缩</h4><p>HTTP/2 里的首部字段也是一个键具有一个或多个值。这些首部字段用于 HTTP 请求和响应消息，也用于服务端推送操作。</p><p>首部列表 (Header List) 是零个或多个首部字段 (Header Field) 的集合。当通过连接传送时，首部列表通过压缩算法(即下文 HPACK) 序列化成首部块 (Header Block)。然后，序列化的首部块又被划分成一个或多个叫做首部块片段 (Header Block Fragment) 的字节序列，并通过 HEADERS、PUSH_PROMISE，或者 CONTINUATION 帧进行有效负载传送。</p><blockquote><p>Cookie 首部字段需要 HTTP 映射特殊对待，见 <a href="https://httpwg.org/specs/rfc7540.html#CompressCookie" target="_blank" rel="noopener">8.1.2.5. Compressing the Cookie Header Field</a></p></blockquote><p>一个完整的首部块有两种可能</p><ul><li>一个 HEADERS 帧或 PUSH_PROMISE 帧加上设置 END_HEADERS flag</li><li>一个未设置 END_HEADERS flag 的 HEADERS 帧或 PUSH_PROMISE 帧，加上多个 CONTINUATION 帧，其中最后一个 CONTINUATION 帧设置 END_HEADERS flag</li></ul><p>必须将首部块作为连续的帧序列传送，不能插入任何其他类型或其他流的帧。尾帧设置 END_HEADERS 标识代表首部块结束，这让首部块在逻辑上等价于一个单独的帧。接收端连接片段重组首部块，然后解压首部块重建首部列表。</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/End-Stream.png" title="image" data-fancybox="images" data-caption="End-Stream.png"><img data-original="https://src.wangriyu.wang/images/blog/http/End-Stream.png" src="/img/loading.gif" title="image" alt="image"></a></p><h4 id="SETTINGS-帧格式"><a href="#SETTINGS-帧格式" class="headerlink" title="SETTINGS 帧格式"></a>SETTINGS 帧格式</h4><p><a href="https://httpwg.org/specs/rfc7540.html#SETTINGS" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html#SETTINGS</a></p><p>一个 SETTINGS 帧的 payload 由零个或多个参数组成，每个参数的形式如下:</p><pre class="line-numbers language-http"><code class="language-http"> +-------------------------------+
 |       Identifier (16)         |
 +-------------------------------+-------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Identifier</code>: 代表参数类型，比如 SETTINGS_HEADER_TABLE_SIZE 是 0x1</li><li><code>Value</code>: 相应参数的值</li></ul><p>在建立连接开始时双方都要发送 SETTINGS 帧以表明自己期许对方应做的配置，对方接收后同意配置参数便返回带有 ACK 标识的空 SETTINGS 帧表示确认，而且连接后任意时刻任意一方也都可能再发送 SETTINGS 帧调整，SETTINGS 帧中的参数会被最新接收到的参数覆盖</p><p>SETTINGS 帧作用于整个连接，而不是某个流，而且 SETTINGS 帧的 stream identifier 必须是 0x0，否则接收方会认为错误 (PROTOCOL_ERROR)。</p><p>SETTINGS 帧包含以下参数:</p><ul><li>SETTINGS_HEADER_TABLE_SIZE (0x1): 用于解析 Header block 的 Header 压缩表的大小，初始值是 4096 字节</li><li>SETTINGS_ENABLE_PUSH (0x2): 可以关闭 Server Push，该值初始为 1，表示允许服务端推送功能</li><li>SETTINGS_MAX_CONCURRENT_STREAMS (0x3): 代表发送端允许接收端创建的最大流数目</li><li>SETTINGS_INITIAL_WINDOW_SIZE (0x4): 指明发送端所有流的流量控制窗口的初始大小，会影响所有流，该初始值是 2^16 - 1(65535) 字节，最大值是 2^31 - 1，如果超出最大值则会返回 FLOW_CONTROL_ERROR</li><li>SETTINGS_MAX_FRAME_SIZE (0x5): 指明发送端允许接收的最大帧负载的字节数，初始值是 2^14(16384) 字节，如果该值不在初始值 (2^14) 和最大值 (2^24 - 1) 之间，返回 PROTOCOL_ERROR</li><li>SETTINGS_MAX_HEADER_LIST_SIZE (0x6): 通知对端，发送端准备接收的首部列表大小的最大字节数。该值是基于未压缩的首部域大小，包括名称和值的字节长度，外加每个首部域的 32 字节的开销</li></ul><p>SETTINGS 帧有以下标识 (flags):</p><ul><li>ACK: bit 0 设为 1 代表已接收到对方的 SETTINGS 请求并同意设置，设置此标志的 SETTINGS 帧 payload 必须为空</li></ul><p>例子:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/SETTINGS-Frame.png" title="image" data-fancybox="images" data-caption="SETTINGS-Frame.png"><img data-original="https://src.wangriyu.wang/images/blog/http/SETTINGS-Frame.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>实际抓包会发现 HTTP2 请求创建连接发送 SETTINGS 帧初始化前还有一个 Magic 帧 (建立 HTTP/2 请求的前言)。</p><p>在 HTTP/2 中，要求两端都要发送一个连接前言，作为对所使用协议的最终确认，并确定 HTTP/2 连接的初始设置，客户端和服务端各自发送不同的连接前言。</p><p>客户端的前言内容 (对应上图中编号 23 的帧) 包含一个内容为 <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code> 的序列加上一个可以为空的 SETTINGS 帧，在收到 101(Switching Protocols) 响应 (代表 upgrade 成功) 后发送，或者作为 TLS 连接的第一个传输的应用数据。如果在预先知道服务端支持 HTTP/2 的情况下启用 HTTP/2 连接，客户端连接前言在连接建立时发送。</p><p>服务端的前言 (对应上图中编号 26 的帧) 包含一个可以为空的 SETTINGS 帧，在建立 HTTP/2 连接后作为第一帧发送。详见 <a href="https://httpwg.org/specs/rfc7540.html#ConnectionHeader" target="_blank" rel="noopener">HTTP/2 Connection Preface</a></p><p>发送完前言后双方都得向对方发送带有 ACK 标识的 SETTINGS 帧表示确认，对应上图中编号 29 和 31 的帧。</p><p>请求站点的全部帧序列，帧后面的数字代表所属流的 id，最后以 GOAWAY 帧关闭连接:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/All-Frame.png" title="image" data-fancybox="images" data-caption="All-Frame.png"><img data-original="https://src.wangriyu.wang/images/blog/http/All-Frame.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>GOAWAY 帧带有最大的那个流标识符 (比如图中第 29 帧是最大流)，对于发送方来说会继续处理完不大于此数字的流，然后再真正关闭连接</p><h3 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 - Stream"></a>流 - Stream</h3><p>流只是一个逻辑上的概念，代表 HTTP/2 连接中在客户端和服务器之间交换的独立双向帧序列，每个帧的 Stream Identifier 字段指明了它属于哪个流。</p><p>流有以下特性:</p><ul><li>单个 h2 连接可以包含多个并发的流，两端之间可以交叉发送不同流的帧</li><li>流可以由客户端或服务器来单方面地建立和使用，或者共享</li><li>流可以由任一方关闭</li><li>帧在流上发送的顺序非常重要，最后接收方会把相同 Stream Identifier (同一个流) 的帧重新组装成完整消息报文</li></ul><h4 id="流的状态"><a href="#流的状态" class="headerlink" title="流的状态"></a>流的状态</h4><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/stream-state.png" title="image" data-fancybox="images" data-caption="stream-state.png"><img data-original="https://src.wangriyu.wang/images/blog/http/stream-state.png" src="/img/loading.gif" title="image" alt="image"></a></p><blockquote><p>注意图中的 send 和 recv 对象是指端点，不是指当前的流</p></blockquote><h5 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h5><p>所有流以“空闲”状态开始。在这种状态下，没有任何帧的交换</p><p>其状态转换:</p><ul><li>发送或者接收一个 HEADERS 帧会使空闲 <code>idle</code> 流变成打开 <code>open</code> 状态，其中 HEADERS 帧的 Stream Identifier 字段指明了流 id。同样的 HEADERS 帧(带有 END_STREAM )也可以使一个流立即进入 half-closed 状态。</li><li>服务端必须在一个打开 <code>open</code> 或者半关闭 (远端) <code>half-closed(remote)</code> 状态的流 (由客户端发起的) 上发送 PUSH_PROMISE 帧，其中 PUSH_PROMISE 帧的 Promised Stream ID 字段指定了一个预示的新流 (由服务端发起)，<ul><li>在服务端该新流会由空闲 <code>idle</code> 状态进入被保留的 (本地) <code>reserved(local)</code> 状态</li><li>在客户端该新流会由空闲 <code>idle</code> 状态进入被保留的 (远端) <code>reserved(remote)</code> 状态</li></ul></li></ul><blockquote><p>在 <a href="https://httpwg.org/specs/rfc7540.html#discover-http" target="_blank" rel="noopener">3.2 - Starting HTTP/2 for “http” URIs</a> 中介绍了一种特殊情况:</p><blockquote><p>客户端发起一个 HTTP/1.1 请求，请求带有 Upgrade 机制，想创建 h2c 连接，服务端同意升级返回 101 响应。<br>升级之前发送的 HTTP/1.1 请求被分配一个流标识符 0x1，并被赋予默认优先级值。从客户端到服务端这个流 1 隐式地转为 “half-closed” 状态，因为作为 HTTP/1.1 请求它已经完成了。HTTP/2 连接开始后，流 1 用于响应。详细过程可以看下文的 <a href="#HTTP-2-的协议协商机制">HTTP/2 的协议协商机制</a></p></blockquote></blockquote><p>此状态下接收到 HEADERS 和 PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><p>状态图中 <code>send PP</code> 和 <code>recv PP</code> 是指连接的双方端点发送或接收了 PUSH_PROMISE，不是指某个空闲流发送或接收了 PUSH_PROMISE，是 PUSH_PROMISE 的出现促使一个预示的流从 <code>idle</code> 状态转为 <code>reserved</code></p><blockquote><p>在下文 <a href="#Server-Push">Server-Push</a> 中会详细介绍服务端推送的内容和 PUSH_PROMISE 的使用情形</p></blockquote><h5 id="reserved-local-reserved-remote"><a href="#reserved-local-reserved-remote" class="headerlink" title="reserved (local) / reserved (remote)"></a>reserved (local) / reserved (remote)</h5><p>PUSH_PROMISE 预示的流由 <code>idle</code> 状态进入此状态，代表准备进行 Server push</p><p>其状态转换:</p><ul><li>PUSH_PROMISE 帧预示的流的响应以 HEADERS 帧开始，这会立即将该流在服务端置于半关闭 (远端) <code>half-closed(remote)</code> 状态，在客户端置于半关闭 (本地) <code>half-closed(local)</code> 状态，最后以携带 END_STREAM 的帧结束，这会将流置于关闭 <code>closed</code> 状态</li><li>任一端点都可以发送 RST_STREAM 帧来终止这个流，其状态由 <code>reserved</code> 转为 <code>closed</code></li></ul><p><code>reserved(local)</code> 状态下的流不能发送 HEADERS、RST_STREAM、PRIORITY 以外的帧，接收到 RST_STREAM、PRIORITY、WINDOW_UPDATE 以外的帧被视为 PROTOCOL_ERROR</p><p><code>reserved(remote)</code> 状态下的流不能发送 RST_STREAM、WINDOW_UPDATE、PRIORITY 以外的帧，接收到 HEADERS、RST_STREAM、PRIORITY 以外的帧被视为 PROTOCOL_ERROR</p><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>处于 <code>open</code> 状态的流可以被两个对端用来发送任何类型的帧</p><p>其状态转换:</p><ul><li>任一端都可以发送带有 END_STREAM 标识的帧，发送方会转入 <code>half-closed(local)</code> 状态；接收方会转入 <code>half-closed(remote)</code> 状态</li><li>任一端都可以发送 RST_STREAM 帧，这会使流立即进入 <code>closed</code> 状态</li></ul><h5 id="half-closed-local"><a href="#half-closed-local" class="headerlink" title="half-closed (local)"></a>half-closed (local)</h5><p>流是双向的，半关闭表示这个流单向关闭了，local 代表本端到对端的方向关闭了，remote 代表对端到本端的方向关闭了</p><p>此状态下的流不能发送 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧</p><p>当此状态下的流收到带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><p>此状态下的流收到的 PRIORITY 帧用以调整流的依赖关系顺序，可以看下文的流优先级</p><h5 id="half-closed-remote"><a href="#half-closed-remote" class="headerlink" title="half-closed (remote)"></a>half-closed (remote)</h5><p>此状态下的流不会被对端用于发送帧，执行流量控制的端点不再有义务维护接收方的流控制窗口。</p><p>一个端点在此状态的流上接收到 WINDOW_UPDATE、PRIORITY、RST_STREAM 以外的帧，应该响应一个 STREAM_CLOSED 流错误</p><p>此状态下的流可以被端点用于发送任意类型的帧，且此状态下该端点仍会观察流级别的流控制的限制</p><p>当此状态下的流发送带有 END_STREAM 标识的帧或者任一方发送 RST_STREAM 帧，会转为 <code>closed</code> 状态</p><h5 id="closed"><a href="#closed" class="headerlink" title="closed"></a>closed</h5><p>代表流已关闭</p><p>此状态下的流不能发送 PRIORITY 以外的帧，发送 PRIORITY 帧是调整那些依赖这个已关闭的流的流优先级，端点都应该处理 PRIORITY 帧，尽管如果该流从依赖关系树中移除了也可以忽略优先级帧</p><p>此状态下在收到带有 END_STREAM 标识的 DATA 或 HEADERS 帧后的一小段时间内 (period) 仍可能接收到 WINDOW_UPDATE 或 RST_STREAM 帧，因为在远程对端接收并处理 RST_STREAM 或带有 END_STREAM 标志的帧之前，它可能会发送这些类型的帧。但是端点必须忽略接收到的 WINDOW_UPDATE 或 RST_STREAM</p><p>如果一个流发送了 RST_STREAM 帧后转入此状态，而对端接收到 RST_STREAM 帧时可能已经发送了或者处在发送队列中，这些帧是不可撤销的，发送 RST_STREAM 帧的端点必须忽略这些帧。</p><p>一个端点可以限制 period 的长短，在 period 内接受的帧会忽略，超出 period 的帧被视为错误。</p><p>一个端点发送了 RST_STREAM 帧后接收到流控制帧(比如 DATA)，仍会计入流量窗口，即使这些帧会被忽略，因为对端肯定是在接收到 RST_STREAM 帧前发送的流控制帧，对端会认为流控制已生效</p><p>一个端点可能会在发送了 RST_STREAM 帧后收到 PUSH_PROMISE 帧，即便预示的流已经被重置 (reset)，PUSH_PROMISE 帧也能使预示流变成 <code>reserved</code> 状态。因此，需要 RST_STREAM 来关闭一个不想要的预示流。</p><blockquote><p>PRIORITY 帧可以被任意状态的流发送和接收，未知类型的帧会被忽略</p></blockquote><h5 id="流状态的转换"><a href="#流状态的转换" class="headerlink" title="流状态的转换"></a>流状态的转换</h5><p>下面看两个例子来理解流状态:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/ServerPushStreamState.png" title="image" data-fancybox="images" data-caption="ServerPushStreamState.png"><img data-original="https://src.wangriyu.wang/images/blog/http/ServerPushStreamState.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>(1)、Server 在 Client 发起的一个流上发送 PUSH_PROMISE 帧，其 Promised Stream ID 指定一个预示流用于后续推送，send PP 后这个预示流在服务端从 idle 状态转为 reserve(local) 状态，客户端 recv PP 后这个流从 idle 状态转为 reserve(remote) 状态</p><p>(2)(3)、此时预示流处于保留状态，客户端如果选择拒绝接受推送，可以发送 RST 帧关闭这个流；服务端如果此时出问题了也可以发送 RST 帧取消推送。不管哪一方发送或接收到 RST，此状态都转为 closed</p><p>(4)、没有出现重置说明推送仍有效，则服务端开始推送，首先发送的肯定是响应的 HEADERS 首部块，此时流状态转为半关闭 half-closed(remote)；客户端接收到 HEADERS 后流状态转为半关闭 half-closed(local)</p><p>(5)(6)、半关闭状态下的流应该还会继续推送诸如 DATA 帧、CONTINUATION 帧这样的数据帧，如果这个过程碰到任一方发起重置，则流会关闭进入 closed 状态</p><p>(7)、如果一切顺利，资源随着数据帧响应完毕，最后一帧会带上 END_STREAM 标识代表这个流结束了，此时流转为 closed 状态</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/RequestStreamState.png" title="image" data-fancybox="images" data-caption="RequestStreamState.png"><img data-original="https://src.wangriyu.wang/images/blog/http/RequestStreamState.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>(1)、客户端发起请求，首先发送一个 HEADERS 帧，其 Stream Identifier 创建一个新流，此流从 idle 状态转为 open 状态</p><p>(2)(3)、如果客户端取消请求可以发送 RST 帧，服务端出错也可以发送 RST 帧，不管哪一方接收或发送 RST，流关闭进入 closed 状态；</p><p>(4)、如果请求结束(END_STREAM)，流转为半关闭状态。假如是 GET 请求，一般 HEADERS 帧就是最后一帧，send H 后流会立即进入半关闭状态。假如是 POST 请求，待数据传完，最后一帧带上 END_STREAM 标识，流转为半关闭</p><p>(5)(6)、客户端半关闭后服务端开始返回响应，此时任一方接收或发送 RST，流关闭；</p><p>(7)、如果一切顺利，等待响应结束(END_STREAM)，流关闭</p><h4 id="流的标识符"><a href="#流的标识符" class="headerlink" title="流的标识符"></a>流的标识符</h4><p>流 ID 是 31 位无符号整数，客户端发起的流必须是奇数，服务端发起的流必须是偶数，0x0 保留为连接控制消息不能用于建立新流。</p><p>HTTP/1.1 Upgrade to HTTP/2 时响应的流 ID 是 0x1，在升级完成之后，流 0x1 在客户端会转为 <code>half-closed (local)</code> 状态，因此这种情况下客户端不能用 0x1 初始化一个流</p><p>新建立的流的 ID 必须大于所有已使用过的数字，接收到一个错误大小的 ID 应该返回 PROTOCOL_ERROR 响应</p><p>使用一个新流时隐式地关闭了对端发起的 ID 小于当前流的且处于 <code>idle</code> 状态的流，比如一个流发送一个 HEADERS 帧打开了 ID 为 7 的流，但还从未向 ID 为 5 的流发送过帧，则流 0x5 会在 0x7 发送完或接收完第一帧后转为 <code>closed</code> 状态</p><p>一个连接内的流 ID 不能重用</p><h4 id="流的优先级"><a href="#流的优先级" class="headerlink" title="流的优先级"></a>流的优先级</h4><p>客户端可以通过 HEADERS 帧的 PRIORITY 信息指定一个新建立流的优先级，其他期间也可以发送 PRIORITY 帧调整流优先级</p><p>设置优先级的目的是为了让端点表达它所期望对端在并发的多个流之间如何分配资源的行为。更重要的是，当发送容量有限时，可以使用优先级来选择用于发送帧的流。</p><p>流可以被标记为依赖其他流，所依赖的流完成后再处理当前流。每个依赖 (dependency) 后都跟着一个权重 (weight)，这一数字是用来确定依赖于相同的流的可分配可用资源的相对比例</p><h5 id="流依赖-Stream-Dependencies"><a href="#流依赖-Stream-Dependencies" class="headerlink" title="流依赖(Stream Dependencies)"></a>流依赖(Stream Dependencies)</h5><p>每个流都可以显示地依赖另一个流，包含依赖关系表示优先将资源分配给指定的流(上层节点)而不是依赖流</p><p>一个不依赖于其他流的流会指定 stream dependency 为 0x0 值，因为不存在的 0x0 流代表依赖树的根</p><p>一个依赖于其他流的流叫做<strong>依赖流</strong>，被依赖的流是当前流的父级。如果被依赖的流不在当前依赖树中(比如状态为 <code>idle</code> 的流)，被依赖的流会使用一个默认优先级</p><p>当依赖一个流时，该流会添加进父级的依赖关系中，共享相同父级的依赖流不会相对于彼此进行排序，比如 B 和 C 依赖 A，新添加一个依赖流 D，BCD 的顺序是不固定的:</p><pre class="line-numbers language-http"><code class="language-http">    A                 A
   / \      ==>      /|\
  B   C             B D C
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>独占标识 (exclusive) 允许插入一个新层级(新的依赖关系)，独占标识导致该流成为父级的唯一依赖流，而其他依赖流变为其子级，比如同样插入一个新依赖流 E (带有 exclusive):</p><pre class="line-numbers language-http"><code class="language-http">                      A
    A                 |
   /|\      ==>       E
  B D C              /|\
                    B D C
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在依赖关系树中，只有当一个依赖流所依赖的所有流(父级最高为 0x0 的链)被关闭或者无法继续在上面执行，这个依赖流才应该被分配资源</p><h5 id="依赖权重"><a href="#依赖权重" class="headerlink" title="依赖权重"></a>依赖权重</h5><p>所有依赖流都会分配一个 1~256 权重值</p><p>相同父级的依赖流按权重比例分配资源，比如流 B 依赖于 A 且权重值为 4，流 C 依赖于 A 且权重值为 12，当 A 不再执行时，B 理论上能分配的资源只有 C 的三分之一</p><h5 id="优先级调整-Reprioritization"><a href="#优先级调整-Reprioritization" class="headerlink" title="优先级调整 (Reprioritization)"></a>优先级调整 (Reprioritization)</h5><p>使用 PRIORITY 帧可以调整流优先级</p><p>PRIORITY 帧内容与 HEADERS 帧的优先级模块相同:</p><pre class="line-numbers language-http"><code class="language-http"> +-+-------------------------------------------------------------+
 |E|                  Stream Dependency (31)                     |
 +-+-------------+-----------------------------------------------+
 |   Weight (8)  |
 +-+-------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>如果父级重新设置了优先级，则依赖流会随其父级流一起移动。若调整优先级的流带有独占标识，会导致新的父流的所有子级依赖于这个流</p></li><li><p>如果一个流调整为依赖自己的一个子级，则这个将被依赖的子级首先移至调整流的父级之下(即同一层)，再移动那个调整流的整棵子树，移动的依赖关系保持其权重</p></li></ul><p>看下面这个例子: 第一个图是初始关系树，现在 A 要调整为依赖 D，根据第二点，现将 D 移至 x 之下，再把 A 调整为 D 的子树(图 3)，如果 A 调整时带有独占标识根据第一点 F 也归为 A 子级(图 4)</p><pre class="line-numbers language-http"><code class="language-http">    x                x                x                 x
    |               / \               |                 |
    A              D   A              D                 D
   / \            /   / \            / \                |
  B   C     ==>  F   B   C   ==>    F   A       OR      A
     / \                 |             / \             /|\
    D   E                E            B   C           B C F
    |                                     |             |
    F                                     E             E
               (intermediate)   (non-exclusive)    (exclusive)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="流优先级的状态管理"><a href="#流优先级的状态管理" class="headerlink" title="流优先级的状态管理"></a>流优先级的状态管理</h5><p>当一个流从依赖树中移除，它的子级可以调整为依赖被关闭流的父级(应该就是连接上一层节点)，新的依赖权重将根据关闭流的权重以及流自身的权重重新计算。</p><p>从依赖树中移除流会导致某些优先级信息丢失。资源在具有相同父级的流之间共享，这意味着如果这个集合中的某个流关闭或者阻塞，任何空闲容量将分配给最近的相邻流。然而，如果此集合的共有依赖(即父级节点)从树中移除，这些子流将与更上一层的流共享资源</p><p>一个例子: 流 A 和流 B 依赖相同父级节点，而流 C 和流 D 都依赖 A，在移除流 A 之前的一段时间内，A 和 D 都无法执行(可能任务阻塞了)，则 C 会分配到 A 的所有资源；<br>如果 A 被移除出树了，A 的权重按比重新计算分配给 C 和 D，此时 D 仍旧阻塞，C 分配的资源相较之前变少了。对于同等的初始权重，C 获取到的可用资源是三分之一而不是二分之一(为什么是三分之一?文档中没有说明细节，权重如何重新分配也不太清楚，下面是按我的理解解释的)</p><p>X 的资源为 1，ABCD 初始权重均为 16，*号代表节点当前不可用，图一中 C 和 B 各占一半资源，而 A 移除后 CD 的权重重新分配变为 8，所以图二中 C 和 B 占比变为 1:2，R(C) 变为 1/3</p><pre class="line-numbers language-http"><code class="language-http">          X(v:1.0)               X(v:1.0)
         / \                    /|\
        /   \                  / | \
      *A     B       ==>      /  |  \
    (w:16) (w:16)            /   |   \
      / \                   C   *D    B
     /   \                (w:8)(w:8)(w:16)
    C    *D
 (w:16) (w:16)


 R(C)=16/(16+16)=1/2 ==>  R(C)=8/(8+16)=1/3
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能向一个流创建依赖关系的优先级信息还在传输中，那个流就已经关闭了。如果一个依赖流的依赖指向没有相关优先级信息(即父节点无效)，则这个依赖流会分配默认优先级，这可能会造成不理想的优先级，因为给流分配了不在预期的优先级。</p><p>为了避免上述问题，一个端点应该在流关闭后的一段时间内保留流的优先级调整状态信息，此状态保留时间越长，流被分配错误的或者默认的优先级可能性越低。</p><p>类似地，处于“空闲”状态的流可以被分配优先级或成为其他流的父节点。这允许在依赖关系树中创建分组节点，从而实现更灵活的优先级表达式。空闲流以默认优先级开始</p><p>流优先级状态信息的保留可能增加终端的负担，因此这种状态可以被限制。终端可能根据负荷来决定保留的额外的状态的数目；在高负荷下，可以丢弃额外的优先级状态来限制资源的任务。在极端情况下，终端甚至可以丢弃激活或者保留状态流的优先级信息。如果使用了固定的限制，终端应当至少保留跟 SETTINGS_MAX_CONCURRENT_STREAMS 设置一样大小的流状态</p><h5 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h5><p>所有流都是初始为非独占地依赖于流 0x0。</p><p>Pushed 流初始依赖于相关的流(见 Server-Push)。</p><p>以上两种情况，流的权重都指定为 16。</p><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server-Push"></a>Server-Push</h3><h4 id="PUSH-PROMISE-帧格式"><a href="#PUSH-PROMISE-帧格式" class="headerlink" title="PUSH_PROMISE 帧格式"></a>PUSH_PROMISE 帧格式</h4><pre class="line-numbers language-http"><code class="language-http"> +---------------+
 |Pad Length? (8)|
 +-+-------------+-----------------------------------------------+
 |R|                  Promised Stream ID (31)                    |
 +-+-----------------------------+-------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
 |                           Padding (*)                       ...
 +---------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Pad Length</code>: 指定 Padding 长度，存在则代表 PADDING flag 被设置</li><li><code>R</code>: 保留的1bit位</li><li><code>Promised Stream ID</code>: 31 位的无符号整数，代表 PUSH_PROMISE 帧保留的流，对于发送者来说该流标识符必须是可用于下一个流的有效值</li><li><code>Header Block Fragment</code>: 包含请求首部域的首部块片段</li><li><code>Padding</code>: 填充字节，没有具体语义，作用与 DATA 的 Padding 一样，存在则代表 PADDING flag 被设置</li></ul><p>PUSH_PROMISE 帧有以下标识 (flags):</p><ul><li>END_HEADERS: bit 2 置 1 代表 header 块结束</li><li>PADDED: bit 3 置 1 代表 Pad 被设置，存在 Pad Length 和 Padding</li></ul><h4 id="Push-的过程"><a href="#Push-的过程" class="headerlink" title="Push 的过程"></a>Push 的过程</h4><p>结合上文关于 Server-Push 的流状态转换</p><p>PUSH_PROMISE 帧只能在对端(客户端)发起的且流状态为 open 或者 half-closed (remote) 的流上发送</p><p>PUSH_PROMISE 帧准备推送的响应总是和来自于客户端的请求相关联。服务端在该请求所在的流上发送 PUSH_PROMISE 帧。PUSH_PROMISE 帧包含一个 Promised Stream ID，该流标识符是从服务端可用的流标识符里选出来的。</p><p>如果服务端收到了一个对文档的请求，该文档包含内嵌的指向多个图片文件的链接，且服务端选择向客户端推送那些额外的图片，那么在发送包含图片链接的 DATA 帧之前发送 PUSH_PROMISE 帧可以确保客户端在发现内嵌的链接之前，能够知道有一个资源将要被推送过来。同样地，如果服务端准备推送被首部块引用的响应 (比如，在 <a href="https://www.w3.org/wiki/LinkHeader" target="_blank" rel="noopener">Link 首部字段</a> 里的)，在发送首部块之前发送一个 PUSH_PROMISE 帧，可以确保客户端不再请求那些资源</p><p>一旦客户端收到了 PUSH_PROMISE 帧，并选择接收被推送的响应，客户端就不应该为准备推送的响应发起任何请求，直到预示的流被关闭以后。</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_1.png" title="image" data-fancybox="images" data-caption="PUSH_PROMISE_1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_2.png" title="image" data-fancybox="images" data-caption="PUSH_PROMISE_2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/PUSH_PROMISE_2.png" src="/img/loading.gif" title="image" alt="image"></a></p><blockquote><p>注意图中推送的四个资源各预示了一个流 (Promised Stream ID)，而发送 PUSH_PROMISE 帧的还是在客户端发起的请求流 (Stream Identifier = 1) 上，客户端收到 PUSH_PROMISE 帧并选择接收便不会对这四个资源发起请求，之后服务端会发起预示的流然后推送资源相关的响应</p></blockquote><p>不管出于什么原因，如果客户端决定不再从服务端接收准备推送的响应，或者如果服务端花费了太长时间准备发送被预示的响应，客户端可以发送一个 RST_STREAM 帧，该帧可以使用 CANCEL 或者 REFUSED_STEAM 码，并引用被推送的流标识符。</p><h4 id="nginx-配置-Server-Push"><a href="#nginx-配置-Server-Push" class="headerlink" title="nginx 配置 Server-Push"></a>nginx 配置 Server-Push</h4><blockquote><p>server-push 需要服务端设置，并不是说浏览器发起请求，与此请求相关的资源服务端就会自动推送</p></blockquote><p>以 nginx 为例，从版本 1.13.9 开始正式支持 hppt2 serverpush 功能，</p><p>在相应 server 或 location 模块中加入 <code>http2_push</code> 字段加上相对路径的文件即可在请求该资源时推送相关资源，比如我的博客设置如下，访问首页时有四个文件会由服务器主动推送过去而不需要客户端请求:</p><pre class="line-numbers language-nginx"><code class="language-nginx">  <span class="token keyword">server_name</span>  blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>
  <span class="token keyword">root</span> <span class="token operator">/</span>blog<span class="token punctuation">;</span>
  <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>

  <span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span><span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token punctuation">{</span>
    http2_push <span class="token operator">/</span>css<span class="token operator">/</span>style<span class="token punctuation">.</span>css<span class="token punctuation">;</span>
    http2_push <span class="token operator">/</span>js<span class="token operator">/</span>main<span class="token punctuation">.</span>js<span class="token punctuation">;</span>
    http2_push <span class="token operator">/</span>img<span class="token operator">/</span>yule<span class="token punctuation">.</span>jpg<span class="token punctuation">;</span>
    http2_push <span class="token operator">/</span>img<span class="token operator">/</span>avatar<span class="token punctuation">.</span>jpg<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过浏览器控制台可以查看 <code>Push</code> 响应:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/server-push.png" title="image" data-fancybox="images" data-caption="server-push.png"><img data-original="https://src.wangriyu.wang/images/blog/http/server-push.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>也可以用 <code>nghttp</code> 测试 push 响应 (* 号代表是服务端推送的):</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/nghttp-serverpush.png" title="image" data-fancybox="images" data-caption="nghttp-serverpush.png"><img data-original="https://src.wangriyu.wang/images/blog/http/nghttp-serverpush.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>上面 <code>http2_push</code> 的设置适合静态资源，服务端事先知道哪些文件是客户端需要的，然后选择性推送</p><p>假如是后台应用动态生成的文件(比如 json 文件)，服务器事先不知道要推送什么，可以用 <code>Link</code> 响应头来做自动推送</p><p>在 server 模块中添加 <code>http2_push_preload on;</code></p><pre class="line-numbers language-nginx"><code class="language-nginx">  <span class="token keyword">server_name</span>  blog<span class="token punctuation">.</span>wangriyu<span class="token punctuation">.</span>wang<span class="token punctuation">;</span>
  <span class="token keyword">root</span> <span class="token operator">/</span>blog<span class="token punctuation">;</span>
  <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>

  http2_push_preload on<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后设置响应头 (add_header) 或者后台程序生成数据文件返回时带上响应头 Link 标签，比如</p><pre class="line-numbers language-stylus"><code class="language-stylus"><span class="token property-declaration"><span class="token property">Link</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">.</span>css<span class="token operator">></span><span class="token punctuation">;</span> as<span class="token operator">=</span>style<span class="token punctuation">;</span> rel<span class="token operator">=</span>preload<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">/</span>main<span class="token operator">.</span>js<span class="token operator">></span><span class="token punctuation">;</span> as<span class="token operator">=</span>script<span class="token punctuation">;</span> rel<span class="token operator">=</span>preload<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token operator">/</span>image<span class="token operator">.</span>jpg<span class="token operator">></span><span class="token punctuation">;</span> as<span class="token operator">=</span>image<span class="token punctuation">;</span> rel<span class="token operator">=</span>preload</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nginx 会根据 Link 响应头主动推送这些资源</p><p>更多nginx 官方介绍见 <a href="https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/" target="_blank" rel="noopener">Introducing HTTP/2 Server Push with NGINX 1.13.9</a></p><h4 id="Server-Push-潜在的问题"><a href="#Server-Push-潜在的问题" class="headerlink" title="Server-Push 潜在的问题"></a>Server-Push 潜在的问题</h4><p>看了这篇文章 <a href="https://imququ.com/post/server-push-in-http2.html" target="_blank" rel="noopener">HTTP/2 中的 Server Push 讨论</a>，发现 Server-Push 有个潜在的问题</p><p>Server-Push 满足条件时便会发起推送，可是客户端已经有缓存了想发送 RST 拒收，而服务器在收到 RST 之前已经推送资源了，虽然这部分推送无效但是肯定会占用带宽</p><p>比如我上面博客关于 http2_push 的配置，我每次打开首页服务器都会推送那四个文件，而实际上浏览器知道自己有缓存使用的也是本地缓存，也就是说本地缓存未失效的期间内，服务器的 Server-Push 只是起到了占用带宽的作用</p><p>当然实际上对我的小站点来说影响并不大，但是如果网站需要大量推送的话，需要考虑并测试 Server-Push 是否会影响用户的后续访问</p><p>另外服务端可以设置 Cookie 或者 Session 记录访问时间，然后之后的访问判断是否需要 Push；还有就是客户端可以限制 PUSH 流的数目，也可以设置一个很低的流量窗口来限制 PUSH 发送的数据大小</p><p>至于哪些资源需要推送，在《web 性能权威指南》中就提到几种策略，比如 Apache 的 mod_spdy 能够识别 X-Associated-Content 首部，当中列出了希望服务器推送的资源；另外网上有人已经做了基于 Referer 首部的中间件来处理 Server-Push；或者服务端能更智能的识别文档，根据当前流量决定是否推送或者推送那些资源。相信以后会有更多关于 Server-Push 的实现和应用</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>多路复用的流会竞争 TCP 资源，进而导致流被阻塞。流控制机制确保同一连接上的流不会相互干扰。流量控制作用于单个流或整个连接。HTTP/2 通过使用 WINDOW_UPDATE 帧来提供流量控制。</p><p>流控制具有以下特征:</p><ul><li>流量控制是特定于连接的。两种级别的流量控制都位于单跳的端点之间，而不是整个端到端的路径。比如 server 前面有一个 front-end proxy 如 Nginx，这时就会有两个 connection，browser-Nginx, Nginx—server，flow control 分别作用于两个 connection。详情见: <a href="https://stackoverflow.com/questions/40747040/how-is-http-2-hop-by-hop-flow-control-accomplished" target="_blank" rel="noopener">How is HTTP/2 hop-by-hop flow control accomplished? - stackoverflow</a></li><li>流量控制是基于 WINDOW_UPDATE 帧的。接收方公布自己打算在每个流以及整个连接上分别接收多少字节。这是一个以信用为基础的方案。</li><li>流量控制是有方向的，由接收者全面控制。接收方可以为每个流和整个连接设置任意的窗口大小。发送方必须尊重接收方设置的流量控制限制。客户方、服务端和中间代理作为接收方时都独立地公布各自的流量控制窗口，作为发送方时都遵守对端的流量控制设置。</li><li>无论是新流还是整个连接，流量控制窗口的初始值是 65535 字节。</li><li>帧的类型决定了流量控制是否适用于帧。目前，只有 DATA 帧会受流量控制影响，所有其它类型的帧并不消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞。</li><li>流量控制不能被禁用。</li><li>HTTP/2 只定义了 WINDOW_UPDATE 帧的格式和语义，并没有规定接收方如何决定何时发送帧、发送什么样的值，也没有规定发送方如何选择发送包。具体实现可以选择任何满足需求的算法。</li></ul><h4 id="WINDOW-UPDATE-帧格式"><a href="#WINDOW-UPDATE-帧格式" class="headerlink" title="WINDOW_UPDATE 帧格式"></a>WINDOW_UPDATE 帧格式</h4><pre class="line-numbers language-http"><code class="language-http">+-+-------------------------------------------------------------+
|R|                Window Size Increment (31)                   |
+-+-------------------------------------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Window Size Increment 表示除了现有的流量控制窗口之外，发送端还可以传送的字节数。取值范围是 1 到 2^31 - 1 字节。</p><p>WINDOW_UPDATE 帧可以是针对一个流或者是针对整个连接的。如果是前者，WINDOW_UPDATE 帧的流标识符指明了受影响的流；如果是后者，流标识符为 0 表示作用于整个连接。</p><p>流量控制功能只适用于被标识的、受流量控制影响的帧。文档定义的帧类型中，只有 DATA 帧受流量控制影响。除非接收端不能再分配资源去处理这些帧，否则不受流量控制影响的帧必须被接收并处理。如果接收端不能再接收帧了，可以响应一个 FLOW_CONTROL_ERROR 类型的流错误或者连接错误。</p><p>WINDOW_UPDATE 可以由发送过带有 END_STREAM 标志的帧的对端发送。这意味着接收端可能会在 half-closed (remote) 或者 closed 状态的流上收到 WINDOW_UPDATE 帧，接收端不能将其当做错误。</p><h4 id="流量控制窗口"><a href="#流量控制窗口" class="headerlink" title="流量控制窗口"></a>流量控制窗口</h4><p>流量控制窗口是一个简单的整数值，指出了准许发送端传送的数据的字节数。窗口值衡量了接收端的缓存能力。</p><p>除非将其当做连接错误，否则当接收端收到 DATA 帧时，必须总是从流量控制窗口中减掉其长度(不包括帧头的长度，而且两个级别的控制窗口都要减)。即使帧有错误，这也是有必要的，因为发送端已经将该帧计入流量控制窗口，如果接收端没有这样做，发送端和接收端的流量控制窗口就会不一致。</p><p>发送端不能发送受流量控制影响的、其长度超出接收端告知的两种级别的流量控制窗口可用空间的帧。即使这两种级别的流量控制窗口都没有可用空间了，也可以发送长度为 0、设置了 END_STREAM 标志的帧(即空的 DATA 帧)。</p><p>当帧的接收端消耗了数据并释放了流量控制窗口的空间时，可以发送一个 WINDOW_UPDATE 帧。对于流级别和连接级别的流量控制窗口，需要分别发送 WINDOW_UPDATE 帧。</p><p>新建连接时，流和连接的初始窗口大小都是 2^16 - 1(65535) 字节。可以通过设置连接前言中 SETTINGS 帧的 SETTINGS_INITIAL_WINDOW_SIZE 参数改变流的初始窗口大小，这会作用于所有流。而<code>连接的初始窗口大小不能改，但可以用 WINDOW_UPDATE 帧来改变流量控制窗口</code>，这是为什么连接前言往往带有一个 WINDOW_UPDATE 帧的原因。</p><p>除了改变还未激活的流的流量控制窗口外，SETTIGNS 帧还可以改变已活跃的流 (处于 open 或 half-closed (remote) 状态的流)的初始流量控制窗口的大小。也就是说，当 SETTINGS_INITIAL_WINDOW_SIZE 的值变化时，接收端必须调整它所维护的所有流的流量控制窗口的值，不管是之前就打开的流还是尚未打开的流。</p><p>改变 SETTINGS_INITIAL_WINDOW_SIZE 可能引发流量控制窗口的可用空间变成负值。发送端必须追踪负的流量控制窗口，并且直到它收到了使流量控制窗口变成正值的 WINDOW_UPDATE 帧，才能发送新的 DATA 帧。</p><p>例如，如果连接一建立客户端就立即发送 60KB 的数据，而服务端却将初始窗口大小设置为 16KB，那么客户端一收到 SETTINGS 帧，就会将可用的流量控制窗口重新计算为 -44KB。客户端保持负的流量控制窗口，直到 WINDOW_UPDATE 帧将窗口值恢复为正值，客户端才可以继续发送数据。</p><p>如果改变 SETTINGS_INITIAL_WINDOW_SIZE 导致流量控制窗口超出了最大值，一端必须 将其当做类型为 FLOW_CONTROL_ERROR 的连接错误</p><p>如果接收端希望使用比当前值小的流量控制窗口，可以发送一个新的 SETTINGS 帧。但是，接收端必须准备好接收超出该窗口值的数据，因为可能在收到 SETTIGNS 帧之前，发送端已经发送了超出该较小窗口值的数据。</p><h4 id="合理使用流控制"><a href="#合理使用流控制" class="headerlink" title="合理使用流控制"></a>合理使用流控制</h4><p>流量控制的定义是用来保护端点在资源约束条件下的操作。例如，一个代理需要在很多连接之间共享内存，也有可能有缓慢的上游连接和快速的下游连接。流量控制解决了接收方无法在一个流上处理数据，但仍希望继续处理同一连接中的其他流的情况。</p><p>不需要此功能的部署可以通告最大大小 (2^31 - 1) 的流量控制窗口，并且可以通过在收到任何数据时发送 WINDOW_UPDATE 帧来维护此窗口大小保持不变。这可以有效禁用接受方的流控制。相反地，发送方总是受控于接收方通告的流控制窗口的限制。</p><p>资源约束下(例如内存)的调度可以使用流量来限制一个对端可以消耗的内存量。需要注意的是如果在不知道带宽延迟积的时候启用流量控制可能导致无法最优的利用可用的网络资源 (RFC1323)。</p><p>即便是对当前的网络延迟乘积有充分的认识，流量控制的实现也可能很复杂。当使用流量控制时，接收端必须及时地从 TCP 接收缓冲区读取数据。这样做可能导致在一些例如 WINDOW_UPDATE 的关键帧在 HTTP/2 不可用时导致死锁。但是流量控制可以保证约束资源能在不需要减少连接利用的情况下得到保护。</p><h3 id="HTTP-2-的协议协商机制"><a href="#HTTP-2-的协议协商机制" class="headerlink" title="HTTP/2 的协议协商机制"></a>HTTP/2 的协议协商机制</h3><h4 id="非加密下的协商-h2c"><a href="#非加密下的协商-h2c" class="headerlink" title="非加密下的协商 - h2c"></a>非加密下的协商 - h2c</h4><p>客户端使用 HTTP Upgrade 机制请求升级，HTTP2-Settings 首部字段是一个专用于连接的首部字段，它包含管理 HTTP/2 连接的参数(使用 Base64 编码)，其前提是假设服务端会接受升级请求</p><pre class="line-numbers language-http"><code class="language-http"> GET / HTTP/1.1
 Host: server.example.com
 Connection: Upgrade, HTTP2-Settings
 Upgrade: h2c
 HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器如果支持 http/2 并同意升级，则转换协议，否则忽略</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">101 Switching Protocols</span></span>
<span class="token header-name keyword">Connection:</span> Upgrade
<span class="token header-name keyword">Upgrade:</span> h2c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时潜在的存在一个流 0x1，客户端上这个流在完成 h1 请求后便转为 <code>half-closed</code> 状态，服务端会用这个流返回响应</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-1.png" title="image" data-fancybox="images" data-caption="h1-&gt;h2-1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-2.png" title="image" data-fancybox="images" data-caption="h1-&gt;h2-2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-3.png" title="image" data-fancybox="images" data-caption="h1-&gt;h2-3.png"><img data-original="https://src.wangriyu.wang/images/blog/http/h1-&gt;h2-3.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>注意图中第一个响应所在的流是 0x1，与上文所说的一致</p><p>目前浏览器只支持 TLS 加密下的 HTTP/2 通信，所以上述情况在浏览器中目前是不可能碰到的，图中显示的是 nghttp 客户端发起的请求</p><h4 id="加密的协商机制-h2"><a href="#加密的协商机制-h2" class="headerlink" title="加密的协商机制 - h2"></a>加密的协商机制 - h2</h4><p>TLS 加密中在 Client-Hello 和 Server-Hello 的过程中通过 <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">ALPN</a> 进行协议协商</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_1.png" title="image" data-fancybox="images" data-caption="application_layer_protocol_negotiation_1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>应用层协议协商在 TLS 握手第一步的扩展中，Client Hello 中客户端指定 ALPN Next Protocol 为 h2 或者 http/1.1 说明客户端支持的协议</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_2.png" title="image" data-fancybox="images" data-caption="application_layer_protocol_negotiation_2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/application_layer_protocol_negotiation_2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>服务端如果在 Server Hello 中选择 h2 扩展，说明协商协议为 h2，后续请求响应跟着变化；如果服务端未设置 http/2 或者不支持 h2，则继续用 http/1.1 通信</p><h3 id="分析实例"><a href="#分析实例" class="headerlink" title="分析实例"></a>分析实例</h3><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/all-frames.png" title="image" data-fancybox="images" data-caption="all-frames.png"><img data-original="https://src.wangriyu.wang/images/blog/http/all-frames.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>196: TLS 握手第一步 Client Hello，开始协议协商，且此处带上了 Session Ticket</p><p>200: Server Hello 同意使用 h2，而且客户端的会话票证有效，恢复会话，握手成功</p><p>202: 客户端也恢复会话，开始加密后续消息</p><p>205: 服务端发起一个连接前言 (SETTINGS)，SETTINGS 帧中设置了最大并行流数量、初始窗口大小、最大帧长度，然后 (WINDOW_UPDATE) 扩大窗口大小</p><p>310: 客户端也发送一个连接前言 Magic，并初始化设置 (SETTINGS)，SETTINGS 帧中设置了 HEADER TABLE 大小、初始窗口大小、最大并行流数量，然后 (WINDOW_UPDATE) 扩大窗口大小</p><p>311: 客户端发送完连接前言后可以立即跟上一个请求，GET / (HEADERS[1])，而且这个 HEADERS 帧还带有 END_STREAM，这会使流 1 从 idle 状态立即转为 half-closed(local) 状态 (open 是中间态)</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/all-frames-1.png" title="image" data-fancybox="images" data-caption="all-frames-1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/all-frames-1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>311: 此消息中还包含一个客户端发送给服务端的带 ACK 的 SETTINGS 帧</p><p>312: 服务端也响应带 ACK 的 SETTINGS 帧</p><p>321: 服务端在流 1 (此时状态为 half-closed(remote)) 上发送了四个 PUSH_PROMISE 帧，它们分别保留了流 2、4、6、8 用于后续推送，</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/all-frames-2.png" title="image" data-fancybox="images" data-caption="all-frames-2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/all-frames-2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>321: 此消息中还返回了上面请求的响应 (HEADERS - DATA)，最后 DATA 带上 END_STREAM，流 1 从 half-closed 转为 closed</p><p>329: 调整流优先级，依赖关系: 8 -&gt; 6 -&gt; 4 -&gt; 2 -&gt; 1 (都带有独占标志，而且权重均为 110)</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/priority-1.png" title="image" data-fancybox="images" data-caption="priority-1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/priority-1.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>342: 流 1 关闭后，流 2 得到分配资源，服务器开始推送，数据由两个 DATA 帧返回</p><p>344: 流 2 结束，开始推送流 4</p><p>356: 调整依赖关系</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/priority-2.png" title="image" data-fancybox="images" data-caption="priority-2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/priority-2.png" src="/img/loading.gif" title="image" alt="image"></a></p><pre class="line-numbers language-http"><code class="language-http">  1         1         1         1(w: 110)
  |         |         |         |
  2         2         2         2(w: 110)
  |         |         |         |
  4   ==>   4   ==>   6   ==>   6(w: 147)
  |         |         |         |
  6         8         4         8(w: 147)
  |         |         |         |
  8         6         8         4(w: 110)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>367、369、372: 推送 6 和 8 的流数据</p><p>377: 发起一个请求，打开流 3，其中客户端发起的请求都是依赖流 0x0</p><p>之后都是同样的套路完成请求 - 响应，最后以 GOAWAY 帧关闭连接结束</p><h3 id="HPACK-算法"><a href="#HPACK-算法" class="headerlink" title="HPACK 算法"></a>HPACK 算法</h3><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/hpack.png" title="image" data-fancybox="images" data-caption="hpack.png"><img data-original="https://src.wangriyu.wang/images/blog/http/hpack.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>上图来自 Ilya Grigorik 的 PPT - <a href="#references">HTTP/2 is here, let’s optimize!</a></p><p>可以清楚地看到 HTTP2 头部使用的也是键值对形式的值，而且 HTTP1 当中的请求行以及状态行也被分割成键值对，还有所有键都是小写，不同于 HTTP1。除此之外，还有一个包含静态索引表和动态索引表的索引空间，实际传输时会把头部键值表压缩，使用的算法即 HPACK，其原理就是匹配当前连接存在的索引空间，若某个键值已存在，则用相应的索引代替首部条目，比如 “:method: GET” 可以匹配到静态索引中的 index 2，传输时只需要传输一个包含 2 的字节即可；若索引空间中不存在，则用字符编码传输，字符编码可以选择哈夫曼编码，然后分情况判断是否需要存入动态索引表中</p><h4 id="索引表"><a href="#索引表" class="headerlink" title="索引表"></a>索引表</h4><h5 id="静态索引"><a href="#静态索引" class="headerlink" title="静态索引"></a>静态索引</h5><p>静态索引表是固定的，对于客户端服务端都一样，目前协议商定的静态索引包含 61 个键值，详见 <a href="https://httpwg.org/specs/rfc7541.html#static.table.definition" target="_blank" rel="noopener">Static Table Definition - RFC 7541</a></p><p>比如前几个如下</p><table><thead><tr><th style="text-align:left">索引</th><th style="text-align:left">字段值</th><th style="text-align:left">键值</th></tr></thead><tbody><tr><td style="text-align:left">index</td><td style="text-align:left">Header Name</td><td style="text-align:left">Header Value</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">:authority</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">:method</td><td style="text-align:left">GET</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">:method</td><td style="text-align:left">POST</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">:path</td><td style="text-align:left">/</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">:path</td><td style="text-align:left">/index.html</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">:scheme</td><td style="text-align:left">http</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">:scheme</td><td style="text-align:left">https</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">:status</td><td style="text-align:left">200</td></tr></tbody></table><h5 id="动态索引"><a href="#动态索引" class="headerlink" title="动态索引"></a>动态索引</h5><p>动态索引表是一个 FIFO 队列维护的有空间限制的表，里面含有非静态表的索引。<br>动态索引表是需要连接双方维护的，其内容基于连接上下文，一个 HTTP2 连接有且仅有一份动态表。<br>当一个首部匹配不到索引时，可以选择把它插入动态索引表中，下次同名的值就可能会在表中查到索引并替换。<br>但是并非所有首部键值都会存入动态索引，因为动态索引表是有空间限制的，最大值由 SETTING 帧中的 SETTINGS_HEADER_TABLE_SIZE (默认 4096 字节) 设置</p><ul><li>如何计算动态索引表的大小 (Table Size):</li></ul><p>大小均以字节为单位，动态索引表的大小等于所有条目大小之和，每个条目的大小 = 字段长度 + 键值长度 + 32</p><blockquote><p>这个额外的 32 字节是预估的条目开销，比如一个条目使用了两个 64-bit 指针分别指向字段和键值，并使用两个 64-bit 整数来记录字段和键值的引用次数</p><p>golang 实现也是加上了 32: <a href="https://github.com/golang/net/blob/db08ff08e8622530d9ed3a0e8ac279f6d4c02196/http2/hpack/hpack.go#L61" target="_blank" rel="noopener">golang.org/x/net/http2/hpack/hpack.go#L61</a></p></blockquote><p>SETTING 帧规定了动态表的最大大小，但编码器可以另外选择一个比 SETTINGS_HEADER_TABLE_SIZE 小的值作为动态表的有效负载量</p><ul><li>如何更新动态索引表的最大容量</li></ul><p>修改最大动态表容量可以发送一个 <code>dynamic table size update</code> 信号来更改:</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前缀 001 代表此字节为 <code>dynamic table size update</code> 信号，后面使用 <strong>N=5 的整数编码方法</strong>表示新的最大动态表容量(不能超过 SETTINGS_HEADER_TABLE_SIZE)，其计算方法下文会介绍。</p><p>需要注意的是这个信号必须在首部块发送之前或者两个首部块传输的间隔发送，可以通过发送一个 Max size 为 0 的更新信号来清空现有动态表</p><ul><li>动态索引表什么时候需要驱逐条目</li></ul><ol><li>每当出现表大小更新的信号时，需要判断并驱逐队尾的条目，即旧的索引，直到当前大小小于等于新的容量</li><li>每当插入新条目时，需要判断并驱逐队尾的条目，直到当前大小小于等于容量。这个情形下插入一个比 Max size 还大的新条目不会视作错误，但其结果是会清空动态索引表</li></ol><blockquote><p>关于动态索引表如何管理的，推荐看下 golang 的实现: <a href="https://github.com/golang/net/blob/db08ff08e8622530d9ed3a0e8ac279f6d4c02196/http2/hpack/hpack.go#L157" target="_blank" rel="noopener">golang.org/x/net/http2/hpack/hpack.go#L157</a>，通过代码能更明白这个过程</p></blockquote><h5 id="索引地址空间"><a href="#索引地址空间" class="headerlink" title="索引地址空间"></a>索引地址空间</h5><p>由静态索引表和动态索引表可以组成一个索引地址空间:</p><pre class="line-numbers language-http"><code class="language-http">  &lt;----------  Index Address Space ---------->
  &lt;-- Static  Table -->  &lt;-- Dynamic Table -->
  +---+-----------+---+  +---+-----------+---+
  | 1 |    ...    | s |  |s+1|    ...    |s+k|
  +---+-----------+---+  +---+-----------+---+
                         ⍋                   |
                         |                   ⍒
                  Insertion Point      Dropping Point
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前 s 就是 61，而有新键值要插入动态索引表时，从 index 62 开始插入队列，所以动态索引表中索引从小到大依次存着从新到旧的键值</p><h4 id="编码类型表示"><a href="#编码类型表示" class="headerlink" title="编码类型表示"></a>编码类型表示</h4><p>HPACK 编码使用两种原始类型: 无符号可变长度整数和八位字节表示的字符串，相应地规定了以下两种编码方式</p><h5 id="整数编码"><a href="#整数编码" class="headerlink" title="整数编码"></a>整数编码</h5><p>一个整数编码可以用于表示字段索引值、首部条目索引值或者字符串长度。<br>一个整数编码含两部分: 一个前缀字节和可选的后跟字节序列，只有前缀字节不足以表达整数值时才需要后跟字节，<strong>前缀字节中可用比特位 N 是整数编码的一个参数</strong></p><p>比如下面所示的是一个 N=5 的整数编码(前三比特用于其他标识)，如果我们要编码的整数值小于 2^N - 1，直接用一个前缀字节表示即可，比如 10 就用 <code>???01010</code> 表示</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| ? | ? | ? |       Value       |
+---+---+---+-------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果要编码的整数值 X 大于等于 2^N - 1，前缀字节的可用比特位都设成 1，然后把 X 减去 2^N - 1 得到值 R，并用一个或多个字节序列表示 R，字节序列中每个字节的最高有效位 (msb) 用于表示是否结束，<strong>msb 设为 0 时代表是最后一个字节</strong>。具体编码看下面的伪代码和例子</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| ? | ? | ? | 1   1   1   1   1 |
+---+---+---+-------------------+
| 1 |    Value-(2^N-1) LSB      |
+---+---------------------------+
               ...
+---+---------------------------+
| 0 |    Value-(2^N-1) MSB      |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编码:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">if</span> I <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> encode I on N bits
<span class="token keyword">else</span>
    <span class="token function">encode</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> on N bits
    I <span class="token operator">=</span> I <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    while I <span class="token operator">>=</span> <span class="token number">128</span>
         <span class="token function">encode</span> <span class="token punctuation">(</span>I <span class="token operator">%</span> <span class="token number">128</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span> on <span class="token number">8</span> bits
         I <span class="token operator">=</span> I <span class="token operator">/</span> <span class="token number">128</span>
    encode I on <span class="token number">8</span> bits
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解码:</p><pre class="line-numbers language-go"><code class="language-go">decode I from the next N bits
<span class="token keyword">if</span> I <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">^</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">return</span> I
<span class="token keyword">else</span>
    M <span class="token operator">=</span> <span class="token number">0</span>
    repeat
        B <span class="token operator">=</span> next octet
        I <span class="token operator">=</span> I <span class="token operator">+</span> <span class="token punctuation">(</span>B <span class="token operator">&amp;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span>M
        M <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">7</span>
    while B <span class="token operator">&amp;</span> <span class="token number">128</span> <span class="token operator">==</span> <span class="token number">128</span>
    <span class="token keyword">return</span> I
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如使用 N=5 的整数编码表示 1337:</p><p>1337 大于 31 (2^5 - 1), 将前缀字节后五位填满 1</p><p>I = 1337 - (2^5 - 1) = 1306</p><p>I 仍然大于 128, I % 128 = 26, 26 + 128 = 154</p><p>154 二进制编码: 10011010, 这即是第一个后跟字节</p><p>I = 1306 / 128 = 10, I 小于 128, 循环结束</p><p>将 I 编码成二进制: 00001010, 这即是最后一个字节</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306 >= 128, encode(154), I=1306/128=10
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10 &lt; 128, encode(10), done
+---+---+---+---+---+---+---+---+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解码时读取第一个字节，发现后五位 (11111) 对应的值 I 等于 31(&gt;= 2^N - 1)，说明还有后跟字节；令 M=0，继续读下一个字节 B，I = I + (B &amp; 127) * 2^M = 31 + 26 * 1 = 57，M = M + 7 = 7，最高有效位为 1，表示字节序列未结束，B 指向下一个字节；I = I + (B &amp; 127) * 2^M = 57 + 10 * 128 = 1337，最高有效位为 0，表示字节码结束，返回 I</p><blockquote><p>这里也可以这样处理 1306: 1306 = 0x51a = (0101 0001 1010)B，将 bit 序列从低到高按 7 个一组分组，则有第一组 001 1010，第二组 000 1010，加上最高有效位 0/1 便与上面的后跟字节对应</p></blockquote><h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5><p>一个字符串可能代表 Header 条目的字段或者键值。字符编码使用字节序列表示，要么直接使用字符的八位字节码要么使用哈夫曼编码。</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| H |    String Length (7+)     |
+---+---------------------------+
|  String Data (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>H: 一个比特位表示是否使用哈夫曼编码</li><li>String Length: 代表字节序列长度，即 String Data 的长度，使用 N=7 的整数编码方式表示</li><li>String Data: 字符串的八位字节码序列表示，如果 H 为 0，则此处就是原字符的八位字节码表示；如果 H 为 1，则此处为原字符的哈夫曼编码</li></ul><p>RFC 7541 给出了一份字符的哈夫曼编码表: <a href="https://httpwg.org/specs/rfc7541.html#huffman.code" target="_blank" rel="noopener">Huffman Code</a>，这是基于大量 HTTP 首部数据生成的哈夫曼编码。</p><ul><li>当中第一列 (sym) 表示要编码的字符，最后的特殊字符 “EOS” 代表字符串结束</li><li>第二列 (code as bits) 是二进制哈夫曼编码，向最高有效位对齐</li><li>第三列 (code as hex) 是十六进制哈夫曼编码，向最低有效位对齐</li><li>最后一列 (len) 代表编码长度，单位 bit</li></ul><p>使用哈夫曼编码可能存在编码不是整字节的，会在后面填充 1 使其变成整字节</p><p>比如下面的例子:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-IndexedName.png" title="Literal Header Field with Incremental Indexing - Indexed Name" data-fancybox="images" data-caption="Literal-Header-Field-with-Incremental-Indexing-IndexedName.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-IndexedName.png" src="/img/loading.gif" title="Literal Header Field with Incremental Indexing - Indexed Name" alt="Literal Header Field with Incremental Indexing - Indexed Name"></a></p><p><code>:authority: blog.wangriyu.wang</code> 首部对应的编码为:</p><pre class="line-numbers language-http"><code class="language-http">41 8e 8e 83 cc bf 81 d5    35 86 f5 6a fe 07 54 df
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Literal Header Field with Incremental Indexing — Indexed Name</code> 的编码格式见下文</p><p>41 (0100 0001) 表示字段存在索引值 1，即对应静态表中第一项 :authority</p><p>8e (1000 1110) 最高有效位为 1 表示键值使用哈夫曼编码，000 1110 表示字节序列长度为 14</p><p>后面 <code>8e 83 cc bf 81 d5 35 86 f5 6a fe 07 54 df</code> 是一段哈夫曼编码序列</p><p>由哈夫曼编码表可知 100011 -&gt; ‘b’, 101000 -&gt; ‘l’, 00111 -&gt; ‘o’, 100110 -&gt; ‘g’, 010111 -&gt; ‘.’, 1111000 -&gt; ‘w’, 00011 -&gt; ‘a’, 101010 -&gt; ‘n’, 100110 -&gt; ‘g’, 101100 -&gt; ‘r’, 00110 -&gt; ‘i’, 1111010 -&gt; ‘y’, 101101 -&gt; ‘u’</p><pre class="line-numbers language-http"><code class="language-http">8e 83 cc bf 81 d5 35 86 f5 6a fe 07 54 df
                         |
                         ⍒
1000 1110 1000 0011 1100 1100 1011 1111 1000 0001 1101 0101 0011 0101 1000 0110 1111 0101 0110 1010 1111 1110 0000 0111 0101 0100 1101 1111
                         |
                         ⍒
100011 101000 00111 100110 010111 1111000 00011 101010 100110 101100 00110 1111010 101101 010111 1111000 00011 101010 100110 11111
                         |
                         ⍒
blog.wangriyu.wang  最后 11111 用于填充
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h4><p>现在开始是 HPACK 真正的编解码规范</p><h5 id="已索引首部条目表示-Indexed-Header-Field-Representation"><a href="#已索引首部条目表示-Indexed-Header-Field-Representation" class="headerlink" title="已索引首部条目表示 (Indexed Header Field Representation)"></a>已索引首部条目表示 (Indexed Header Field Representation)</h5><ul><li><code>Indexed Header Field</code></li></ul><p>以 1 开始为标识，能在索引空间匹配到索引的首部会替换成这种形式，后面的 index 使用上述的整数编码方式且 N = 7。<br>比如 <code>:method: GET</code> 可以用 0x82，即 10000010 表示</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Indexed-Header-Field.png" title="Indexed Header Field" data-fancybox="images" data-caption="Indexed-Header-Field.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Indexed-Header-Field.png" src="/img/loading.gif" title="Indexed Header Field" alt="Indexed Header Field"></a></p><h5 id="未索引文字首部条目表示-Literal-Header-Field-Representation"><a href="#未索引文字首部条目表示-Literal-Header-Field-Representation" class="headerlink" title="未索引文字首部条目表示 (Literal Header Field Representation)"></a>未索引文字首部条目表示 (Literal Header Field Representation)</h5><p>尚未被索引的首部有三种表示形式，第一种会添加进索引，第二种对于当前跳来说不会添加进索引，第三种绝对不被允许添加进索引</p><ol><li>会添加索引的文字首部 (Literal Header Field with Incremental Indexing)</li></ol><p>以 01 开始为标识，此首部会加入到解码后的首部列表 (Header List) 中并且会把它<strong>作为新条目插入到动态索引表中</strong></p><ul><li><code>Literal Header Field with Incremental Indexing — Indexed Name</code></li></ul><p>如果字段已经存在索引，但键值未被索引，比如首部 <code>:authority: blog.wangriyu.wang</code> 的字段 <code>:authority</code> 已存在索引但键值 <code>blog.wangriyu.wang</code> 不存在索引，则会替换成如下形式 (index 使用 N=6 的整数编码表示)</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-IndexedName.png" title="Literal Header Field with Incremental Indexing - Indexed Name" data-fancybox="images" data-caption="Literal-Header-Field-with-Incremental-Indexing-IndexedName.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-IndexedName.png" src="/img/loading.gif" title="Literal Header Field with Incremental Indexing - Indexed Name" alt="Literal Header Field with Incremental Indexing - Indexed Name"></a></p><ul><li><code>Literal Header Field with Incremental Indexing — New Name</code></li></ul><p>如果字段和键值均未被索引，比如 <code>upgrade-insecure-requests: 1</code>，则会替换成如下形式</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-NewName.png" title="Literal Header Field with Incremental Indexing — New Name" data-fancybox="images" data-caption="Literal-Header-Field-with-Incremental-Indexing-NewName.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-with-Incremental-Indexing-NewName.png" src="/img/loading.gif" title="Literal Header Field with Incremental Indexing — New Name" alt="Literal Header Field with Incremental Indexing — New Name"></a></p><ol start="2"><li>不添加索引的首部 (Literal Header Field without Indexing)</li></ol><p>以 0000 开始为标识，此首部会加入到解码后的首部列表中，但<strong>不会插入到动态索引表中</strong></p><ul><li><code>Literal Header Field without Indexing — Indexed Name</code></li></ul><p>如果字段已经存在索引，但键值未被索引，则会替换成如下形式 (index 使用 N=4 的整数编码表示)</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-without-Indexing-IndexedName.png" title="Literal Header Field without Indexing - Indexed Name" data-fancybox="images" data-caption="Literal-Header-Field-without-Indexing-IndexedName.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-without-Indexing-IndexedName.png" src="/img/loading.gif" title="Literal Header Field without Indexing - Indexed Name" alt="Literal Header Field without Indexing - Indexed Name"></a></p><ul><li><code>Literal Header Field without Indexing — New Name</code></li></ul><p>如果字段和键值均未被索引，则会替换成如下形式。比如 <code>strict-transport-security: max-age=63072000; includeSubdomains</code></p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-without-Indexing-NewName.png" title="Literal Header Field without Indexing - New Name" data-fancybox="images" data-caption="Literal-Header-Field-without-Indexing-NewName.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Literal-Header-Field-without-Indexing-NewName.png" src="/img/loading.gif" title="Literal Header Field without Indexing - New Name" alt="Literal Header Field without Indexing - New Name"></a></p><ol start="3"><li>绝对不添加索引的首部 (Literal Header Field Never Indexed)</li></ol><p>这与上一种首部类似，只是标识为 0001，首部也是会添加进解码后的首部列表中但不会插入动态更新表。</p><p>区别在于这类首部发出是什么格式表示，接收也是一样的格式，作用于每一跳 (hop)，如果中间通过代理，代理必须原样转发不能另行编码。</p><p>而上一种首部只是作用当前跳，通过代理后可能会被重新编码</p><p>golang 实现中使用一个 <code>Sensitive</code> 标明哪些字段是绝对不添加索引的: <a href="https://github.com/golang/net/blob/db08ff08e8622530d9ed3a0e8ac279f6d4c02196/http2/hpack/hpack.go#L41" target="_blank" rel="noopener">golang.org/x/net/http2/hpack/hpack.go#L41</a></p><p>RFC 文档中详细说明了这么做的原因: <a href="https://httpwg.org/specs/rfc7541.html#never.indexed.literals" target="_blank" rel="noopener">Never-Indexed Literals</a></p><p>表示形式除了标识其他都跟上一种首部一样:</p><ul><li><code>Literal Header Field Never Indexed — Indexed Name</code></li></ul><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Literal Header Field Never Indexed — New Name</code></li></ul><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="动态表最大容量更新-Dynamic-Table-Size-Update"><a href="#动态表最大容量更新-Dynamic-Table-Size-Update" class="headerlink" title="动态表最大容量更新 (Dynamic Table Size Update)"></a>动态表最大容量更新 (Dynamic Table Size Update)</h5><p>以 001 开始为标识，作用前面已经提过</p><pre class="line-numbers language-http"><code class="language-http">+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---------------------------+
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Dynamic-Table-Size-Update-0.png" title="Literal Header Field without Indexing - Indexed Name" data-fancybox="images" data-caption="Dynamic-Table-Size-Update-0.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Dynamic-Table-Size-Update-0.png" src="/img/loading.gif" title="Literal Header Field without Indexing - Indexed Name" alt="Literal Header Field without Indexing - Indexed Name"></a></p><p>可以发送 Max Size 为 0 的更新来清空动态索引表</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/Dynamic-Table-Size-Update-1.png" title="Literal Header Field without Indexing - Indexed Name" data-fancybox="images" data-caption="Dynamic-Table-Size-Update-1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/Dynamic-Table-Size-Update-1.png" src="/img/loading.gif" title="Literal Header Field without Indexing - Indexed Name" alt="Literal Header Field without Indexing - Indexed Name"></a></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>RFC 中给出了很多实例 <a href="https://httpwg.org/specs/rfc7541.html#examples" target="_blank" rel="noopener">Examples - RFC 7541</a>，推荐看一遍加深理解</p><h2 id="What-then"><a href="#What-then" class="headerlink" title="What then ?"></a>What then ?</h2><h3 id="HTTP-2-演示"><a href="#HTTP-2-演示" class="headerlink" title="HTTP/2 演示"></a>HTTP/2 演示</h3><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a></p><p><a href="https://http2.golang.org/" target="_blank" rel="noopener">https://http2.golang.org/</a></p><p>网站启用 h2 的前后对比，使用 <a href="http://www.webpagetest.org/" target="_blank" rel="noopener">WebPageTest</a> 做的测试，第一张是 h1，第二张是 h2:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/webtest-h1.png" title="image" data-fancybox="images" data-caption="webtest-h1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/webtest-h1.png" src="/img/loading.gif" title="image" alt="image"></a><br><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/webtest-h2.png" title="image" data-fancybox="images" data-caption="webtest-h2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/webtest-h2.png" src="/img/loading.gif" title="image" alt="image"></a></p><h3 id="使用-HTTP-2-建议"><a href="#使用-HTTP-2-建议" class="headerlink" title="使用 HTTP/2 建议"></a>使用 HTTP/2 建议</h3><p>nginx 开启 HTTP2 只需在相应的 HTTPS 设置后加上 <code>http2</code> 即可</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">443</span> <span class="token keyword">ssl</span> http2 ipv6only<span class="token operator">=</span>on<span class="token punctuation">;</span>
<span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="以下几点是-HTTP-1-和-HTTP-2-都同样适用的"><a href="#以下几点是-HTTP-1-和-HTTP-2-都同样适用的" class="headerlink" title="以下几点是 HTTP/1 和 HTTP/2 都同样适用的"></a>以下几点是 HTTP/1 和 HTTP/2 都同样适用的</h4><p>1、开启压缩</p><p>配置 gzip 等可以使传输内容更小，传输速度更快</p><p>例如 nginx 可以再 http 模块中加入以下字段，其他字段和详细解释可以谷歌</p><pre class="line-numbers language-nginx"><code class="language-nginx">    <span class="token keyword">gzip</span>  on<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 开启
    <span class="token keyword">gzip_min_length</span> 1k<span class="token punctuation">;</span>
    <span class="token keyword">gzip_comp_level</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 压缩级别
    <span class="token keyword">gzip_types</span> text<span class="token operator">/</span>plain application<span class="token operator">/</span>javascript application<span class="token operator">/</span>x<span class="token operator">-</span>javascript application<span class="token operator">/</span>octet<span class="token operator">-</span>stream application<span class="token operator">/</span>json text<span class="token operator">/</span>css application<span class="token operator">/</span>xml text<span class="token operator">/</span>javascript application<span class="token operator">/</span>x<span class="token operator">-</span>httpd<span class="token operator">-</span>php image<span class="token operator">/</span>jpeg image<span class="token operator">/</span>gif image<span class="token operator">/</span>png font<span class="token operator">/</span>ttf font<span class="token operator">/</span>otf image<span class="token operator">/</span>svg<span class="token operator">+</span>xml<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span> 需要压缩的文件类型
    <span class="token keyword">gzip_vary</span> on<span class="token punctuation">;</span>
    <span class="token keyword">gzip_disable</span> <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、使用缓存</p><p>给静态资源设置一个缓存期是非常有必要的，关于缓存见另一篇博文 <code>HTTP Message</code></p><p>例如 nginx 在 server 模块中添加以下字段可以设置缓存时间</p><pre class="line-numbers language-nginx"><code class="language-nginx"> <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>ico<span class="token operator">|</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token operator">|</span>png<span class="token operator">|</span>moc<span class="token operator">|</span>mtn<span class="token operator">|</span>mp3<span class="token operator">|</span><span class="token keyword">mp4</span><span class="token operator">|</span>mov<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
   <span class="token keyword">expires</span>      30d<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>css<span class="token operator">|</span>js<span class="token operator">|</span>txt<span class="token operator">|</span>xml<span class="token operator">|</span>swf<span class="token operator">|</span>wav<span class="token operator">|</span>json<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
   <span class="token keyword">expires</span>      5d<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>html<span class="token operator">|</span>htm<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">expires</span>      24h<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> <span class="token operator">^</span><span class="token punctuation">.</span><span class="token operator">+</span>\<span class="token punctuation">.</span><span class="token punctuation">(</span>eot<span class="token operator">|</span>ttf<span class="token operator">|</span>otf<span class="token operator">|</span>woff<span class="token operator">|</span>svg<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>
   <span class="token keyword">access_log</span>   off<span class="token punctuation">;</span>
   <span class="token keyword">expires</span> 30d<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、CDN 加速</p><p>CDN 的好处是就近访问，延迟低，访问快</p><p>4、减少 DNS 查询</p><p>每个域名都需要 DNS 查询，一般需要几毫秒到几百毫秒，移动环境下会更慢。DNS 解析完成之前，请求会被阻塞。减少 DNS 查询也是优化项之一</p><p>浏览器的 <a href="https://en.wikipedia.org/wiki/Link_prefetching" target="_blank" rel="noopener">DNS Prefetching</a> 技术也是一种优化手段</p><p>5、减少重定向</p><p>重定向可能引入新的 DNS 查询、新的 TCP 连接以及新的 HTTP 请求，所以减少重定向也很重要。</p><p>浏览器基本都会缓存通过 301 Moved Permanently 指定的跳转，所以对于永久性跳转，可以考虑使用状态码 301。对于启用了 HTTPS 的网站，配置 HSTS 策略，也可以减少从 HTTP 到 HTTPS 的重定向</p><h4 id="但以下几点就不推荐在-HTTP-2-中用了"><a href="#但以下几点就不推荐在-HTTP-2-中用了" class="headerlink" title="但以下几点就不推荐在 HTTP/2 中用了"></a>但以下几点就不推荐在 HTTP/2 中用了</h4><p>1、域名分片</p><p>HTTP/2 对于同一域名使用一个 TCP 连接足矣，过多 TCP 连接浪费资源而且效果不见得一定好</p><p>而且资源分域会破坏 HTTP/2 的优先级特性，还会降低头部压缩效果</p><p>2、资源合并</p><p>资源合并会不利于缓存机制，而且单文件过大对于 HTTP/2 的传输不好，尽量做到细粒化更有利于 HTTP/2 传输</p><p>3、资源内联</p><p>HTTP/2 支持 Server-Push，相比较内联优势更大效果更好</p><p>而且内联的资源不能有效缓存</p><p>如果有共用，多页面内联也会造成浪费</p><h4 id="HTTP-2-最佳实践"><a href="#HTTP-2-最佳实践" class="headerlink" title="HTTP/2 最佳实践"></a>HTTP/2 最佳实践</h4><p>使用 HTTP/2 尽可能用最少的连接，因为同一个连接上产生的请求和响应越多，动态字典积累得越全，头部压缩效果也就越好，而且多路复用效率高，不会像多连接那样造成资源浪费</p><p>为此需要注意以下两点:</p><ul><li>同一域名下的资源使用同一个连接，这是 HTTP/2 的特性</li><li>不同域名下的资源，如果满足能解析到同一 IP 或者使用的是同一个证书(比如泛域名证书)，HTTP/2 可以合并多个连接</li></ul><p>所以使用相同的 IP 和证书部署 Web 服务是目前最好的选择，因为这让支持 HTTP/2 的终端可以复用同一个连接，实现 HTTP/2 协议带来的好处；而只支持 HTTP/1.1 的终端则会不同域名建立不同连接，达到同时更多并发请求的目的</p><p>比如 Google 一系列网站都是用的同一个证书:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/google-dns.png" title="image" data-fancybox="images" data-caption="google-dns.png"><img data-original="https://src.wangriyu.wang/images/blog/http/google-dns.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>但是这好像也会造成一个问题，我使用 nginx 搭建的 webserver，有三个虚拟主机，它们共用一套证书，其中两个我显示地配置了 http2，而剩下一个我并没有配置 http2，结果我访问未配置 http2 的站点时也变成了 http2。</p><h3 id="大图片传输碰到的问题"><a href="#大图片传输碰到的问题" class="headerlink" title="大图片传输碰到的问题"></a>大图片传输碰到的问题</h3><p>先比较一下 h1 和 h2 的页面加载时间，图中绿色代表发起请求收到响应等待负载的时间，蓝色代表下载负载的时间:</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h1.png" title="image" data-fancybox="images" data-caption="imgs-loadtime-h1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h1.png" src="/img/loading.gif" title="image" alt="image"></a><br><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h2.png" title="image" data-fancybox="images" data-caption="imgs-loadtime-h2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/imgs-loadtime-h2.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>可以发现 h2 加载时间还比 h1 慢一点，特别是碰到大图片时差别更明显</p><p>这篇文章对不同场景下 h1 和 h2 加载图片做了测试: <a href="https://99designs.com/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/" target="_blank" rel="noopener">Real–world HTTP/2: 400gb of images per day</a></p><p>其结果是:</p><ul><li><p>对一个典型的富图像，延迟限制 (latency–bound) 的界面来说。使用一个高速，低延迟的连接，视觉完成度 (visual completion) 平均会快 5%。</p></li><li><p>对一个图像极其多，带宽限制 (bandwidth–bound) 的页面来说。使用同样的连接，视觉完成度平均将会慢 5–10%，但页面的整体加载时间实际是减少了，因为得益于连接延迟少。</p></li><li><p>一个高延迟，低速度的连接(比如移动端的慢速 3G) 会对页面的视觉完成造成极大的延迟，但 h2 的视觉完成度明显更高更好。</p></li></ul><p>在所有的测试中，都可以看到: h2 使整体页面的加载速度提高了，并且在初次绘制 (initial render) 上做的更好，虽然第二种情况中视觉完成度略微下降，但总体效果还是好的</p><p>视觉完成度下降的原因是因为没有 HTTP/1.x 同时连接数量的限制，h2 可以同时发起多张图片的请求，服务器可以同时响应图片的负载，可以从下面的动图中看到</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/safari-h2.gif" title="image" data-fancybox="images" data-caption="safari-h2.gif"><img data-original="https://src.wangriyu.wang/images/blog/http/safari-h2.gif" src="/img/loading.gif" title="image" alt="image"></a></p><p>一旦图片下载完成，浏览器就会绘制出它们，然而，小图片下载后会渲染地更快，但是如果一个大图片恰好是初始的视图，那就会花费较长的时间加载，延迟视觉上的完成度。</p><h4 id="chrome-bug"><a href="#chrome-bug" class="headerlink" title="chrome bug"></a>chrome bug</h4><p>上面的动图是在 Safari 上的测试结果，图片最后都下载成功了，而我在 Chrome 上测试时后面的部分图片直接挂了，都报 <code>ERR_SPDY_PROTOCOL_ERROR</code> 错误，而且是百分百复现</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/chrome-h2.gif" title="image" data-fancybox="images" data-caption="chrome-h2.gif"><img data-original="https://src.wangriyu.wang/images/blog/http/chrome-h2.gif" src="/img/loading.gif" title="image" alt="image"></a></p><p>去看了下 <code>ERR_SPDY_PROTOCOL_ERROR</code> 出在哪，发现是 Server reset stream，应该是哪出错了导致流提前终止</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/spdyerror-0.png" title="image" data-fancybox="images" data-caption="spdyerror-0.png"><img data-original="https://src.wangriyu.wang/images/blog/http/spdyerror-0.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>然后再研究了一下 HTTP/2 的帧序列，发出的请求都在 629 号消息中响应成功了，但是返回的数据帧只有流 15 上的，实际收到的图片又不止流 15 对应的图片，这是为什么?</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-0.png" title="image" data-fancybox="images" data-caption="large-imgs-problem-0.png"><img data-original="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-0.png" src="/img/loading.gif" title="image" alt="image"></a></p><p>后面我继续测试发现连续请求几张大图片，虽然 HEADERS 帧都打开的是不同的流，返回的响应的 HEADERS 帧也还是对应前面的流 ID，但是响应的 DATA 帧都是从第一个打开的流上返回的。</p><p>如果是小图片的话，一个请求响应过后这个流就关闭了，下一张小图是在其自己对应的流上返回的。只有连续几张大图会出现上述情形，这个机制很奇怪，我暂时还没有找到解释的文档。</p><p>至于 chrome 为什么出错呢，看一下 TCP 报文就会发现所有数据在一个连接上发送，到后面 TCP 包会出现各种问题，丢包、重传、失序、重包等等，不清楚 Safari 是否也是这样，因为 wireshark 只能解 chrome 的包解不了 Safari 的包</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-1.png" title="image" data-fancybox="images" data-caption="large-imgs-problem-1.png"><img data-original="https://src.wangriyu.wang/images/blog/http/large-imgs-problem-1.png" src="/img/loading.gif" title="image" alt="image"></a></p><blockquote><p>《web 性能权威指南》中提及 HTTP/2 中一个 TCP 可能会造成的问题:<br>虽然消除了 HTTP 队首阻塞现象，但 TCP 层次上仍存在队首阻塞问题；如果 TCP 窗口缩放被禁用，那<a href="https://zh.wikipedia.org/wiki/%E5%B8%A6%E5%AE%BD%E6%97%B6%E5%BB%B6%E4%B9%98%E7%A7%AF" target="_blank" rel="noopener">带宽延迟积效应</a>可能会限制连接的吞吐量；丢包时 TCP 拥塞窗口会缩小；</p></blockquote><p>TCP 是一方面原因，还有另一方面应该是浏览器策略问题，估计也是 chrome bug，对比两张动图你会发现，safari 接收负载是轮流接收，我们几个接收一点然后换几个人接收，直到所有都接受完；而 chrome 则是按顺序接收，这个接收完才轮到下一个接收，结果后面的图片可能长时间未响应就挂了。</p><h4 id="使用渐进式图片"><a href="#使用渐进式图片" class="headerlink" title="使用渐进式图片"></a>使用渐进式图片</h4><p>渐进式 jpg 代替普通 jpg 有利于提高视觉完成度，而且文件更小:</p><p>输入 <code>convert --version</code> 看看是否已安装 <a href="http://www.imagemagick.org/" target="_blank" rel="noopener">ImageMagic</a>，如果没有先安装: Mac 可以用 <code>brew install imagemagick</code>，Centos 可以用 <code>yum install imagemagick</code></p><p>检测是否为 progressive jpeg，如果输出 None 说明不是 progressive jpeg；如果输出 JPEG 说明是 progressive jpeg:</p><pre class="line-numbers language-bash"><code class="language-bash">$ identify -verbose filename.jpg <span class="token operator">|</span> <span class="token function">grep</span> Interlace
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 basic jpeg 转换成 progressive jpeg，<a href="https://www.imagemagick.org/script/command-line-options.php#interlace" target="_blank" rel="noopener">interlace 参数</a>:</p><pre class="line-numbers language-bash"><code class="language-bash">$ convert -strip -interlace Plane source.jpg destination.jpg // 还可以指定质量 -quality 90

// 批量处理
$ <span class="token keyword">for</span> i <span class="token keyword">in</span> ./*.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> convert -strip -interlace Plane <span class="token variable">$i</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也可以转换 PNG 和 GIF，但是我试过 <code>convert -strip -interlace Plane source.png destination.png</code> 但转换后的图片往往会更大，不推荐这么用，可以 convert source.png destination.jpg</p><p>ImageMagic 还有很多强大的功能</p><pre class="line-numbers language-bash"><code class="language-bash">// 图片缩放
$ convert -resize 50%x50% source.jpg destination.jpg
// 图片格式转换
$ convert source.jpg destination.png
// 配合 <span class="token function">find</span> 命令，将当前目录下大于 100kb 的图片按 75% 质量进行压缩
$ <span class="token function">find</span> -E <span class="token keyword">.</span> -iregex <span class="token string">'.*\.(jpg|png|bmp)'</span> -size +100k -exec convert -strip +profile “*” -quality 75 <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>png 压缩推荐使用 <a href="https://pngquant.org/" target="_blank" rel="noopener">pngquant</a></p><p>另外 photoshop 保存图片时也可以设置渐进或交错:</p><p>渐进式图片：选择图片格式为 JPEG =&gt; 选中“连续”</p><p>交错式图片：选择图片格式为 PNG/GIF =&gt; 选中“交错”</p><h3 id="SPDY-与-HTTP2-的关系"><a href="#SPDY-与-HTTP2-的关系" class="headerlink" title="SPDY 与 HTTP2 的关系"></a>SPDY 与 HTTP2 的关系</h3><p><a href="https://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a> 是 HTTP2 的前身，大部分特性与 HTTP2 保持一致，包括服务器端推送，多路复用和帧作为传输的最小单位。但 SPDY 与 HTTP2 也有一些实现上的不同，比如 SPDY 的头部压缩使用的是 DEFLATE 算法，而 HTTP2 使用的是 HPACK 算法，压缩率更高。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>Google 的 <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">QUIC(Quick UDP Internet Connections)</a> 协议，继承了 SPDY 的特点。QUIC 是一个 UDP 版的 TCP + TLS + HTTP/2 替代实现。</p><p>QUIC 可以创建更低延迟的连接，并且也像 HTTP/2 一样，通过仅仅阻塞部分流解决了包裹丢失这个问题，让连接在不同网络上建立变得更简单 － 这其实正是 <a href="https://en.wikipedia.org/wiki/Multipath_TCP" target="_blank" rel="noopener">MPTCP</a> 想去解决的问题。</p><p>QUIC 现在还只有 Google 的 Chrome 和它后台服务器上的实现，虽然有第三方库 libquic，但这些代码仍然很难在其他地方被复用。该协议也被 IETF 通信工作组引入了草案。</p><p><a href="https://github.com/mholt/caddy" target="_blank" rel="noopener">Caddy</a>: 基于 Go 语言开发的 Web Server， 对 HTTP/2 和 HTTPS 有着良好的支持，也开始支持 QUIC 协议 (试验性)</p><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><ul><li>Chrome 插件: <a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">HTTP/2 and SPDY indicator</a></li></ul><p>如果你访问的站点开启了 HTTP/2，图标会亮起，而且点击会进入 chrome 内置的 HTTP/2 监视工具</p><ul><li>命令行工具: <a href="https://github.com/nghttp2/nghttp2" target="_blank" rel="noopener">nghttp2</a></li></ul><p>C 语言实现的 HTTP/2，可以用它调试 HTTP/2 请求</p><p>直接 <code>brew install nghttp2</code> 就可以安装，安装好后输入 <code>nghttp -nv https://nghttp2.org</code> 就可以查看 h2 请求</p><p><a class="fancy-ctn" href="https://src.wangriyu.wang/images/blog/http/nghttp2.png" title="image" data-fancybox="images" data-caption="nghttp2.png"><img data-original="https://src.wangriyu.wang/images/blog/http/nghttp2.png" src="/img/loading.gif" title="image" alt="image"></a></p><ul><li><p>除 nghttp2 外还可以用 h2i 测试 http2: <a href="https://github.com/golang/net/blob/master/http2/h2i/README.md" target="_blank" rel="noopener">https://github.com/golang/net/blob/master/http2/h2i/README.md</a></p></li><li><p>还可以用 wireshark 解 h2 的包，不过得设置浏览器提供的对称协商密钥或者服务器提供的私钥，具体方法看此文: <a href="https://imququ.com/post/http2-traffic-in-wireshark.html" target="_blank" rel="noopener">使用 Wireshark 调试 HTTP/2 流量</a></p></li></ul><p>如果无法解包看一下 sslkeylog.log 文件有没有写入数据，如果没有数据说明浏览器打开方式不对，得用命令行打开浏览器，这样才能让浏览器读取环境变量然后向 sslkeylog 写入密钥，另外此方法好像支持谷歌浏览器和火狐，对 Safari 无效</p><p>如果 sslkeylog.log 有数据，wireshark 还是无法解包，打开设置的 SSL 选项重新选择一下文件试试，如果还是不行也用命令行打开 Wireshark</p><p>一次不行多试几次</p><ul><li><a href="https://github.com/h2o/h2o" target="_blank" rel="noopener">h2o</a>: 优化的 HTTP Server，对 HTTP/2 的支持性做的比较好</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.slideshare.net/qgy18/http2-55366951" target="_blank" rel="noopener">HTTP/2: 新的机遇与挑战</a></li><li><a href="https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.p19" target="_blank" rel="noopener">HTTP2 is here, let’s optimize!</a></li><li><a href="https://imququ.com/post/series.html" target="_blank" rel="noopener">JerryQu’s Blog</a></li><li><a href="https://daniel.haxx.se/http2/" target="_blank" rel="noopener">http2 explained</a></li><li><a href="https://cdn-1.wp.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf" target="_blank" rel="noopener">NGINX HTTP2 White Paper</a></li><li><a href="https://calendar.perfplanet.com/2016/http2-push-the-details/" target="_blank" rel="noopener">HTTP/2 Push: The details</a></li><li>《web 性能权威指南》</li></ul></div></div><div class="copyright"><p><span>本文标题:</span><a href="/2018/05-HTTP2.html">HTTP2 详解</a></p><p><span>文章作者:</span><a href="/" title="回到主页">鱼乐</a></p><p><span>发布时间:</span>2018-05-19, 00:00:00</p><p><span>最后更新:</span>2018-12-22, 13:31:45</p><p><span>原始链接:</span><a class="post-url" href="/2018/05-HTTP2.html" title="HTTP2 详解">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。</p></div><nav id="article-nav"><div id="article-nav-newer" class="article-nav-title"><a href="/2018/05-server-ftp.html">CentOS 搭建 FTP 服务</a></div><div id="article-nav-older" class="article-nav-title"><a href="/2018/05-server-git.html">博客搬家</a></div></nav></article><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-use-it"><span class="toc-text">Why use it ?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1-存在的问题"><span class="toc-text">HTTP/1.1 存在的问题:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2-的优势"><span class="toc-text">HTTP2 的优势:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、二进制分帧层-Binary-Framing-Layer"><span class="toc-text">1、二进制分帧层 (Binary Framing Layer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、多路复用-MultiPlexing"><span class="toc-text">2、多路复用 (MultiPlexing)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、服务端推送-Server-Push"><span class="toc-text">3、服务端推送 (Server Push)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、Header-压缩-HPACK"><span class="toc-text">4、Header 压缩 (HPACK)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、应用层的重置连接"><span class="toc-text">5、应用层的重置连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、请求优先级设置"><span class="toc-text">6、请求优先级设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、流量控制"><span class="toc-text">7、流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、HTTP-1-的几种优化可以弃用"><span class="toc-text">8、HTTP/1 的几种优化可以弃用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-does-it-work"><span class="toc-text">How does it work ?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#帧-Frame"><span class="toc-text">帧 - Frame</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#帧的结构"><span class="toc-text">帧的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DATA-帧格式"><span class="toc-text">DATA 帧格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEADERS-帧格式"><span class="toc-text">HEADERS 帧格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#首部的压缩与解压缩"><span class="toc-text">首部的压缩与解压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SETTINGS-帧格式"><span class="toc-text">SETTINGS 帧格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流-Stream"><span class="toc-text">流 - Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#流的状态"><span class="toc-text">流的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#idle"><span class="toc-text">idle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reserved-local-reserved-remote"><span class="toc-text">reserved (local) / reserved (remote)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#open"><span class="toc-text">open</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#half-closed-local"><span class="toc-text">half-closed (local)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#half-closed-remote"><span class="toc-text">half-closed (remote)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#closed"><span class="toc-text">closed</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#流状态的转换"><span class="toc-text">流状态的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流的标识符"><span class="toc-text">流的标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流的优先级"><span class="toc-text">流的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#流依赖-Stream-Dependencies"><span class="toc-text">流依赖(Stream Dependencies)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#依赖权重"><span class="toc-text">依赖权重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优先级调整-Reprioritization"><span class="toc-text">优先级调整 (Reprioritization)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#流优先级的状态管理"><span class="toc-text">流优先级的状态管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#默认优先级"><span class="toc-text">默认优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server-Push"><span class="toc-text">Server-Push</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSH-PROMISE-帧格式"><span class="toc-text">PUSH_PROMISE 帧格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Push-的过程"><span class="toc-text">Push 的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx-配置-Server-Push"><span class="toc-text">nginx 配置 Server-Push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server-Push-潜在的问题"><span class="toc-text">Server-Push 潜在的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流量控制"><span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WINDOW-UPDATE-帧格式"><span class="toc-text">WINDOW_UPDATE 帧格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流量控制窗口"><span class="toc-text">流量控制窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合理使用流控制"><span class="toc-text">合理使用流控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-的协议协商机制"><span class="toc-text">HTTP/2 的协议协商机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非加密下的协商-h2c"><span class="toc-text">非加密下的协商 - h2c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加密的协商机制-h2"><span class="toc-text">加密的协商机制 - h2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析实例"><span class="toc-text">分析实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HPACK-算法"><span class="toc-text">HPACK 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引表"><span class="toc-text">索引表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#静态索引"><span class="toc-text">静态索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态索引"><span class="toc-text">动态索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#索引地址空间"><span class="toc-text">索引地址空间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编码类型表示"><span class="toc-text">编码类型表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#整数编码"><span class="toc-text">整数编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符编码"><span class="toc-text">字符编码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二进制编码"><span class="toc-text">二进制编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#已索引首部条目表示-Indexed-Header-Field-Representation"><span class="toc-text">已索引首部条目表示 (Indexed Header Field Representation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#未索引文字首部条目表示-Literal-Header-Field-Representation"><span class="toc-text">未索引文字首部条目表示 (Literal Header Field Representation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态表最大容量更新-Dynamic-Table-Size-Update"><span class="toc-text">动态表最大容量更新 (Dynamic Table Size Update)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例"><span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-then"><span class="toc-text">What then ?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-演示"><span class="toc-text">HTTP/2 演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-HTTP-2-建议"><span class="toc-text">使用 HTTP/2 建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#以下几点是-HTTP-1-和-HTTP-2-都同样适用的"><span class="toc-text">以下几点是 HTTP/1 和 HTTP/2 都同样适用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#但以下几点就不推荐在-HTTP-2-中用了"><span class="toc-text">但以下几点就不推荐在 HTTP/2 中用了</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2-最佳实践"><span class="toc-text">HTTP/2 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大图片传输碰到的问题"><span class="toc-text">大图片传输碰到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chrome-bug"><span class="toc-text">chrome bug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用渐进式图片"><span class="toc-text">使用渐进式图片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPDY-与-HTTP2-的关系"><span class="toc-text">SPDY 与 HTTP2 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC-协议"><span class="toc-text">QUIC 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#推荐工具"><span class="toc-text">推荐工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-text">References</span></a></li></ol></div><style>.left-col .switch-area,.left-col .switch-btn{display:none}.toc-level-6 i,.toc-level-6 ol{display:none!important}</style><input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录"><script>yiliaConfig.toc=["隐藏目录","显示目录",!0],$(".left-col").is(":hidden")&&$("#tocButton").attr("value",yiliaConfig.toc[1])</script><div class="share"><link rel="stylesheet" type="text/css" href="/share/iconfont.css"><link rel="stylesheet" href="/share/spongebob.min.css" type="text/css" media="all"><div class="social_share"><ul id="social_list" class="social_icon_list"></ul></div><script>var shareConfig={title:"HTTP2 详解",url:window.location.href,author:"鱼乐",img:"https://src.wangriyu.wang/images/blog/avatar.jpg"}</script><script src="/share/qrcode.min.js"></script><script src="/share/spongebob.min.js"></script></div><section id="comments" style="margin:2em;padding:2em;background:rgba(255,255,255,.5)"><link rel="stylesheet" href="//src.wangriyu.wang/lib/gitalk/gitalk.min.css"><script src="//src.wangriyu.wang/lib/gitalk/gitalk.min.js"></script><div id="gitalk-container"></div><script type="text/javascript">var gitalk=new Gitalk({clientID:"f7029005e9b4b35463e1",clientSecret:"62c9e6339c73778f29fd10eea90ea5aeb4f15427",repo:"wangriyu.github.io",owner:"wangriyu",admin:["wangriyu"],id:window.location.pathname});gitalk.render("gitalk-container")</script></section><div class="scroll" id="post-nav-button"><a href="/2018/05-server-ftp.html" title="上一篇: CentOS 搭建 FTP 服务"><i class="fa fa-angle-left"></i> </a><a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a> <a href="/2018/05-server-git.html" title="下一篇: 博客搬家"><i class="fa fa-angle-right"></i></a></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08-Jenkins.html">Jenkins + Ansible 实现 Golang 自动化编译部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-ELK.html">从零开始搭建一套日志收集分析系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08-Linux_libc.html">解决 Linux “GLIBCXX_* not found” 问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07-root.html">Mac 系统如何解锁、root、刷 Android 手机</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-Distribution.html">分布式相关理论和分布式事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-share.html">浏览器的 Copy 事件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-Hash.html">数据结构 - 哈希</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-Tree.html">数据结构 - 树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06-Aplayer.html">使用 Aplayer 导致博客目录跳转失效</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-server-nextcloud.html">搭建 docker 环境并用 docker 部署 nextcloud 网盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-server-ftp.html">CentOS 搭建 FTP 服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-HTTP2.html">HTTP2 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05-server-git.html">博客搬家</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04-go-http.html">Golang http/server</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04-go-rpc.html">Golang RPC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04-http-pki.html">PKI 体系</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03-http-tls.html">SSL/TLS 详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03-http-message.html">HTTP Message</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03-valine.html">更换博客评论系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01-githubpage.html">GithubPages 绑定二级域名并开启 HTTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12-Dart V.html">Dart 语法入门 V</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12-MacStorageExpansion.html">极具性价比的 Mac 存储扩展方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12-Win+Ubuntu.html">UEFI + GPT + Win10 + Ubuntu + rEFInd</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12-Dart IV.html">Dart 语法入门 IV</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11-masm.html">masm for mac</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11-Dart III.html">Dart 语法入门 III</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10-Dart II.html">Dart 语法入门 II</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10-MacSkills.html">Mac 快速入门操作指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10-Dart I.html">Dart 语法入门 I</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09-ShareArtifact.html">分享自用的一些软件、插件、网站和应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08-Hexo.html">使用 Hexo 主题 Yelee</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08-Storage.html">浏览器本地存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08-SystemIO.html">系统 I/O</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06-JSNote3.html">0611-JS 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05-JSNote2.html">0507-JS 笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04-JSNote1.html">0423-JS 笔记</a></li></ul><script></script></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"><i class="fa fa-copyright"></i> 2017-2018 冀-18010769-1</div><div class="visit"><span id="busuanzi_container_site_pv" style="display:none"><span id="site-visit" title="本站到访人数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span> </span></span><span>| </span><span id="busuanzi_container_page_pv" style="display:none"><span id="page-visit" title="本页访问次数"><i class="fa fa-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span></span></span></div><div class="footer-right"><i class="fa fa-heart"></i><a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架"> Hexo</a> Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a></div></div></div></footer></div><script type="application/javascript">var hide=!1,leftWidth=312;$(".hide-left-col").click(function(){hide?($(".left-col").width(leftWidth),$(".left-col .intrude-less").fadeIn(200),$("#tocButton").fadeIn(200),"block"===$("#switch-btn").css("display")&&"block"===$("#switch-area").css("display")||$("#toc").fadeIn(200),$(".hide-left-col").css("left",leftWidth).html('<i class="fa fa-angle-double-left"></i>'),$(".mid-col").css("left",leftWidth),$("#post-nav-button").css("left",leftWidth),$("#post-nav-button > a:nth-child(2)").css("display","block"),hide=!1):($(".left-col").width(0),$(".left-col .intrude-less").fadeOut(200),$("#toc").fadeOut(100),$("#tocButton").fadeOut(100),$(".hide-left-col").css("left",0).html('<i class="fa fa-angle-double-right"></i>'),$(".mid-col").css("left",0),$("#post-nav-button").css("left",0),$("#post-nav-button > a:nth-child(2)").css("display","none"),$(".post-list").is(":visible")&&($("#post-nav-button .fa-bars,#post-nav-button .fa-times").toggle(),$(".post-list").toggle()),hide=!0)})</script><script data-main="/js/main.js" src="//src.wangriyu.wang/lib/requirejs/require.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[["$$","$$"],["$","$"],["\\(","\\)"]],processEscapes:!0,skipTags:["script","noscript","style","textarea","pre","code"]}}),MathJax.Hub.Queue(function(){var a,e=MathJax.Hub.getAllJax();for(a=0;a<e.length;a+=1)e[a].SourceElement().parentNode.className+=" has-jax"})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script><div class="scroll" id="scroll"><a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a> <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a> <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a></div><script>var oOpenInNew={post:".copyright a[href]",friends:"#js-friends a",socail:".social a"};for(var x in oOpenInNew)$(oOpenInNew[x]).attr("target","_blank")</script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂)"+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*)~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script async src="https://src.wangriyu.wang/lib/busuanzi/busuanzi.pure.mini.js"></script></div><link href="//src.wangriyu.wang/lib/aos/aos.css" rel="stylesheet"><script type="text/javascript">AOS.init({easing:"ease-out-back",once:!0})</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/izumi.model.json"},"display":{"position":"right","width":100,"height":200,"hOffset":-50,"vOffset":-85},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.3},"pluginJsPath":"lib/","pluginModelPath":"assets/"});</script><script>!function(o){var l=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),c=o.innerWidth||document.documentElement.clientWidth||document.body.clientWidth;function n(){for(var t=0,e=l.length;t<e;t++)n=l[t],void 0,0<=(i=n.getBoundingClientRect()).top&&0<=i.left&&i.top<=(o.innerHeight||document.documentElement.clientHeight)&&(l[t].src=l[t].getAttribute("data-original"),l[t].onload=function(t){var e=t.target||t.path[0];e.width>c/2&&(e.style.maxWidth=c<=768?"100%":"50%")},l.splice(t,1),e=l.length,t--);var n,i}n(),o.addEventListener("scroll",function(){var t,e;t=n,e=o,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)},!1)}(this);</script></body>